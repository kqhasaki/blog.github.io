<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.948481160c9db913da32.css" data-identity="gatsby-global-css">.modal-wrapper{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background:rgba(0,0,0,.6);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1000}.modal-content-wrapper::-webkit-scrollbar{width:0}.modal-content{background:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:1rem;max-width:1080px;min-width:600px;padding:1.5rem;position:relative;width:50vw}.modal-content-wrapper{max-height:70vh;min-height:50vh;overflow-y:auto;width:100%}.modal-closer{cursor:pointer;font-size:1.2rem;position:absolute;right:.8rem;top:.8rem}.modal-closer:hover{color:var(--blue)}@media (max-width:900px){.modal-content{min-width:90%;width:90%}}.post-card-img{background-color:var(--background-color);border-radius:12px;bottom:0;box-shadow:0 0 6px rgba(0,0,0,.15);height:200px;left:50%;-o-object-fit:cover;object-fit:cover;position:absolute;-webkit-transform:translate(-50%) rotate(-8deg);transform:translate(-50%) rotate(-8deg);transition:.2s;width:300px}.img-line{height:120px;margin-bottom:2rem;position:relative}.post-card{align-items:center;border:1px solid var(--card-background-border-color);border-radius:1.5rem;cursor:pointer;display:flex;flex-direction:column;justify-content:center;margin:140px auto 0;max-width:45rem;padding:1.5rem 2rem;position:relative;transition:.2s}.post-card:hover{box-shadow:0 0 1rem var(--card-box-shadow)}.post-card:active{box-shadow:0 0 1.5rem var(--blue)}.post-card:hover .post-card-img{-webkit-transform:translate(-50%) rotate(0deg);transform:translate(-50%) rotate(0deg)}.post-card h2:after{background:var(--blue);content:"";display:block;height:2px;margin-left:auto;margin-right:auto;margin-top:10px;width:60px}.post-card-meta{background-color:var(--card-background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;font-size:.9rem;font-weight:300;margin:1rem 0 0;padding:5px 10px}@media (max-width:500px){.post-card{padding:1.5rem .8rem}}.article-navigator{background-color:var(--background-color);border-right:1px solid var(--card-background-border-color);font-size:16px;height:100%;left:0;overflow-y:auto;padding:2.5rem 1.2rem 2.5rem 2rem;position:fixed;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%;z-index:999}.article-navigator .article-navigator-toggler{cursor:pointer;font-size:1.3rem;height:2rem;line-height:2rem;position:absolute;right:0;top:1rem;visibility:hidden;width:2rem}.article-navigator .article-navigator-toggler:hover{color:var(--blue)}@media (max-width:900px){.article-navigator{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;display:none;height:100%;left:0;padding:0;width:100vw}.article-navigator h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.article-navigator p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;padding-left:2rem!important;padding-right:2rem!important;transition:background .3s}.article-navigator p:hover{background:var(--navigator-hover-color)}.navigator-switch{display:block}.article-navigator .article-navigator-toggler{visibility:visible}}.article-navigator h4{font-size:16px;margin-bottom:.5rem;margin-top:1rem}.article-navigator h4:first-child{margin-top:0}.navigator-switch{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;display:none;font-size:.8rem;height:30px;left:1rem;line-height:29px;position:fixed;text-align:center;top:1rem;width:30px;z-index:999}.article-navigator p{cursor:pointer;font-size:15px;margin:0;overflow-x:hidden;padding-left:.5rem;text-overflow:ellipsis;white-space:nowrap;width:100%}.article-navigator p:hover,.highlighted-navigator-item{color:var(--blue)}.item-list{align-items:center;border-left:3px solid var(--blue);display:flex;flex-direction:column;justify-content:center;margin:0 auto 0 1rem}.item-list .item{margin:0;padding:1rem;position:relative;width:100%}.item:before{background-color:var(--blue);border-radius:50%;content:"";height:.8rem;left:-.5rem;position:absolute;top:2rem;transition:.2s;width:.8rem}.item:hover:before{-webkit-transform:scale(1.2);transform:scale(1.2)}.item-list .item-label{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.item-list .item-content{padding-top:.5rem}.homepage-title{font-weight:700;margin:2rem 0 1rem}.item a{transition:.3s}.item a:hover{color:var(--font-color-highlight)}.messager{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;box-shadow:0 0 .8rem var(--card-box-shadow);left:0;margin-left:auto;margin-right:auto;max-width:200px;padding:.5rem 1rem;position:fixed;right:0;text-align:center;top:1rem;-webkit-transform:scale(.2);transform:scale(.2);transition:.2s;z-index:999}.avatar{align-items:center;display:flex;flex-direction:row;height:8rem;justify-content:center}.avatar>img{border-radius:50%;box-shadow:0 0 4px rgba(0,0,0,.1);max-height:100%;-o-object-fit:cover;object-fit:cover;-o-object-position:center center;object-position:center center;opacity:1;padding:.5rem;transition:none 0s ease 0s}.footer{border-top:1px solid var(--card-background-border-color);color:var(--font-color);display:flex;flex-direction:row;font-size:13px;justify-content:space-evenly;margin-top:10rem;padding:2rem 0 8rem;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}.footer .wrapper{align-items:flex-start;display:flex;flex-direction:column;font-family:sans-serif;padding-left:.5rem;padding-right:1rem;width:50%}h3,ul{width:100%}h3{color:var(--font-color);margin-bottom:8px}.footer p{line-height:1.2rem;margin:0;padding:.5rem 0}.footer span{color:var(--font-color);cursor:pointer;margin-right:12px}.wrapper li{padding:4px 0}.footer span:hover{color:var(--font-color-highlight)}@media (max-width:600px){.footer{flex-direction:column}.footer .wrapper{margin-bottom:1rem;width:100%}}:root{--deckgo-highlight-code-font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}@media (prefers-color-scheme:dark){body{--blue:#02bbff;--background-color:#202124;--background-color-transparent:rgba(0,0,0,.9);--font-color:#bdc1c6;--font-color-header:#eaeaea;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#c678dd;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:rgba(0,0,0,.1);--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030}}@media (prefers-color-scheme:light){body{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#3c4043;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#313131;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed}}.dark{--blue:#02bbff;--background-color:#202124;--background-color-transparent:rgba(0,0,0,.9);--font-color:#bdc1c6;--font-color-header:#eaeaea;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#c678dd;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:rgba(0,0,0,.1);--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030}.light{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#3c4043;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#313131;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed}body,html{background-color:var(--background-color);color:var(--font-color);font-family:Arial,Helvetica,sans-serif}a{color:inherit;text-decoration:none}*{-webkit-tap-highlight-color:rgba(0,0,0,0);border:none;box-sizing:border-box;list-style-type:none;margin:0;padding:0}ol{margin:.7rem 0}ol li{list-style-type:decimal;margin:.6rem 0 .6rem 2rem}p{-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;display:block;line-height:1.7;margin-block-end:1em;margin-block-start:1em;margin-bottom:.7rem;margin-inline-end:0;margin-inline-start:0;margin-top:.7rem}::selection{background-color:var(--blue);color:#fff}body{word-wrap:break-word;font-kerning:normal;margin:0;padding:0}header{align-items:center;display:flex;flex-direction:row;justify-content:space-around;padding-bottom:0}header>.route-link{margin:0 1rem}header img{box-shadow:0 0 .2rem rgba(0,0,0,.5)}.base-wrapper{margin-left:auto;margin-right:auto;max-width:1080px;min-height:100%;padding:2.625rem 1.3125rem;width:60%}.nav-link{align-items:center;color:var(--font-color);cursor:pointer;display:flex;flex-direction:column;font-size:2.2rem;justify-content:center;margin:0 1rem;min-width:3rem}.nav-link>img{border-radius:50%;height:2.2rem;-webkit-transform:scale(1.2);transform:scale(1.2)}.nav-link:hover{color:var(--blue);text-decoration:none}.nav-link:hover .link-label{-webkit-transform:scaleY(1);transform:scaleY(1)}.nav-link .link-label{bottom:-24px;display:block;font-size:.9rem;padding-top:6px;text-align:center;-webkit-transform:scaleY(0);transform:scaleY(0);transition:.2s;width:8rem}.link-active{color:var(--blue)}.article-body .article-title{font-size:2.2rem;font-weight:700;margin-bottom:2rem;text-align:center}.article-body strong{color:var(--font-color-highlight)}.article-meta{font-size:.9rem;margin:1rem auto 1.5rem;text-align:center}.article-meta>span{background-color:var(--card-background-color);border-radius:.5rem;font-weight:lighter;padding:.5rem 1rem}.article-body h1,h2,h3{cursor:pointer}.article-body p{font-size:17px;margin-bottom:1.2rem;margin-top:1.2rem}.article-body h1{color:var(--font-color-header);font-size:2rem;font-weight:700;margin-bottom:1.8rem;margin-top:3.5rem}.article-body h1 code{font-size:2rem}.article-body h2{color:var(--font-color-header);font-size:1.6rem;font-weight:700;margin-bottom:1rem;margin-top:2.5rem}.article-body h2 code{font-size:1.5rem}.article-body h3{color:var(--font-color-header);font-size:1.4rem;font-weight:700;line-height:1.8;margin-bottom:1rem;margin-top:1.8rem}.article-body h3 code{font-size:1.2rem;font-weight:700}.article-body h4{color:var(--font-color-header);font-weight:500;margin-bottom:1rem;margin-top:1.5rem}.article-body h4 code{font-size:1rem}.article-body h1:first-child{border-radius:.5rem}.article-body h1:not(:first-child):before{margin-bottom:.5rem}.article-body h1:not(:first-child):before,.article-body h2:before{background:var(--blue);content:"";display:block;height:2px;width:70px}.article-body h2:before{margin-bottom:.3rem}.article-body code{background-color:var(--code-background-color);border:1px solid var(--code-border-color);border-radius:4px;color:var(--code-font-color);font-family:Menlo,Monaco,Consolas,monospace;font-size:15px;margin:0 2px;padding:1px 4px}.article-body blockquote{background-color:var(--quote-background-color);border-left:2px solid var(--blue);border-radius:0 .5rem .5rem 0;color:var(--font-color-quote);margin-top:1rem;padding:1rem}.article-body blockquote code{color:var(--code-font-color)}.article-body .article-cover{border-radius:16px;box-shadow:0 0 1px rgba(0,0,0,.1);margin:18px auto 20px;width:80%}.article-body .article-cover,.article-body img{display:block;min-width:330px;-o-object-fit:cover;object-fit:cover}.article-body img{border-radius:12px;margin:18px auto;width:85%}.article-body ul{margin:.7rem 0}.article-body ul li{list-style-type:disc;margin:.6rem 0 .6rem 2rem}.article-body a{color:#189fff}a:hover{text-decoration:underline}.article-body a:after{content:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMSIgaGVpZ2h0PSIxMSIgY2xhc3M9InByZWZpeF9faWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCI+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTkyNC40MDIgMTAyMy4wNjhILjY4Vjk5LjM0NUg0NjIuNTR2OTguOTFIOTkuNTk3VjkyNC4xNWg3MjUuODk2VjU2MS4yMDdoOTguOTF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0ibTkzMC44MDUgMjIuOTc3IDY5Ljk2NiA2OS45NjYtNDUzLjQ5MyA0NTMuNDkyLTY5Ljk2NS02OS45MDF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTEwMjIuNDY0IDMwNC4wM2gtOTguOTE3Vjk5LjM0NUg3MDkuMjMxVi40MjhoMzEzLjIzM3oiLz48L3N2Zz4=);padding-left:2px}.article-body table{word-wrap:normal;border-collapse:collapse;table-layout:fixed;width:100%}th{background-color:rgba(0,0,0,.06);text-align:center}td{background-color:hsla(0,0%,100%,.01);font-weight:300}table,td,th{border:1px solid var(--table-border-color);overflow:auto;padding:.5rem}.theme-changer{border-radius:50%;bottom:1rem;cursor:pointer;position:fixed;right:1rem}.theme-changer img{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;height:30px;padding:6px;width:30px}deckgo-highlight-code{background-color:var(--code-block-background);border-radius:.5rem;box-shadow:none!important;cursor:pointer;font-size:14px;margin-top:1rem;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}@media (min-width:900px){deckgo-highlight-code:after{content:"双击复制";font-size:11px;height:2rem;opacity:0;position:absolute;right:1rem;text-align:center;top:1rem;transition:.4s;width:4rem}deckgo-highlight-code:hover:after{opacity:1}}@media (max-width:900px){.base-wrapper{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 1rem;width:100%}}.progresser{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;font-family:Courier New,Courier,monospace;font-size:13px;font-weight:lighter;height:30px;line-height:29px;position:fixed;right:1rem;text-align:center;top:1rem;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:30px;z-index:999}.progresser:after{background-color:var(--quote-background-color);border-radius:50%;content:"";opacity:0;transition:.2s}.progresser:after,.progresser:hover:after{bottom:0;left:0;position:absolute;right:0;top:0}.progresser:hover:after{content:"up";opacity:1}.table-of-content{background-color:var(--background-color);border-left:1px solid var(--card-background-border-color);font-size:16px;height:100%;overflow-y:auto;padding:2.5rem 2rem 2.5rem 1.2rem;position:fixed;right:0;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}@media (max-width:900px){.table-of-content{display:none}}.table-of-content::-webkit-scrollbar{display:none}.table-of-content p{cursor:pointer;margin:0;overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.table-of-content .topHeader{color:var(--blue)!important}.table-of-content p:hover{color:var(--blue)}p.header-level-h1{font-weight:700;margin-top:.8rem}p.header-level-h2{font-size:15px;margin-top:.4rem;padding-left:1rem}p.header-level-h3{font-size:15px;margin-top:.2rem;padding-left:2rem}</style><meta name="generator" content="Gatsby 4.4.0"/><link rel="icon" href="/favicon-32x32.png?v=955b34d699199a783b1a23f58b90c7ba" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=955b34d699199a783b1a23f58b90c7ba"/><link as="script" rel="preload" href="/webpack-runtime-616a2703339e1825be33.js"/><link as="script" rel="preload" href="/framework-f27b074ecebec0f1dbc4.js"/><link as="script" rel="preload" href="/app-2669451f6c27cf91d5d9.js"/><link as="script" rel="preload" href="/cb1608f2-001f1ae553ac1c271243.js"/><link as="script" rel="preload" href="/a9a7754c-992c6b2080a7db331a45.js"/><link as="script" rel="preload" href="/commons-621e910004da52b2e8e5.js"/><link as="script" rel="preload" href="/component---src-pages-articles-mdx-slug-js-cb30643db792e4279ec0.js"/><link as="fetch" rel="preload" href="/page-data/articles/redbook-series/redbook-chapter24/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2757060725.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3605573801.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="base-wrapper"><title>Louis K - Software Engineer</title><header><a class="nav-link" href="/nonTech/"><span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span><span class="link-label">杂谈文章</span></a><a class="nav-link" href="/"><span role="img" aria-label="desktop" class="anticon anticon-desktop"><svg viewBox="64 64 896 896" focusable="false" data-icon="desktop" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 140H96c-17.7 0-32 14.3-32 32v496c0 17.7 14.3 32 32 32h380v112H304c-8.8 0-16 7.2-16 16v48c0 4.4 3.6 8 8 8h432c4.4 0 8-3.6 8-8v-48c0-8.8-7.2-16-16-16H548V700h380c17.7 0 32-14.3 32-32V172c0-17.7-14.3-32-32-32zm-40 488H136V212h752v416z"></path></svg></span><span class="link-label">技术文章</span></a><div class="nav-link"><img alt="avatar" src="/static/avatar-427bcc9e4a03334af5649168991c08f0.png"/><span class="link-label">关于作者</span></div></header><main><div class="progresser">0</div><div class="article-body"><h1 class="article-title">（二十四）网络请求与远程资源</h1><p class="article-meta"><span><span role="img" aria-label="field-time" class="anticon anticon-field-time"><svg viewBox="64 64 896 896" focusable="false" data-icon="field-time" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M945 412H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h256c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM811 548H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h122c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM477.3 322.5H434c-6.2 0-11.2 5-11.2 11.2v248c0 3.6 1.7 6.9 4.6 9l148.9 108.6c5 3.6 12 2.6 15.6-2.4l25.7-35.1v-.1c3.6-5 2.5-12-2.5-15.6l-126.7-91.6V333.7c.1-6.2-5-11.2-11.1-11.2z"></path><path d="M804.8 673.9H747c-5.6 0-10.9 2.9-13.9 7.7a321 321 0 01-44.5 55.7 317.17 317.17 0 01-101.3 68.3c-39.3 16.6-81 25-124 25-43.1 0-84.8-8.4-124-25-37.9-16-72-39-101.3-68.3s-52.3-63.4-68.3-101.3c-16.6-39.2-25-80.9-25-124 0-43.1 8.4-84.7 25-124 16-37.9 39-72 68.3-101.3 29.3-29.3 63.4-52.3 101.3-68.3 39.2-16.6 81-25 124-25 43.1 0 84.8 8.4 124 25 37.9 16 72 39 101.3 68.3a321 321 0 0144.5 55.7c3 4.8 8.3 7.7 13.9 7.7h57.8c6.9 0 11.3-7.2 8.2-13.3-65.2-129.7-197.4-214-345-215.7-216.1-2.7-395.6 174.2-396 390.1C71.6 727.5 246.9 903 463.2 903c149.5 0 283.9-84.6 349.8-215.8a9.18 9.18 0 00-8.2-13.3z"></path></svg></span> <!-- -->2022-04-05<!-- --> | <span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span> <!-- -->12900<!-- -->words <!-- -->46<!-- -->min</span></p><img class="article-cover" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0z7nmxobmj20sg0hnmxd.jpg" alt="https://tva1.sinaimg.cn/large/e6c9d24egy1h0z7nmxobmj20sg0hnmxd.jpg"/><p>2005 年，Jesse James Garrett 撰写了一篇文章，“Ajax——A New Approach to Web Applications”。这篇文章中描绘了一个被他称作 Ajax（Asynchronous JavaScript + XML，即异步 JavaScript 加 XML）的技术。这个技术涉及发送服务器请求额外数据而不刷新页面，从而实现更好的用户体验。Garrett 解释了这个技术怎样改变自 Web 诞生以来一直延续的传统单击等待模式。</p><p>将 Ajax 推到历史舞台上的关键技术是<code>XMLHttpRequest</code>（XHR）对象。这个对象最早由微软发明，然后被其他浏览器所借鉴。在 XHR 出现以前，Ajax 风格的通信不许通过一些黑科技实现，主要是使用隐藏的窗格或者内嵌窗格。XHR 为发送服务器请求和获取响应提供了合理的接口。这个接口可以实现异步从服务器获取额外数据，意味着用户点击不用页面刷新也可以获取数据。通过 XHR 对象获取数据后，可以使用 DOM 方法将数据插入网页。虽然 Ajax 这个名字中包含 XML，但实际上 Ajax 通信与数据格式无关。这个技术主要是可以实现在不刷新页面的情况下从服务器获取数据，格式并不一定是 XML。</p><p>实际上，Garrett 所称的这种 Ajax 技术已经出现很长时间了。在 Garrett 的那篇文章之前，一般称这种技术为<strong>远程脚本</strong>。这种浏览器与服务器的通信早在 1998 年就通过不同方式实现了。最初 JavaScript 对服务器的请求可以通过中介（例如 Java 小程序或 Flash 影片）来发送。后来 XHR 对象又为开发者提供了原生的浏览器通信能力，减少了实现这个目的的工作量。</p><p>XHR 对象的 API 被普遍认为比较难用，而 Fetch API 自从诞生以后就迅速成为了 XHR 更现代的替代标准。Fetch API 支持期约和服务线程，已经成为极其强大的 Web 开发工具。</p><blockquote><p>本章会全面介绍<code>XMLHttpRequest</code>，但它实际上是过时的 Web 规范的产物，应该只在旧版本浏览器中使用。实际开发中应该尽可能使用<code>fetch()</code>。</p></blockquote><h1><code>XMLHttpRequest</code>对象</h1><p>IE5 是第一个引入 XHR 对象的浏览器。这个对象是通过 ActiveX 对象实现并包含在 MSXML 库中的。为此，XHR 对象的 3 个版本在浏览器中分别被暴露为<code>MSXML2.XMLHttp</code>、<code>MSXML2.XMLHttp.3.0</code>和<code>MSXL2.XHMLHttp.6.0</code>。</p><p>所有现代浏览器都通过<code>XHMLHttpRequest</code>构造函数原生支持 XHR 对象：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let xhr = new XMLHttpRequest()</code>
        </deckgo-highlight-code><h2>使用 XHR</h2><p>使用 XHR 对象首先要调用<code>open()</code>方法，这个方法接收 3 个参数：请求类型（<code>&quot;get&quot;</code>、<code>&quot;post&quot;</code>等）、请求 URL，以及表示请求是否异步的布尔值。下面是一个例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">xhr.open(&#x27;get&#x27;, &#x27;example.php&#x27;, false)</code>
        </deckgo-highlight-code><p>这行代码就可以向 example.php 发送一个同步的 GET 请求。关于这行代码需要说明几点。首先这里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用<code>open()</code>不会实际发送请求，只是为发送请求做好准备。</p><blockquote><p>只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与发送请求的页面在任何方面有所不同，则会抛出安全错误。</p></blockquote><p>要发送定义好的请求，必须像下面这样调用<code>send()</code>方法：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">xhr.open(&#x27;get&#x27;, &#x27;example.txt&#x27;, false)
xhr.send(null)</code>
        </deckgo-highlight-code><p><code>send()</code>方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传<code>null</code>，因为这个参数在某些浏览器中是必须的。调用<code>send()</code>之后，请求就会发送到服务器。</p><p>因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR 对象的以下属性会被填充上数据。</p><ul><li><code>responseText</code>：作为响应体返回的文本。</li><li><code>responseXML</code>：如果响应的内容类型是<code>&quot;text/xml&quot;</code>或<code>&quot;application/xml&quot;</code>，那就是包含响应数据的 XML DOM 文档。</li><li><code>status</code>：响应的 HTTP 状态。</li><li><code>statusText</code>：响应的 HTTP 状态描述。</li></ul><p>收到响应后，第一步要检查<code>status</code>属性以确保响应成功返回。一般来说，HTTP 状态码 2xx 表示成功。此时，<code>responseText</code>或<code>responseXML</code>（如果内容类型正确）属性中会有内容。如果 HTTP 状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">xhr.open(&#x27;get&#x27;, &#x27;example.txt&#x27;, false)
xhr.send(null)

if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
  alert(xhr.responseText)
} else {
  alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
}</code>
        </deckgo-highlight-code><p>以上代码可能显示服务器返回的内容，也可能是显示错误消息，取决于 HTTP 响应的状态码。未确定下一步该执行什么操作，最好检查<code>status</code>而不是<code>statusText</code>属性，因为后者已经被证明在跨浏览器的情况下不可靠。无论是什么响应内容类型，<code>responseText</code>属性始终会保存响应体，而<code>responseXML</code>则对于非 XML 数据是<code>null</code>。</p><p>虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用异步请求，这样可以不阻塞 JavaScript 代码继续执行。XHR 对象有一个<code>readyState</code>属性，表示当前处在请求/响应过程的哪个阶段。这个属性可能有以下的值：</p><ul><li>0：未初始化。尚未调用<code>open()</code>方法。</li><li>1：已打开。已经调用了<code>open()</code>方法，尚未调用<code>send()</code>方法。</li><li>2：已发送。已调用<code>send()</code>方法，尚未收到响应。</li><li>3：接受中。已经收到部分响应。</li><li>4：完成。已经收到所有响应，可以使用了。</li></ul><p>每次<code>readyState</code>从一个值变成另一个值，都会触发<code>readyStateChange</code>事件。可以借此机会检查<code>readyState</code>的值。一般来说，我们唯一关心的<code>readyState</code>的值是 4，表示数据已经就绪。为保证跨浏览器兼容，<code>onreadystatechange</code>事件处理程序应该在调用<code>open()</code>之前赋值。来看下面的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
      alert(xhr.responseText)
    } else {
      alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
    }
  }
}

xhr.open(&#x27;get&#x27;, &#x27;example.txt&#x27;, true)
xhr.send(null)</code>
        </deckgo-highlight-code><p>以上代码使用 DOM Level 0 风格为 XHR 对象添加了事件处理程序，因为并不是所有浏览器都支持 DOM Level 2 风格。与其他事件处理程序不同，<code>onreadystatechange</code>事件处理程序不会收到<code>event</code>对象。在事件处理程序中，必须使用 XHR 对象本身来确定接下来该做什么。</p><blockquote><p>由于<code>onreadystatechange</code>事件处理程序作用域问题，这个例子在<code>onreadystatechange</code>事件处理程序中使用了<code>xhr</code>对象而不是<code>this</code>对象。使用<code>this</code>可能导致功能失败或错误，取决于用户使用的是什么浏览器。因此还是使用保存 XHR 对象的变量更保险一些。</p></blockquote><p>在收到响应之前如果想要取消异步请求，可以调用<code>abort()</code>方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">xhr.abort()</code>
        </deckgo-highlight-code><p>调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。</p><h2>HTTP 头部</h2><p>每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。默认情况下，XHR 请求会发送以下头部字段：</p><ul><li><code>Accept</code>：浏览器可以处理的内容类型。</li><li><code>Accept-Charset</code>：浏览器可以显示的字符集。</li><li><code>Accept-Encoding</code>：浏览器可以处理的压缩编码类型。</li><li><code>Accept-Language</code>：浏览器使用的语言。</li><li><code>Connection</code>：浏览器与服务器的连接类型。</li><li><code>Cookie</code>：页面中设置的 Cookie。</li><li><code>Host</code>：发送请求的页面所在的域。</li><li><code>Referer</code>：发送请求的页面 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容性问题也必须将错就错。（正确的拼写应该是 Referrer。）</li><li><code>User-Agent</code>：浏览器的用户代理字符串。</li></ul><p>虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。如果需要发送额外的请求头部，可以使用<code>setRequestHeader</code>方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在<code>open()</code>之后、<code>send()</code>之前调用<code>setRequestHeader()</code>，如下面例子所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
    alert(xhr.responseText)
  } else {
    alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
  }
}

xhr.open(&#x27;get&#x27;, &#x27;exmaple.php&#x27;, true)
xhr.setRequestHeader(&#x27;MyHeader&#x27;, &#x27;MyValue&#x27;)
xhr.send(null)</code>
        </deckgo-highlight-code><p>服务器通过读取自定义头部可以确定适当的操作。自定义头部一定要区别于浏览器正常发送的头部，否则就可能影响服务器正常响应。有些浏览器允许重写默认头部，有些浏览器则不允许。</p><p>可以使用<code>getResponseHeader()</code>方法从 XHR 对象获取响应头部，只要传入要求获取头部的名称即可。如果想取得所有响应头部，可以使用<code>getAllResponseHeaders()</code>方法，这个方法会返回包含所有响应头部的字符串。下面是调用这两个方法的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const myHeader = xhr.getResponseHeader(&#x27;MyHeader&#x27;)
const allHeaders = xhr.getAllResponseHeaders()</code>
        </deckgo-highlight-code><p>服务器可以使用头部向浏览器传递额外的结构化数据。<code>getAllResponseHeaders()</code>方法通常返回类似如下的字符串：</p><deckgo-highlight-code language="text" theme="one-dark">
          <code slot="code">Date: Sun, 14 Nov 2022 18:04:03 GMT
Server: Apache/1.3.29 (Unix)
Vary: Accept
X-Powered-By: PHP/4.3.8
Connection: close
Content-Type: text/html; charset=iso-8859-1</code>
        </deckgo-highlight-code><p>通过解析以上头部字段的输出，就可以知道服务器发送的所有头部，而不需要单独去检查了。</p><h2>GET 请求</h2><p>最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时需要在 GET 请求的 URL 后面添加查询字符串参数。对于 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给<code>open()</code>方法。</p><p>发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用<code>encodeURIComponent()</code>编码，所有名/值对必须以<strong>和号</strong>（&amp;）分隔，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">xhr.open(&#x27;get&#x27;, &#x27;example.php?name1=value1&amp;name2=value2&#x27;, true)</code>
        </deckgo-highlight-code><p>可以使用以下函数将查询字符串参数添加到现有的 URL 末尾：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function addURLParam(url, name, value) {
  url += url.indexOf(&#x27;?&#x27;) === -1 ? &#x27;?&#x27; : &#x27;&amp;&#x27;
  url += encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(value)
  return url
}</code>
        </deckgo-highlight-code><p>可以用这个函数构建请求 URL，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const url = &#x27;example.php&#x27;

url = addURLParam(url, &#x27;name&#x27;, &#x27;Nicholas&#x27;)
url = addUrlParam(url, &#x27;book&#x27;, &#x27;Professional JavaScript&#x27;)

xhr.open(&#x27;get&#x27;, url, false)</code>
        </deckgo-highlight-code><p>这里使用<code>addURLParam()</code>函数可以保证通过 XHR 发送请求的 URL 格式正确。</p><h2>POST 请求</h2><p>第二个最常见的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。要初始化 POST 请求，<code>open()</code>方法的第一个参数要传<code>&quot;post&quot;</code>，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">xhr.open(&#x27;post&#x27;, &#x27;example.php&#x27;, true)</code>
        </deckgo-highlight-code><p>接下来就是要给<code>send()</code>方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可以传入序列化之后的 XML DOM 文档作为请求体，当然也可以传入任意字符串。</p><p>默认情况下，对于服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST 数据才能取得浏览器发送的数据。不过可以使用 XHR 模拟表单提交。为此第一步需要把<code>Content-Type</code>头部设置为<code>&quot;application/x-www-formurlencoded&quot;</code>，这是提交表单时使用的内容类型。第二步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表单需要序列化并通过 XHR 发送到服务器，可以使用特定的序列化函数来创建相应的字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function submitData() {
  const xhr = new XMLHttpRequest()
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
        alert(xhr.responseText)
      } else {
        alert(&#x27;Request was un successful: &#x27; + xhr.status)
      }
    }
  }

  xhr.open(&#x27;post&#x27;, &#x27;postexample.php&#x27;, true)
  xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)
  const form = document.getElementById(&#x27;user-info&#x27;)
  xhr.send(serialize(form))
}</code>
        </deckgo-highlight-code><p>在这个函数中，来自 ID 为<code>&quot;user-info&quot;</code>的表单数中的数据被序列化之后发送给了服务器。</p><blockquote><p>POST 请求相比 GET 请求要占用更多资源。从性能方面来说，发送相同数量的数据，GET 请求要比 POST 请求快两倍。</p></blockquote><h2>XMLHttpRequest Level 2</h2><p>XHR 对象作为事实标准的迅速流行，也促使 W3C 为规范这一行为而制定了正式标准。XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。并非所有的浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能。</p><h3><code>FormData</code>类型</h3><p>现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了<code>FormData</code>类型。<code>FormData</code>类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送。下面的代码创建了一个<code>FormData</code>对象，并填充了一些数据：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const data = new FormData()
data.append(&#x27;name&#x27;, &#x27;Nicholas&#x27;)</code>
        </deckgo-highlight-code><p><code>append()</code>方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键/值对数据。此外，通过直接给<code>FormData</code>构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const data = new FormData(document.forms[0])</code>
        </deckgo-highlight-code><p>有了<code>FormData</code>实例，可以像下面这样直接传给 XHR 对象的<code>send()</code>方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr =  new XMLHttpRequest()
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
      alert(xhr.responseText)
    } else {
      alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
    }
  }
}

xhr.open(&#x27;post&#x27;, &#x27;postexample.php&#x27;, true)
const form = document.getElementById(&#x27;user-info&#x27;)
xhr.send(nwe FormData(form))</code>
        </deckgo-highlight-code><p>使用<code>FormData</code>的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为<code>FormData</code>实例传入的数据类型并自动配置相应的头部。</p><h3>超时</h3><p>IE8 给 XHR 对象增加了一个<code>timeout</code>属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有的浏览器都在自己的 XHR 实现中增加了这个属性。在给<code>timeout</code>属性设置了一个事件且在该时间之后没有收到响应时，XHR 对象就会触发<code>timeout</code>事件，调用<code>ontimeout</code>事件处理程序。这个特性后来也被添加到了 XMLHttpRequest Level 2 规范。看下面的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    try {
      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
        alert(xhr.responseText)
      } else {
        alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
      }
    } catch (ex) {
      // 假设由ontimeout处理
    }
  }
}

xhr.open(&#x27;get&#x27;, &#x27;timeout.php&#x27;, true)
xhr.ontimeout = function () {
  alert(&#x27;Request did not return in a second&#x27;)
}
xhr.send(null)</code>
        </deckgo-highlight-code><p>这个例子演示了使用<code>timeout</code>设置超时。给<code>timeout</code>设置 1000 毫秒意味着，如果请求没有在 1 秒钟内返回则会中断。此时触发<code>ontimeout</code>事件处理程序，<code>readyState</code>仍然会变成 4，因此也会调用<code>onreadystatechange</code>事件处理程序。不过如果在超时之后访问<code>status</code>属性则会发生错误。因此为了做好防护，可以把检查<code>status</code>属性的代码封装在<code>try/catch</code>语句中。</p><h3><code>overrideMimeType()</code>方法</h3><p>Firefox 首选引入了<code>overrideMimeType()</code>方法用于重写 XHR 响应的 MIME 类型。这个特性后来也被添加到 XMLHttpRequest Level 2.因为响应返回的 MIME 类型决定了 XHR 对象如何处理响应，所以如果有办法覆盖服务器返回的类型，那么是有帮助的。</p><p>假设服务器实际发送了 XML 数据，但响应头部设置的 MIME 类型是<code>text/plain</code>。结果就会导致虽然数据是 XML，但<code>responseXML</code>属性值是<code>null</code>。此时调用<code>overrideMimeType()</code>可以保证将响应当成 XML 而不是纯文本来处理。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.open(&#x27;get&#x27;, &#x27;text.php&#x27;, true)
xhr.overrideMimeType(&#x27;text/xml&#x27;)
xhr.send(null)</code>
        </deckgo-highlight-code><p>这个例子强制让 XHR 把响应当成 XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型，必须在调用<code>send()</code>之前调用<code>overrideMimeType()</code>。</p><h1>进度事件</h1><p>Progress Events 是 W3C 的工作草案，定义了客户端—服务器端通信。这些事件最初只针对 XHR，现在也推广到了其他类似的 API。有以下 6 个进度相关的事件。</p><p><code>loadstart</code>：在接收到响应的第一个字节时触发。</p><p><code>progress</code>：在接收响应期间反复触发。</p><p><code>error</code>：在请求出错时触发。</p><p><code>abort</code>：在调用<code>abort()</code>终止连接时触发。</p><p><code>load</code>：在成功接收完响应时触发。</p><p><code>loadend</code>：在通信完成时，且在<code>error</code>、<code>abort</code>或<code>load</code>之后触发。</p><p>每次请求都会首先触发<code>loadstart</code>事件，之后是一个或者多个<code>progress</code>事件，接着是<code>error</code>、<code>abort</code>或<code>load</code>中的一个，最后以<code>loadend</code>事件结束。这些事件大部分都很好理解，但其中有两个需要说明一下。</p><h2><code>load</code>事件</h2><p>Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个<code>load</code>事件用于替代<code>readystatechange</code>事件。<code>load</code>事件在响应接收完成之后立即触发，这样就不用检查<code>readyState</code>属性了。<code>onload</code>事件处理程序会收到一个<code>event</code>对象，其<code>target</code>属性设置为 XHR 实例，在这个实例上可以访问所有的 XHR 对象属性和方法。不过并不是所有浏览器都实现了这个事件的<code>event</code>对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onload = function () {
  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
    alert(xhr.responseText)
  } else {
    alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
  }
}

xhr.open(&#x27;get&#x27;, &#x27;altevent.php&#x27;, true)
xhr.send(null)</code>
        </deckgo-highlight-code><p>只要是从服务器接收到响应，无论状态码是什么，都会触发<code>load</code>事件。这意味着还需要检查<code>status</code>属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持<code>load</code>事件。</p><h2><code>progress</code>事件</h2><p>Mozilla 在 XHR 对象上另一个创新是<code>progress</code>事件，在浏览器接收数据期间，这个事件反复触发。每次触发时，<code>onprogress</code>事件处理程序都会收到<code>event</code>对象，其<code>target</code>属性是 XHR 对象，且包含 3 个额外属性：<code>lengthComputable</code>、<code>position</code>和<code>totalSize</code>。其中<code>lengthComputable</code>是一个布尔值，表示进度信息是否可用：<code>position</code>是接收到的字节数；<code>totalSize</code>是响应的<code>Content-Length</code>头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onload = function () {
  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
    alert(xhr.responseText)
  } else {
    alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
  }
}

xhr.onprogress = function (event) {
  const divStatus = document.getElementById(&#x27;status&#x27;)
  if (event.lengthComputable) {
    divStatus.innerHTML = `Received ${event.position} of ${event.totalSize} bytes.`
  }
}

xhr.open(&#x27;get&#x27;, &#x27;altevents.php&#x27;, true)
xhr.send(null)</code>
        </deckgo-highlight-code><p>为了保证正确执行，必须在调用<code>open()</code>之前添加<code>onprogress</code>事件处理程序。在前面的例子中，每次触发<code>progress</code>事件都会更新 HTML 元素中的信息。假设响应有<code>Content-Length</code>头部，就可以利用这些信息计算出已经收到响应的百分比。</p><h1>跨源资源共享</h1><p>通过 XHR 进行 Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过浏览器也需要支持合法跨源访问的能力。</p><p>跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器互相了解，以确认请求或响应应该成功还是失败。</p><p>对于简单的请求，例如 GET 或 POST 请求，没有自定义头部，而且请求体是<code>text/plain</code>类型，这样的请求在发送时会有一个额外的头部叫<code>Origin</code>。<code>Origin</code>头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是<code>Origin</code>头部的一个实例：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">Origin: http://www.nczonline.net</code>
        </deckgo-highlight-code><p>如果服务器决定响应请求，那么应该发送<code>Access-Control-Allow-Origin</code>头部，包含相同的源；或者如果资源是公开的，那么就包含<code>&quot;*&quot;</code>。例如：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">Access-Control-Allow-Origin: http://www.nczonline.net</code>
        </deckgo-highlight-code><p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。</p><p>现代浏览器通过<code>XMLHttpRequest</code>对象原生支持 CORS。在尝试访问不同资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR 对象并给<code>open()</code>方法传入一个绝对 URL，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const xhr = new XMLHttpRequest()
xhr.onload = function () {
  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) {
    alert(xhr.responseText)
  } else {
    alert(&#x27;Request was unsuccessful: &#x27; + xhr.status)
  }
}

xhr.open(&#x27;get&#x27;, &#x27;http://www.somewhere-else.com/page&#x27;, true)
xhr.send(null)</code>
        </deckgo-highlight-code><p>跨域 XHR 对象允许访问<code>status</code>和<code>statusText</code>属性，也允许同步请求。处于安全考虑，跨域 XHR 对象也施加了一些额外限制。</p><ul><li>不能使用<code>setRequestHeader()</code>设置自定义头部。</li><li>不能发送和接收 cookie。</li><li><code>getAllResponseHeaders()</code>方法始终返回空字符串。</li></ul><p>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以明确区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。</p><h2>预检请求</h2><p>CORS 通过一种叫<strong>预检请求</strong>（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET 和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部：</p><ul><li><code>Origin</code>：与简单请求相同。</li><li><code>Access-Control-Request-Medhod</code>：请求希望使用的方法。</li><li><code>Access-Control-Request-Headers</code>：（可选）要使用的逗号分隔的自定义头部列表。</li></ul><p>下面是一个假设的 POST 请求，包含自定义的<code>NCZ</code>头部：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ</code>
        </deckgo-highlight-code><p>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息：</p><ul><li><code>Access-Control-Allow-Origin</code>：与简单请求相同。</li><li><code>Access-Control-Allow-Methods</code>：允许的方法（逗号分隔的列表）。</li><li><code>Access-Control-Allow-Headers</code>：服务器允许的头部（逗号分隔的列表）。</li><li><code>Access-Control-Max-Age</code>：缓存预检请求的秒数。</li></ul><p>例如：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">Access-Control-Allow-Origin: http://www.nczonline.net
Access-Control-Allow-Methods: POST, GET
Access-Control-Allow-Headers: NCZ
Access-Control-Max-Age: 1728000</code>
        </deckgo-highlight-code><p>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</p><h2>凭据请求</h2><p>默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）。可以通过将<code>withCredentials</code>属性设置为<code>true</code>来表明会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">Access-Control-Allow-Credentials: true</code>
        </deckgo-highlight-code><p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（<code>responseText</code>是空字符串，<code>status</code>是 0，<code>onerror()</code>被调用）。注意服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。</p><h1>替代性跨源技术</h1><p>CORS 出现之前，实现跨源 Ajax 通信是有点麻烦的。开发这需要依赖能够执行跨源请求的 DOM 特性，在不使用 XHR 对象的情况下发送某种类型的请求。虽然 CORS 目前已经得到了广泛支持，但这些技术仍然没有过时，因为它们不需要修改服务器。</p><h2>图片探测</h2><p>图片探测是利用<code>&lt;img&gt;</code>标签实现跨域通信的最早的一种技术。<strong>任何页面都可以跨域加载图片而不必担心限制</strong>，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的<code>onload</code>和<code>onerror</code>事件处理程序得知何时收到响应。</p><p>这种动态创建图片的技术经常用于<strong>图片探测</strong>（image pings）。图片探测是与服务器之间简单、跨域、单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或者值为 204 的状态码。浏览器通过图片探测拿不到任何数据，但是可以通过监听<code>onload</code>和<code>onerror</code>事件知道什么时候能收到响应。下面看一个例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const img = new Image()
img.onload = img.onerror = function () {
  alert(&#x27;Done!&#x27;)
}
img.src = &#x27;http://www.example.com/test?name=Nicholas&#x27;</code>
        </deckgo-highlight-code><p>这个例子创建了一个新的<code>Image</code>实例，然后为它的<code>onload</code>和<code>onerror</code>事件处理程序添加了同一个函数。这样可以确保请求完成时无论什么响应都会收到通知。设置完<code>src</code>属性之后请求就开始了，这个例子向服务器发送了一个<code>name</code>值。</p><p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然图片探测的缺点是只能发送 GET 请求并无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。</p><h2>JSONP</h2><p>JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">callback({ name: &#x27;Nicholas&#x27; })</code>
        </deckgo-highlight-code><p>JSONP 格式包括两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。下面是一个典型的 JSONP 请求：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">http://freegeoip.net/json/?callback=handleResponse</code>
        </deckgo-highlight-code><p>这个 JSONP 请求的 URL 是一个地理位置服务。JSONP 服务通常以查询字符串形式指定回调函数的名称。例如这个例子就把回调函数的名字指定为<code>handleResponse()</code>。</p><p>JSONP 调用是通过动态创建<code>&lt;script&gt;</code>元素并为<code>src</code>属性指定跨域 URL 实现的。此时的<code>&lt;script&gt;</code>与<code>&lt;img&gt;</code>元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP 响应在被加载完成之后会立即执行。例如下面这个例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function handleResponse(response) {
  console.log(`
    You&#x27;re at IP address ${response.ip}, which is in 
    ${response.city}, ${response.region_name}
  `)
}

const script = document.createElement(&#x27;script&#x27;)
script.src = &#x27;http://freegeoip.net/json/?callback=handleResponse&#x27;
document.body.insertBefore(script, document.body.firstChild)</code>
        </deckgo-highlight-code><p>这个例子会显示从地理位置服务获取的 IP 地址以及位置信息。</p><p>JSONP 由于其简单易用，在开发者中非常流行。相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点。</p><p>首先，JSONP 是从不同的域拉取可执行代码。如果这个域不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时一定要保证是可以信任的。</p><p>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了<code>&lt;script&gt;</code>元素的<code>onerror</code>事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。</p><h1>Fetch API</h1><p>Fetch API 能够执行<code>XMLHttpRequest</code>对象的所有任务，但更容易使用，接口也更现代化，能够在 Web 工作线程等现代 Web 工具中使用。<code>XMLHttpRequest</code>可以选择异步，而 Fetch API 则必须是异步。</p><p>Fetch API 是 WHATWG 的一个“活标准”（living standard)，用规范原文说，就是“Fetch 标准定义请求、响应，以及绑定二者的流程：获取（fetch）”。</p><p>Fetch API 本身是使用 JavaScript 请求资源的优秀工具，同时这个 API 也能够应用在服务线程（service worker）中，提供拦截、重定向和修改通过<code>fetch()</code>生成的请求接口。</p><h2>基本用法</h2><p><code>fetch()</code>方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，浏览器就会向给定 URL 发送请求。</p><h3>分派请求</h3><p><code>fetch()</code>只有一个必需的参数<code>input</code>。多数情况下，这个参数是要获取资源的 URL。这个方法返回一个期约：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = fetch(&#x27;/bar&#x27;)
console.log(r) // Promise &lt;pending&gt;</code>
        </deckgo-highlight-code><p>URL 的格式（相对路径、绝对路径等）的解释与 XHR 对象一样。</p><p>请求完成、资源可用时，期约会解决为一个<code>Response</code>对象。这个对象是 API 的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;bar.txt&#x27;).then(response =&gt; {
  console.log(response)
})

// Response {type: &#x27;basic&#x27;, url: ... }</code>
        </deckgo-highlight-code><h3>读取响应</h3><p>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到<code>text()</code>方法。这个方法返回一个期约，会解决为取得资源的完整内容：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;bar.txt&#x27;).then(response =&gt; {
  response.text().then(data =&gt; {
    console.log(data)
  })
})

// bar.txt的内容</code>
        </deckgo-highlight-code><p>内容的结构通常是打平的：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;bar.txt&#x27;)
  .then(response =&gt; response.text())
  .then(data =&gt; console.log(data))</code>
        </deckgo-highlight-code><h3>处理状态码和请求失败</h3><p>Fetch API 支持通过<code>Response</code>的<code>status</code>（状态码）和<code>statusText</code>（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/bar&#x27;).then(response =&gt; {
  console.log(response.status) // 200
  console.log(response.statusText) // OK
})</code>
        </deckgo-highlight-code><p>请求不存在的资源通常会产生值为 404 的状态码：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/does-not-exist&#x27;).then(response =&gt; {
  console.log(response.status) // 404
  console.log(response.statusText) // Not Found
})</code>
        </deckgo-highlight-code><p>请求的 URL 如果抛出服务器错误会产生值为 500 的状态码：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/does-not-exist&#x27;).then(response =&gt; {
  console.log(response.status) // 500
  console.log(response.statusText) // Internal Server Error
})</code>
        </deckgo-highlight-code><p>可以显式地设置<code>fetch()</code>在遇到重定向时的行为，不过默认行为是跟随重定向并返回状态码不是 300 ～ 399 的响应。跟随重定向时，响应对象的<code>redirected</code>属性会被设置为<code>true</code>，而状态码仍然是 200：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/permament-redirect&#x27;).then(response =&gt; {
  // 默认行为是跟随重定向直到最终URL
  // 这个例子会出现至少两轮网络请求
  // &lt;origin url&gt;/permament-redirect ==&gt; &lt;redirect url&gt;
  console.log(response.status) // 200
  console.log(response.statusText) // OK
  console.log(response.redirected) // true
})</code>
        </deckgo-highlight-code><p>在前面这几个例子中，虽然请求可能失败（例如状态码为 500），但都只执行了期约的<strong>解决</strong>处理函数。事实上，只要服务器返回了响应，<code>fetch()</code>期约都会解决。这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。</p><p>通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非 200 ～ 299 时检查<code>Response</code>对象的<code>ok</code>属性：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/bar&#x27;).then(response =&gt; {
  console.log(response.status) // 200
  console.log(response.ok) // true
})

fetch(&#x27;/does-not-exist&#x27;).then(response =&gt; {
  console.log(response.status) // 404
  console.log(response.ok) // false
})</code>
        </deckgo-highlight-code><p>因为服务器没有响应而导致浏览器超时，这样真正的<code>fetch()</code>失败会导致期约被拒绝：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;/hangs-forever&#x27;).then(
  response =&gt; {
    console.log(response)
  },
  err =&gt; {
    console.log(err)
  }
)

// （浏览器超时后）
// TypeError: &quot;NetworkError when attempting to fetch resource.&quot;</code>
        </deckgo-highlight-code><p>违反 CORS、无网络连接、HTTPS 错配以及其他浏览器/网络策略问题都会导致期约被拒绝。</p><p>可以通过<code>url</code>属性检查通过<code>fetch()</code>发送请求时使用的完整 URL：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// foo.com/bar/baz 发送的请求
console.log(window.location.href) // https://foo.com/bar/baz

fetch(&#x27;qux&#x27;).then(response =&gt; console.log(response.url)) // https://foo.com/bar/qux

fetch(&#x27;//qux.com&#x27;).then(response =&gt; console.log(response.url)) // https://qux.com

fetch(&#x27;https://qux.com&#x27;).then(response =&gt; console.log(response.url)) // https://qux.com</code>
        </deckgo-highlight-code><h3>自定义选项</h3><p>只使用 URL 时，<code>fetch()</code>会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数<code>init</code>对象。<code>init</code>对象要按照下表中的键/值对进行填充。</p><table><thead><tr><th align="center">键</th><th align="left">值</th></tr></thead><tbody><tr><td align="center"><code>body</code></td><td align="left">指定使用请求体时请求体的内容。必须是<code>Blob</code>、<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code>、<code>ReadableStream</code>或<code>String</code>的实例。</td></tr><tr><td align="center"><code>cache</code></td><td align="left">用于控制浏览器与 HTTP 缓存的交互。要跟踪缓存的重定向，请求的<code>redirect</code>属性值必须是<code>follow</code>，而且必须符合同源策略限制。必须是下列值之一：1) <code>Default</code>。此时<code>fetch()</code>返回命中的有效缓存，不发送请求；命中无效（stale）缓存会发送条件式请求。如果响应已经改变，则更新缓存的值。然后<code>fetch()</code>返回缓存的值；命中缓存会发送请求，并缓存响应。然后<code>fetch()</code>返回响应。2）<code>no-store</code>。浏览器不检查缓存，直接发送请求；不缓存响应，直接通过<code>fetch()</code>返回。3）<code>reload</code>。浏览器不检查缓存，直接发送请求；缓存响应，再通过<code>fetch()</code>返回。4）<code>no-cache</code>。无论命中有效缓存还是无效缓存都会发送条件式请求。如果响应已经改变，则更新缓存的值。然后<code>fetch()</code>返回缓存的值；未命中缓存会发送请求，并缓存响应。然后<code>fetch()</code>返回响应。5)<code>force-cache</code>。无论命中有效缓存还是无效缓存都通过<code>fetch()</code>返回。不发送请求；命中无效缓存会发送请求，并缓存响应。然后<code>fetch()</code>返回响应；6）<code>only-if-cached</code>。只在请求模式为<code>same-origin</code>时使用缓存；无论命中有效缓存还是无效缓存都通过<code>fetch()</code>返回，不发送请求；未命中缓存返回状态码为 504（网关超时）的响应。</td></tr><tr><td align="center"><code>credentials</code></td><td align="left">用于指定在外发请求中如何包含 cookie。与<code>XMLHttpRequest</code>的<code>withCredentials</code>标签类似必须是下列字符串值之一：1）<code>omit</code>：不发送 cookie；2）<code>same-origin</code>：只在请求 URL 与发送<code>fetch()</code>请求的页面同源时发送 cookie；3）<code>include</code>：无论同源还是跨源都包含 cookie。在支持 Credential Management API 的浏览器中，也可以是一个<code>FederatedCredential</code>或<code>PasswordCredential</code>的实例。默认为<code>same-origin</code>。</td></tr><tr><td align="center"><code>headers</code></td><td align="left">用于指定头部。必须是<code>Headers</code>对象实例或者包含字符串格式键/值对的常规对象。默认值不为不包含键/值对的<code>Headers</code>对象。这不意味着请求不包含任何头部，浏览器仍然会随请求发送一些头部。虽然这些头部对 JavaScript 不可见，但浏览器的网络检查器可以观察到。</td></tr><tr><td align="center"><code>integrity</code></td><td align="left">用于强制子资源完整性。必须是包含子资源完整性标志服的字符串。默认为空字符串。</td></tr><tr><td align="center"><code>keepalive</code></td><td align="left">用于指示浏览器允许请求存在时间超出页面声明周期。适合报告时间或分析，例如页面在<code>fetch()</code>后很快卸载。设置<code>keepalive</code>标识的<code>fetch()</code>请求可用于替代<code>Navigator.sendBeacon()。</code>必须是布尔值。默认为<code>false</code>。</td></tr><tr><td align="center"><code>method</code></td><td align="left">用于指定 HTTP 请求方法。基本上就是如下字符串值：<code>&quot;GET&quot;</code>、<code>&quot;POST&quot;</code>、<code>&quot;PUT&quot;</code>、<code>&quot;PATCH&quot;</code>、<code>&quot;DELETE&quot;</code>、<code>&quot;HEAD&quot;</code>、<code>&quot;OPTIONS&quot;</code>、<code>&quot;CONNECT&quot;</code>、<code>&quot;TRACE&quot;</code>。默认为<code>&quot;GET&quot;</code>。</td></tr><tr><td align="center"><code>mode</code></td><td align="left">用于指定请求模式。这个模式决定来自跨源请求的响应是否有效，以及客户端可以读取多少响应。违反这里指定模式的请求会抛出错误。必须是下列字符串之一：1）<code>cors</code>：允许遵守 CORS 协议的跨源请求。响应是“CORS 过滤的响应”，意思是响应中可以访问的浏览器头部是经过浏览器强制白名单过滤的；2）<code>no-cors</code>：允许不要发送预检请求的跨源请求（HEAD、GET 和只有带满足 CORS 请求头部的 POST）。响应类型是<code>opaque</code>，意思是不能读取响应内容；3）<code>same-origin</code>：任何跨源请求都不允许发送；4）<code>navigate</code>：用于支持 HTML 导航，只在文档间导航时使用，基本用不到。在通过构造函数手动创建<code>Request</code>实例时使用<code>mode</code>则默认为<code>cors</code>；否则默认为<code>no-cors</code>。</td></tr><tr><td align="center"><code>redirect</code></td><td align="left">用于指定如何处理重定向响应（状态码为 301、302、303、307 或 308）。必须是下列字符串值之一：1）<code>follow</code>：跟踪重定向请求，以最终非重定向 URL 的响应作为最终响应；2）<code>error</code>：重定向请求会抛出错误；3）<code>manual</code>：不跟踪重定向请求，而是返回<code>opaqueredirect</code>类型的响应，同时仍然暴露期望的重定向 URL，允许以手动方式跟踪重定向。默认为<code>follow</code>。</td></tr><tr><td align="center"><code>referrer</code></td><td align="left">用于指定 HTTP 的<code>Referer</code>头部的内容。必须是下列字符串值之一：1）<code>no-referrer</code>：以<code>no-referrer</code>作为值；2）<code>client/about:client</code>：以当前 URL 或<code>no-referrer</code>（取决于来源策略<code>referrerPolicy</code>）作为值；3）<code>&lt;URL&gt;</code>：以伪造 URL 作为值。伪造 URL 的源必须与执行脚本的源匹配。默认为<code>client/about:client</code>。</td></tr><tr><td align="center"><code>refererPolicy</code></td><td align="left">用于指定 HTTP 的<code>Referrer</code>头部。必须是下列字符串之一：1）<code>no-referrer</code>：请求中不包含<code>Referrer</code>头部；2）<code>no-referrer-when-downgrade</code>：对于从安全 HTTPS 上下文发送到 HTTP URL 的请求，不包含<code>Referrer</code>头部，对于所有其他请求，将<code>Referer</code>设置为完整 URL；3）<code>origin</code>：对于所有请求，将<code>Referer</code>设置为只包含源；4）<code>same-origin</code>：对于跨源请求，不包含<code>Referer</code>头部，对于同源请求，将<code>Referer</code>设置为完整 URL；5）<code>strict-origin</code>：对于从安全 HTTPS 上下文发送到 HTTP URL 的请求，不包含<code>Referer</code>头部，对于所有其他请求将<code>Refer</code>设置为只包含源；6）<code>origin-when-cross-origin</code>：对于跨源请求，将<code>Referer</code>设置为只包含源，对于同源请求，将<code>Referer</code>设置为完整 URL；7）<code>strict-origin-when-cross-origin</code>：对于从安全 HTTPS 上下文发送到 HTTP URL 的请求，不包含<code>Referer</code>头部，对于所有其他跨源请求，将<code>Referer</code>设置为只包含源，对于同源请求，将<code>Referer</code>设置为完整 URL；8）<code>unsafe-url</code>：对于所有请求，将<code>Referer</code>设置为完整 URL。默认为<code>no-referrer-when-downgrade</code>。</td></tr><tr><td align="center"><code>signal</code></td><td align="left">用于支持通过<code>AbortController</code>中断进行中的<code>fetch()</code>请求。必须是<code>AbortSignal</code>的实例；默认为未关联控制器的<code>AbortSignal</code>实例。</td></tr></tbody></table><h2>常见 Fetch 请求模式</h2><p>与<code>XMLHttpRequest</code>一样，<code>fetch()</code>既可以发送数据也可以接收数据。使用<code>init</code>对象参数，可以配置<code>fetch()</code>在请求体中发送各种序列化的数据。</p><h3>发送 JSON 数据</h3><p>可以像这样发送简单 JSON 字符串：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const payload = JSON.stringify({
  foo: &#x27;bar&#x27;,
})

const jsonHeaders = new Headers({
  &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,
})

fetch(&#x27;/send-me-json&#x27;, {
  method: &#x27;POST&#x27;,
  body: payload,
  headers: jsonHeaders,
})</code>
        </deckgo-highlight-code><h3>在请求体中发送参数</h3><p>因为请求体支持任意字符串值，可以通过它发送请求参数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const payload = &#x27;foo=bar&amp;baz=quz&#x27;

const paramHeaders = new Headers({
  &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;,
})

fetch(&#x27;/send-me-params&#x27;, {
  method: &#x27;POST&#x27;, // 发送请求体时必须使用一种HTTP方法
  body: payload,
  headers: paramHeaders,
})</code>
        </deckgo-highlight-code><h3>发送文件</h3><p>因为请求体支持<code>FormData</code>实现，所以<code>fetch()</code>也可以序列化并发送文件字段中的文件：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const imageFormData = new FormData()
const imageInput = document.querySelector(`input[type=&#x27;file&#x27;]`)

imageFormData.append(&#x27;image&#x27;, imageInput.files[0])

fetch(&#x27;/img-upload&#x27;, {
  method: &#x27;POST&#x27;,
  body: imageFormData,
})</code>
        </deckgo-highlight-code><p>这个<code>fetch()</code>实现可以支持多个文件：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const imageFormData = new FormData()
const imageInput = document.querySelector(`input[type=&#x27;file&#x27;][multiple]`)

for (let i = 0; i &lt; imageInput.files.length; i++) {
  imageFormData.append(&#x27;image&#x27;, imageInput.files[i])
}

fetch(&#x27;/img-upload&#x27;, {
  method: &#x27;POST&#x27;,
  body: imageFormData,
})</code>
        </deckgo-highlight-code><h3>加载<code>Blob</code>文件</h3><p>Fetch API 也能提供<code>Blob</code>类型的响应，而<code>Blob</code>又可以兼容多种浏览器 API。一种常见的做法是明确将图片文件加载到内存，然后将其添加到 HTML 图片元素。为此，可以使用响应对象上暴露的<code>blob()</code>方法。这个方法返回一个期约，解决为一个<code>Blob</code>的实例。然后可以将这个实例传给<code>URL.createObjectURL()</code>以生成可以添加给图片元素<code>src</code>属性的值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const imageElement = document.querySelector(&#x27;img&#x27;)

fetch(&#x27;my-image.png&#x27;)
  .then(response =&gt; response.blob())
  .then(blobl =&gt; (imageElement.src = URL.createObjectURL(blob)))</code>
        </deckgo-highlight-code><h3>发送跨源请求</h3><p>从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;//cross-origin.com&#x27;)
// TypeError: Failed to fetch
// No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</code>
        </deckgo-highlight-code><p>如果代码不需要访问响应，也可以发送<code>no-cors</code>请求。此时响应的<code>type</code>属性值为<code>opaque</code>，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;//cross-origin.com&#x27;, { method: &#x27;no-cors&#x27; }).then(response =&gt;
  console.log(response.type)
)

// opaque</code>
        </deckgo-highlight-code><h3>中断请求</h3><p>Fetch API 支持通过<code>AbortController/AbortSignal</code>对中断请求。调用<code>AbortController.abort()</code>会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的<code>fetch()</code>请求会导致包含错误的拒绝。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const abortController = new AbortController()

fetch(&#x27;wikipedia.zip&#x27;, { signal: abortController.signal }).catch(() =&gt;
  console.log(&#x27;aborted!&#x27;)
)

setTimeout(() =&gt; abortController.abort(), 10)</code>
        </deckgo-highlight-code><h2><code>Headers</code>对象</h2><p><code>Headers</code>对象是所有外发请求和入站响应头部的容器。每个外发的<code>Request</code>实例都包含一个空的<code>Headers</code>实例，可以通过<code>Request.prototype.headers</code>访问，每个入站<code>Response</code>实例也可以通过<code>Response.prototype.headers</code>访问包含着响应头部的<code>Headers</code>对象。这两个属性都是可修改属性。另外，通过<code>new Headers()</code>也可以创建一个新实例。</p><h3><code>Headers</code>与<code>Map</code>的相似之处</h3><p><code>Headers</code>对象与<code>Map</code>对象极为相似。这是合理的，因为 HTTP 头部本质上是序列化后的键/值对，它们的 JavaScript 表示则是中间接口。<code>Headers</code>与<code>Map</code>类型都有<code>get()</code>、<code>set()</code>、<code>has()</code>和<code>delete()</code>等实例方法。如下面代码所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const h = new Headers()
const m = new Map()

h.set(&#x27;foo&#x27;, &#x27;bar&#x27;)
m.set(&#x27;foo&#x27;, &#x27;bar&#x27;)

console.log(h.has(&#x27;foo&#x27;))
console.log(m.has(&#x27;foo&#x27;))

console.log(h.get(&#x27;foo&#x27;))
console.log(m.get(&#x27;foo&#x27;))

h.set(&#x27;foo&#x27;, &#x27;baz&#x27;)
m.set(&#x27;foo&#x27;, &#x27;baz&#x27;)

h.delete(&#x27;foo&#x27;)
m.delete(&#x27;foo&#x27;)</code>
        </deckgo-highlight-code><p><code>Headers</code>和<code>Map</code>都可以使用一个可迭代对象来初始化，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const seed = [[&#x27;foo&#x27;, &#x27;bar&#x27;]]

const h = new Headers(seed)
const m = new Map(seed)

console.log(h.get(&#x27;foo&#x27;))
console.log(m.get(&#x27;foo&#x27;))</code>
        </deckgo-highlight-code><p>而且，它们也都有相同的<code>keys()</code>、<code>values()</code>和<code>entries()</code>迭代器接口：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const seed = [
  [&#x27;foo&#x27;, &#x27;bar&#x27;],
  [&#x27;baz&#x27;, &#x27;qux&#x27;],
]

const h = new Headers(seed)
const m = new Map(seed)

console.log(...h.keys())
console.log(...m.keys())

console.log(...h.values())
console.log(...m.values())

console.log(...h.entries())
console.log(...m.entries())</code>
        </deckgo-highlight-code><h3><code>Headers</code>独有的特性</h3><p><code>Headers</code>并不是与<code>Map</code>处处都一样。在初始化<code>Headers</code>对象时，也可以使用键/值对形式的对象，而<code>Map</code>不可以：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const seed = { foo: &#x27;bar&#x27; }

const h = new Headers(seed)
console.log(h.get(&#x27;foo&#x27;)) // bar

const m = new Map(seed)
// TypeError: object is not iterable</code>
        </deckgo-highlight-code><p>一个 HTTP 头部字段可以有多个值，而<code>Headers</code>对象通过<code>append()</code>方法支持添加多个值。在<code>Headers</code>实例中还不存在的头部上调用<code>append()</code>方法相当于调用<code>set()</code>。后续调用会以逗号分隔符拼接多个值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const h = new Headers()

h.append(&#x27;foo&#x27;, &#x27;bar&#x27;)
console.log(h.get(&#x27;foo&#x27;)) // &#x27;bar&#x27;

h.append(&#x27;foo&#x27;, &#x27;baz&#x27;)
console.log(h.get(&#x27;foo&#x27;)) // &#x27;bar, baz&#x27;</code>
        </deckgo-highlight-code><h3>头部护卫</h3><p>某些情况下，并非所有 HTTP 头部都可以被客户端修改，而<code>Headers</code>对象使用护卫来防止不被允许的修改。不同的护卫设置会改变<code>set()</code>、<code>append()</code>和<code>delete()</code>的行为。违反护卫限制会抛出<code>TypeError</code>。</p><p><code>Headers</code>实例会因来源不同而展现不同的行为，它们的行为由护卫来控制。JavaScript 可以决定<code>Headers</code>实例的护卫设置，下表列出了不同的护卫设置和每种设置对应的行为。</p><table><thead><tr><th align="center">护卫</th><th align="center">适用情形</th><th align="center">限制</th></tr></thead><tbody><tr><td align="center"><code>none</code></td><td align="center">在通过构造函数创建<code>Headers</code>实例时激活</td><td align="center">无</td></tr><tr><td align="center"><code>request</code></td><td align="center">在通过构造函数初始化<code>Request</code>对象，且<code>mode</code>值为非<code>no-cors</code>时激活</td><td align="center">不允许修改禁止修改的头部（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name">MDN 禁止修改的请求头部</a>）</td></tr><tr><td align="center"><code>request-no-cors</code></td><td align="center">在通过构造函数初始化<code>Request</code>对象，且<code>mode</code>值为<code>no-cors</code>时激活</td><td align="center">不允许修改非简单头部（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header">MDN 简单头部</a>）</td></tr><tr><td align="center"><code>response</code></td><td align="center">在通过构造函数初始化<code>Response</code>对象时激活</td><td align="center">不允许修改禁止修改的响应头部（<a href="https://fetch.spec.whatwg.org/#forbidden-response-header-name">禁止修改的响应头部</a>）</td></tr><tr><td align="center"><code>immutable</code></td><td align="center">在通过<code>error()</code>或<code>redirect()</code>静态方法初始化<code>Response</code>对象时激活</td><td align="center">不允许修改任何头部</td></tr></tbody></table><h2><code>Request</code>对象</h2><p>顾名思义，<code>Request</code>对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。</p><h3>创建<code>Request</code>对象</h3><p>可以通过构造函数初始化<code>Request</code>对象。为此需要传入一个<code>input</code>参数，一般是 URL：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;)
console.log(r)
// Request {...}</code>
        </deckgo-highlight-code><p><code>Request</code>构造函数也接收第二个参数——一个<code>init</code>对象。这个<code>init</code>对象与前面介绍的<code>fetch()</code>的<code>init</code>对象一样。没有在<code>init</code>对象中涉及的值则会使用默认值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 用所有默认值创建Request对象
console.log(new Request(&#x27;&#x27;))

// Request {
//   bodyUsed: false
//   cache: &quot;default&quot;
//   credentials: &quot;same-origin&quot;
//   destination: &quot;&quot;
//   headers: Headers {}
//   integrity: &quot;&quot;
//   isHistoryNavigation: false
//   keepalive: false
//   method: &quot;GET&quot;
//   mode: &quot;cors&quot;
//   redirect: &quot;follow&quot;
//   referrer: &quot;about:client&quot;
//   referrerPolicy: &quot;&quot;
//   signal: AbortSignal {aborted: false, reason: undefined, onabort: null}
//   url: &quot;https://foo.com/&quot;
// }

// 用指定的初始值创建Request对象
console.log(new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27; }))

// Request {
//   bodyUsed: false
//   cache: &quot;default&quot;
//   credentials: &quot;same-origin&quot;
//   destination: &quot;&quot;
//   headers: Headers {}
//   integrity: &quot;&quot;
//   isHistoryNavigation: false
//   keepalive: false
//   method: &quot;POST&quot;
//   mode: &quot;cors&quot;
//   redirect: &quot;follow&quot;
//   referrer: &quot;about:client&quot;
//   referrerPolicy: &quot;&quot;
//   signal: AbortSignal {aborted: false, reason: undefined, onabort: null}
//   url: &quot;https://foo.com/&quot;
// }</code>
        </deckgo-highlight-code><h3>克隆<code>Request</code>对象</h3><p>Fetch API 提供了两种不太一样的方式用于创建<code>Request</code>对象的副本：使用<code>Request</code>构造函数和使用<code>clone()</code>方法。</p><p>将<code>Request</code>实例作为<code>Input</code>参数传给<code>Request</code>构造函数，会得到该请求的一个副本：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Request(&#x27;https://foo.com&#x27;)
const r2 = new Request(r1)

console.log(r2.url) // https://foo.com/</code>
        </deckgo-highlight-code><p>如果再传入<code>init</code>对象，则<code>init</code>对象的值会覆盖源对象中同名的值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Request(&#x27;https://foo.com&#x27;)
const r2 = new Request(r1, { method: &#x27;POST&#x27; })

console.log(r1.method) // GET
console.log(r2.method) // POST</code>
        </deckgo-highlight-code><p>这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; })
const r2 = new Request(r1)

console.log(r1.bodyUsed) // true
console.log(r2.bodyUsed) // false</code>
        </deckgo-highlight-code><p>如果源对象与创建的新对象不同源，则<code>referrer</code>属性会被清除。此外，如果源对象的<code>mode</code>为<code>navigate</code>，则会被转换为<code>same-origin</code>。</p><p>第二种克隆<code>Request</code>对象的方法是使用<code>clone()</code>方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; })
const r2 = r1.clone()

console.log(r1.url) // https://foo.com/
console.log(r2.url) // https://foo.com/

console.log(r1.bodyUsed) // false
console.log(r2.bodyUsed) // false</code>
        </deckgo-highlight-code><p>如果请求对象的<code>bodyUsed</code>属性为<code>true</code>（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。在请求体被读取之后再克隆会导致抛出<code>TypeError</code>。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;)
r.clone()
new Request(r) // 没有错误

r.text() // 设置bodyUsed为true
r.clone()
// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Request&#x27;: Request body is already used

new Request(r)
// TypeError: Failed to construct &#x27;Request&#x27;: Cannot construct a Request with a Requset object that has already been used.</code>
        </deckgo-highlight-code><h3>在<code>fetch()</code>中使用<code>Request</code>对象</h3><p><code>fetch()</code>和<code>Request</code>构造函数拥有相同的函数签名并不是巧合。在调用<code>fetch()</code>时，可以传入已经创建好的<code>Request</code>实例而不是 URL。与<code>Request</code>构造函数一样，传给<code>fetch()</code>的<code>init</code>对象会覆盖传入请求对象的值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;)

// 向foo.com发送GET请求
fetch(r)

// 向foo.com发送POST请求
fetch(r, { method: &#x27;POST&#x27; })</code>
        </deckgo-highlight-code><p><code>fetch()</code>会在内部克隆传入的<code>Request</code>对象。与克隆<code>Request</code>一样，<code>fetch()</code>也不能拿请求体已经用过的<code>Request</code>对象来发送请求：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;GET&#x27;, body: &#x27;foobar&#x27; })
r.text()

fetch(r)
// TypeError: Cannot construct a Request with a Request object that has already been used.</code>
        </deckgo-highlight-code><p>关键在于，通过<code>fetch()</code>使用<code>Request</code>会将请求体标记为已使用。也就是说，有请求体的<code>Request</code>只能在一次<code>fetch</code>中使用。（不包含请求体的请求不受此限制。）演示如下：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; })
fetch(r)
fetch(r)
// TypeError: Cannot contruct a Request with a Request object that has already been used.</code>
        </deckgo-highlight-code><p>要想基于包含请求体的相同<code>Request</code>对象多次调用<code>fetch()</code>，必须在第一次发送<code>fetch()</code>请求前调用<code>clone()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Request(&#x27;https://foo.com&#x27;, { method: &#x27;POST&#x27;, body: &#x27;foobar&#x27; })

fetch(r.clone())
fetch(r.clone())
fetch(r)
// 3个都会成功</code>
        </deckgo-highlight-code><h2><code>Response</code>对象</h2><p>顾名思义，<code>Response</code>对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p><h3>创建<code>Response</code>对象</h3><p>可以通过构造函数初始化<code>Response</code>对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的 HTTP 响应：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Response()
console.log(r)
// Response {
//   body: (...)
//   bodyUsed: false
//   headers: Headers {}
//   ok: true
//   redirected: false
//   status: 200
//   statusText: &#x27;OK&#x27;
//   type: &#x27;default&#x27;
//   url: &#x27;&#x27;
// }</code>
        </deckgo-highlight-code><p><code>Response</code>构造函数接收一个可选的<code>body</code>参数。这个<code>body</code>可以是<code>null</code>，等同于<code>fetch()</code>参数<code>init</code>中的<code>body</code>。还可以接收一个可选的<code>init</code>对象，这个对象可以包含下表所列的键和值。</p><table><thead><tr><th align="center">键</th><th align="center">值</th></tr></thead><tbody><tr><td align="center"><code>headers</code></td><td align="center">必须是<code>Headers</code>对象实例或包含字符串键/值对的常规对象实例；默认为没有键/值对的<code>Headers</code>对象</td></tr><tr><td align="center"><code>status</code></td><td align="center">表示 HTTP 响应状态码的整数；默认为 200</td></tr><tr><td align="center"><code>statusText</code></td><td align="center">表示 HTTP 响应状态的字符串；默认为空字符串</td></tr></tbody></table><p>可以像下面这样使用<code>body</code>和<code>init</code>来构建<code>Response</code>对象：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Response(&#x27;foobar&#x27;, {
  status: 418,
  statusText: `I&#x27;m a teapot`,
})
console.log(r)
// Reponse {
//   body: (...)
//   bodyUsed: false
//   headers: Headers {}
//   ok: false
//   redirected: false
//   status: 418
//   statusText: &quot;I&#x27;m a teapot&quot;
//   type: &quot;default&quot;
//   url: &quot;&quot;
// }</code>
        </deckgo-highlight-code><p>大多数情况下，产生<code>Response</code>对象的主要方式是调用<code>fetch()</code>，它返回一个最后解决为<code>Response</code>对象的期约，这个<code>Response</code>对象代表实际的 HTTP 响应。下面的代码展示了这样得到的<code>Response</code>对象：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;).then(response =&gt; {
  console.log(response)
})
// Response {
//   body: (...)
//   bodyUsed: false
//   headers: Headers {}
//   ok: true
//   redirected: false
//   status: 200
//   statusText: &quot;OK&quot;
//   type: &quot;basic&quot;
//   url: &quot;https://foo.com/&quot;
// }</code>
        </deckgo-highlight-code><p><code>Response</code>类还有两个用于生成<code>Response</code>对象的静态方法：<code>Response.redirect()</code>和<code>Response.error()</code>。前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），或返回重定向的<code>Response</code>对象：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(Response.redirect(&#x27;https://foo.com&#x27;, 301))
// Response {
//   body: (...)
//   bodyUsed: false
//   headers: Headers {}
//   ok: false
//   redirected: false
//   status: 301
//   statusText: &quot;&quot;
//   type: &quot;default&quot;
//   url: &quot;&quot;
// }</code>
        </deckgo-highlight-code><p>提供的状态必须对应重定向，否则会抛出错误：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">Response.redirect(&#x27;https://foo.com&#x27;, 200)
// RangeError: Failed to execute &#x27;redirect&#x27; on &#x27;Response&#x27;: Invalid status code</code>
        </deckgo-highlight-code><p>另一个静态方法<code>Response.error()</code>用于产生表示网络错误的<code>Response</code>对象（网络错误会导致<code>fetch()</code>期约被拒绝）。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(Response.error())
// Response {
//   body: (...)
//   bodyUsed: false
//   headers: Headers {}
//   ok: false
//   redirected: false
//   status: 0
//   statusText: &quot;&quot;
//   type: &quot;error&quot;
//   url: &quot;&quot;
// }</code>
        </deckgo-highlight-code><h3>读取响应状态信息</h3><p><code>Response</code>对象包含一组只读属性，描述了请求完成后的状态，如下表示：</p><table><thead><tr><th align="center">属性</th><th align="center">值</th></tr></thead><tbody><tr><td align="center"><code>headers</code></td><td align="center">响应包含的<code>Headers</code>对象</td></tr><tr><td align="center"><code>ok</code></td><td align="center">布尔值，表示 HTTP 状态码的含义；200 ～ 299 的状态码返回<code>true</code>；其他状态码返回<code>false</code></td></tr><tr><td align="center"><code>redirected</code></td><td align="center">布尔值，表示响应是否至少经过一次重定向</td></tr><tr><td align="center"><code>status</code></td><td align="center">整数，表示响应的 HTTP 状态码</td></tr><tr><td align="center"><code>statusText</code></td><td align="center">字符串，包含对 HTTP 状态码的正式描述。这个值派生自可选的 HTTP Reason-Phrase 字段，因此如果服务器以 Reason-Phrase 为由拒绝响应，这个字段可能是空字符串</td></tr><tr><td align="center"><code>type</code></td><td align="center">字符串，表示响应类型；可能是下列字符串之一：1）<code>basic</code>：表示标准的同源响应；2）<code>cors</code>：表示标准的跨源响应；3）<code>error</code>：表示响应对象是通过<code>Response.error()</code>创建的；4）<code>opaque</code>：表示<code>no-cors</code>的<code>fetch()</code>返回的跨源响应；5）<code>opaqueredirect</code>：表示对<code>redirect</code>设置为<code>manual</code>的请求响应</td></tr><tr><td align="center"><code>url</code></td><td align="center">包含响应 URL 的字符串。对于重定向响应，这是最终的 URL，非重定向响应就是它产生的</td></tr></tbody></table><h3>克隆<code>Response</code>对象</h3><p>克隆<code>Response</code>对象的主要方式是使用<code>clone()</code>方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Response(&#x27;foobar&#x27;)
const r2 = r.clone()

console.log(r1.bodyUsed) // false
console.log(r2.bodyUsed) // false</code>
        </deckgo-highlight-code><p>如果响应对象的<code>bodyUsed</code>属性为<code>true</code>（即响应体已被读取），则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出<code>TypeError</code>。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Response(&#x27;foobar&#x27;)
r.clone()
// 没有错误

r.text() // 设置bodyUsed为true

r.clone()
// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Response&#x27;: Response body is already used</code>
        </deckgo-highlight-code><p>有响应体的<code>Response</code>对象只能读取一次。（不包含响应体的<code>Response</code>对象不受此限制。）例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Response(&#x27;foobar&#x27;)
r.text().then(console.log) // foobar
r.text().then(console.log)
// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</code>
        </deckgo-highlight-code><p>要多次读取包含响应体的同一个<code>Response</code>对象，必须在第一次读取前调用<code>clone()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r = new Response(&#x27;foobar&#x27;)

r.clone().text().then(console.log) // foobar
r.clone().text().then(console.log) // foobar
r.text().then(console.log) // foobar</code>
        </deckgo-highlight-code><p>此外通过创建带有原始响应体的<code>Response</code>实例，可以执行伪克隆操作。关键是这样不会把第一个<code>Response</code>实例标记为已读，而是会在两个响应之间共享：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const r1 = new Response(&#x27;foobar&#x27;)
const r2 = new Response(r1.body)

console.log(r1.bodyUsed) // false
console.log(r2.bodyUsed) // false

r2.text().then(console.log) // foobar
r1.text().then(console.log)
// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</code>
        </deckgo-highlight-code><h2><code>Request</code>、<code>Response</code>和<code>Body</code>混入</h2><p><code>Request</code>和<code>Response</code>都使用了 Fetch API 的<code>Body</code>混入，以实现两者承担有效载荷的能力。这个混入为两个类提供了只读的<code>body</code>属性（实现为<code>ReadableSTream</code>）、只读的<code>bodyUsed</code>布尔值（表示<code>body</code>流是否已读）和一组方法，用于从流中读取内容，并将结果转换为某种 JavaScript 对象类型。</p><p>通常，将<code>Request</code>和<code>Response</code>主体作为流来使用主要有两个原因。一个原因是有效载荷的大小可能会导致网络延迟，另一个原因是流 API 本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。</p><p><code>Body</code>混入提供了 5 个方法，用于将<code>ReadableStream</code>转存到缓冲区的内存里，将缓冲区转换为某种 JavaScript 对象类型，以及通过期约来产生结果。在解决之前，期约会等待主体流报告完成及缓冲被解析。这意味着客户端必须等待响应的资源完全加载才能访问其内容。</p><h3><code>Body.text()</code></h3><p><code>Body.text()</code>方法返回期约，解决为将缓冲区转存得到的 UTF-8 个格式字符串。下面的代码展示了在<code>Response</code>对象上使用<code>Body.text()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;)
  .then(response =&gt; response.text())
  .then(console.log)</code>
        </deckgo-highlight-code><p>以下代码展示了在<code>Request</code>对象上使用<code>Body.text()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;barbazqux&#x27;,
})

request.text().then(console.log)
// barbazqux</code>
        </deckgo-highlight-code><h3><code>Body.json()</code></h3><p><code>Body.json()</code>方法返回期约，解决为将缓冲区转存得到的 JSON。下面的代码展示了在<code>Response</code>对象上使用<code>Body.json()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com/foo.json&#x27;)
  .then(response =&gt; response.json())
  .then(console.log)

// { &quot;foo&quot;: &quot;bar&quot; }</code>
        </deckgo-highlight-code><p>以下代码展示了在<code>Request</code>对象上使用<code>Body.json()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: JSON.stringify({ bar: &#x27;baz&#x27; }),
})

request.json().then(console.log)
// { &quot;bar&quot;: &#x27;baz&#x27;}</code>
        </deckgo-highlight-code><h3><code>Body.formData()</code></h3><p>浏览器可以将<code>FormData</code>对象序列化/反序列化为主体。例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const myFormData = new FormData()
myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;)</code>
        </deckgo-highlight-code><p>在通过 HTTP 传送时，WebKit 浏览器会将其序列化为以下内容：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">------WebKitFormBoundarydR9Q2kOzE6nbN7eR
Content-Disposition: form-data; name=&quot;foo&quot;
bar
------WebKitFormBoundarydR9Q2kOzE6nbN7eR--</code>
        </deckgo-highlight-code><p><code>Body.formData()</code>方法返回期约，解决为将缓冲区转存得到的<code>FormData</code>实例。下面的代码展示了在<code>Response</code>对象上使用<code>Body.formData()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com/form-data&#x27;)
  .then(response =&gt; response.formData())
  .then(formData =&gt; console.log(formData.get(&#x27;foo&#x27;)))
//bar</code>
        </deckgo-highlight-code><p>下面例子展示了在<code>Request</code>对象上使用<code>Body.formData()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const myFormData = new FormData()
myFormData.append(&#x27;foo&#x27;, &#x27;bar&#x27;)

const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: myFormData,
})

request.formData().then(formData =&gt; console.log(formData.get(&#x27;foo&#x27;)))
// bar</code>
        </deckgo-highlight-code><h3><code>Body.arrayBuffer()</code></h3><p>有时候，可能需要以原始二进制格式查看和修改主体。为此，可以使用<code>Body.arrayBuffer()</code>将主体内容转换为<code>ArrayBuffer</code>实例。<code>Body.arrayBuffer()</code>方法返回期约，解决为将缓冲区转存得到的<code>ArrayBuffer</code>实例。下面的代码演示了在<code>Response</code>对象上使用<code>Body.arrayBuffer()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;)
  .then(response =&gt; response.arrayBuffer())
  .then(console.log)

// ArrayBuffer (...) {}</code>
        </deckgo-highlight-code><p>以下代码展示了在<code>Request</code>对象上使用<code>Body.arrayBuffer()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;abcdefg&#x27;,
})

request.arrayBuffer().then(buf =&gt; console.log(new Int8Array(buf)))
// Int8Array(7) [97, 98, 99, 100, 101, 102, 103]</code>
        </deckgo-highlight-code><h3><code>Body.blob()</code></h3><p>有时候，可能需要以原始二进制格式使用主体，不用查看和修改。为此可以使用<code>Body.blob()</code>将主体内容转换为<code>Blob</code>实例。<code>Body.blob()</code>方法返回期约，解决为将缓冲区转存得到的<code>Blob</code>实例。下面的代码展示了在<code>Response</code>对象上使用<code>Body.blob()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;)
  .then(response =&gt; response.blob())
  .then(console.log)

// Blob (...) {size:..., type: &quot;...&quot;}</code>
        </deckgo-highlight-code><p>以下代码展示了在<code>Request</code>对象上使用<code>Body.blob()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;abcdefg&#x27;,
})

request.blob().then(console.log)
// Blob(7) {size: 7, type: &#x27;text/plain;charset=utf-8&#x27;}</code>
        </deckgo-highlight-code><h3>一次性流</h3><p>因为<code>Body</code>混入是构建在<code>ReadableStream</code>之上的，所以主体流只能使用一次。这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;).then(response =&gt;
  response.blob().then(() =&gt; response.blob())
)

// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked
const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;foobar&#x27;,
})

request.blob().then(() =&gt; request.blob())
//TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked</code>
        </deckgo-highlight-code><p>即使是在读取流的过程中，所有这些方法也会在它们被调用时给<code>ReadableStream</code>枷锁，以阻止其他读取器访问：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://foo.com&#x27;).then(response =&gt; {
  response.blob() // 第一次调用给流加锁
  response.blob() // 第二次调用再次加锁会失败
})

// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked
const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;foobar&#x27;,
})

request.blob() // 第一次调用给流加锁
request.blob() // 第二次调用再次加锁会失败
// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked</code>
        </deckgo-highlight-code><p>作为<code>Body</code>混入的一部分，<code>bodyUsed</code>布尔值属性表示<code>ReadableStream</code>是否已<strong>摄受</strong>（disturbed），意思是读取器是否已经在流上加了锁。这不一定表示流已经被完全读取。下面的代码演示了这个属性：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const request = new Request(&#x27;https://foo.com&#x27;, {
  method: &#x27;POST&#x27;,
  body: &#x27;foobar&#x27;,
})
const response = new Response(&#x27;foobar&#x27;)

console.log(request.bodyUsed) // fasle
console.log(request.bodyUsed) // false

request.text().then(console.log) // foobar
request.text().then(console.log) // foobar

console.log(request.bodyUsed) // true
console.log(request.bodyUsed) // true</code>
        </deckgo-highlight-code><h3>使用<code>ReadableStream</code>主体</h3><p>JavaScript 编程逻辑很多时候会将访问网络作为原子操作，比如请求是同时创建和发送的，响应数据也是以统一的格式一次性暴露出来的。这种约定隐藏了底层的混乱，让涉及网络的代码变得很清晰。</p><p>从 TCP/IP 角度来看，传输的数据是以分块形式抵达端点的，而且速度收到网速的限制。接收端点会为此分配内存，并将收到的块写入内存。Fetch API 通过<code>ReadableStream</code>支持在这些块到达时就实时读取和操作这些数据。</p><p>正如 Stream API 所定义的，<code>ReadableStream</code>暴露了<code>getReader()</code>方法，用于产生<code>ReadableStreamDefaultReader</code>，这个读取器可以用于在数据到达时异步获取数据块。数据流的格式是<code>Uint8Array</code>。</p><p>下面的代码调用了读取器的<code>read()</code>方法，把最早可用的块打印了出来：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://fetch.spec.whatwg.org&#x27;)
  .then(response =&gt; response.body)
  .then(body =&gt; {
    const reader = body.getReader()

    console.log(reader) // ReadableStreamDefaultReader {}

    reader.read().then(console.log)
  })

// { value: Uint8Array{}, done: false }</code>
        </deckgo-highlight-code><p>在随着数据流的到来取得整个有效载荷，可以向下面这样递归调用<code>read()</code>方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://fetch.spec.whatwg.org&#x27;)
  .then(response =&gt; response.body)
  .then(body =&gt; {
    const reader = body.getReader()

    function processNextChunk({ value, done }) {
      if (done) {
        return
      }
      console.log(value)

      return reader.read().then(processNextChunk)
    }

    return reader.read().then(processNextChunk)
  })

// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// ...</code>
        </deckgo-highlight-code><p>异步函数非常适合这样的<code>fetch()</code>操作。可以通过使用<code>async/await</code>将上面的递归调用打平：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://fetch.spec.whatwg.org&#x27;)
  .then(response =&gt; response.body)
  .then(async function (body) {
    const reader = body.getReader()

    while (true) {
      const { value, done } = await reader.read()

      if (done) {
        break
      }

      console.log(value)
    }
  })

// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// ...</code>
        </deckgo-highlight-code><p>另外，<code>read()</code>方法也可以直接封装到<code>Iterable</code>接口中。因此可以在<code>for-await-of</code>循环中方便地实现这种转换：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">fetch(&#x27;https://fetch.spec.whatwg.org&#x27;)
  .then(response =&gt; response.body)
  .then(async function (body) {
    const reader = body.getReader()

    const asyncIterable = {
      [Symbol.asyncIterator]() {
        return {
          next() {
            return reader.read()
          },
        }
      },
    }

    for await (const chunk of asyncIterable) {
      console.log(chunk)
    }
  })

// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// { value: Uint8Array{}, done: false }
// ...</code>
        </deckgo-highlight-code><p>通过将异步逻辑包装到一个生成器函数中，还可以进一步简化代码。并且这个实现通过支持读取部分流也变得更稳健。如果流因为耗尽或错误而终止，读取器会释放锁，以允许不同的流读取器继续操作：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">async function* streamGenerator(stream) {
  const reader = stream.getReader()

  try {
    while (true) {
      const { value, done } = await reader.read()

      if (done) {
        break
      }

      yield value
    }
  } finally {
    reader.releaseLock()
  }
}

fetch(&#x27;https://fetch.spec.whatwg.org&#x27;)
  .then(response =&gt; response.body)
  .then(async function (body) {
    for await (const chunk of streamGenerator(body)) {
      console.log(chunk)
    }
  })</code>
        </deckgo-highlight-code><p>在这些例子中，当读取完<code>Uint8Array</code>块之后，浏览器会将其标记为可以被垃圾回收。对于需要在不连续的内存中连续检查大量数据的情况，这样可以节省很多内存空间。</p><p>缓冲区的大小，以及浏览器是否等待缓冲区被填充后才将其推到流中，要根据 JavaScript 运行时的实现。浏览器会控制等待分配的缓冲区被填满，同时会尽快将缓冲区数据（有时候可能未填充数据）发送到流。</p><p>不同浏览器中分块大小可能不同，这取决于带宽和网络延迟。此外，浏览器如果决定不等待网络，也可以将部分填充的缓冲区发送到流。最终，我们的代码要准备好处理以下情况：</p><ul><li>不同大小的<code>Uint8Array</code>块</li><li>部分填充的<code>Uint8Array</code>块</li><li>块到达的时间间隔不确定</li></ul><p>默认情况下，块是以<code>Uint8Array</code>格式抵达的。因为块的分割不会考虑编码，所以会出现某些值作为多字节字符被分散到两个连续块中的情况。手动处理这些情况是很麻烦的，但很多时候可以使用 Encoding API 的可插拔方案。</p><p>要将<code>Uint8Array</code>转换为可读文本，可以将缓冲区传给<code>TextDecoder</code>，返回转换后的值。通过设置<code>stream: true</code>，可以将之前的缓冲区保留在内存，从而让跨越两个块的内容能够被正确解码。</p><h1>Beacon API</h1><p>为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想的情况下是通过浏览器的<code>unload</code>事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。</p><p>再<code>unload</code>事件触发时，分析工具要停止收集信息并把收集到的数据发给服务器。这时候有一个问题，因为<code>unload</code>事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了）。例如，在<code>unload</code>事件处理程序中创建的任何异步请求都会被浏览器取消。为此，异步<code>XMLHttpRequest</code>或<code>fetch()</code>不合适这个任务。分析工具可以使用同步<code>XMLHttpRequest</code>强制发送请求，但这样做会导致用户体验问题。浏览器会因为要等待<code>unload</code>事件处理程序完成而延迟导航到下一个页面。</p><p>为解决这个问题，W3C 引入了补充性的 Beacon API。这个 API 给<code>navigator</code>对象增加了一个<code>sendBeacon()</code>方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST 请求。可选的数据有效载荷参数有<code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code>、<code>FormData</code>实例。如果请求成功进入了最终要发送的任务队列，则这个方法返回<code>true</code>，否则返回<code>false</code>。</p><p>可以像下面这样使用这个方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 发送POST请求
// URL: &#x27;https://example.com/analytics-reporting-url&#x27;
// 请求负载: &#x27;{ foo: &#x27;bar&#x27; }&#x27;

navigator.sendBeacon(
  &#x27;https://example.com/analytics-reporting-url&#x27;,
  &#x27;{ foo: &quot;bar&quot; }&#x27;
)</code>
        </deckgo-highlight-code><p>这个方法虽然看起来只不过是 POST 请求的一个语法糖，但它有几个重要的特性：</p><ul><li><code>sendBeacon()</code>并不是只能在页面生命周期末尾使用，而是任何时候都可以使用。</li><li>调用<code>sendBeacon()</code>后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。</li><li>浏览器保证在原始页面已经关闭的情况下也会发送请求。</li><li>状态码、超时和其他网络原因造成的失败完全是不透明的，不能通过编程方式处理。</li><li>信标（beacon）请求会携带调用<code>sendBeacon()</code>时所有相关的 cookie。</li></ul><h1>Web Socket</h1><p>Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript 中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP 的<code>Upgrade</code>头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务器实现，而必须使用支持该协议的专有服务器。</p><p>因为 Web Socket 使用了自定义协议，所以 URL 方案（scheme）稍有变化：不能再使用 http://或 https://，而要使用 ws://和 wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包含 URL 方案，因为将来有可能再支持其他方案。</p><p>使用自定义协议而非 HTTP 协议的好处是，客户端和服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏览器的支持。</p><h2>API</h2><p>要创建一个新的 Web Socket，就需要实例化一个<code>WebSocket</code>对象并传入提供连接的 URL：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const socket = new WebSocket(&#x27;ws://www.example.com/server.php&#x27;)</code>
        </deckgo-highlight-code><p>注意必须给<code>WebSocket</code>构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（再握手阶段就可以确定请求来自哪里）。</p><p>浏览器会在初始化<code>WebSocket</code>对象之后立即创建连接。与 XHR 类似，<code>WebSocket</code>也有一个<code>readyState</code>属性表示当前状态。不过这个值与 XHR 中相应的值不一样。</p><ul><li><code>WebSocket.OPENING</code>（0）：连接正在建立。</li><li><code>WebSocket.OPEN</code>（1）：连接已经建立。</li><li><code>WebSocket.CLOSING</code>（2）：连接正在关闭。</li><li><code>WebSocket.CLOSE</code>（3）：连接已经关闭。</li></ul><p><code>WebSocket</code>对象没有<code>readystatechange</code>事件，而是有与上述不同状态对应的其他事件。<code>readyState</code>值从 0 开始。</p><p>任何时候都可以调用<code>close()</code>方法关闭 Web Socket 连接：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">socket.close()</code>
        </deckgo-highlight-code><p>调用<code>close()</code>后，<code>readyState</code>立即变为 2（连接正在关闭），并会在关闭后变为 3（连接已经关闭）。</p><h2>发送和接收数据</h2><p>打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用<code>send()</code>方法并传入一个字符串、<code>ArrayBuffer</code>或<code>Blob</code>，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const socket = new WebSocket(&#x27;ws://www.example.com/server.php&#x27;)

const stringData = &#x27;Hello World&#x27;
const arrayBufferData = Uint8Array.from([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;])
const blobData = new Blob([&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;])

socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)</code>
        </deckgo-highlight-code><p>服务器向客户端发送消息时，<code>WebSocket</code>对象上会触发<code>message</code>事件。这个<code>message</code>事件与其他消息协议类似，可以通过<code>event.data</code>属性访问到有效载荷：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">socket.onmessage = function (event) {
  const data = event.data
  // 对数据执行某些操作
}</code>
        </deckgo-highlight-code><p>与通过<code>send()</code>方法发送的数据类似，<code>event.data</code>返回的数据也可能是<code>ArrayBuffer</code>或<code>Blob</code>。这由<code>WebSocket</code>对象的<code>binaryType</code>属性决定，该属性可能是<code>&quot;blob&quot;</code>或<code>&quot;arrayBuffer&quot;</code>。</p><h2>其他事件</h2><p><code>WebSocket</code>对象在连接生命周期中有可能触发 3 个其他事件。</p><ul><li><code>open</code>：在连接成功建立时触发。</li><li><code>error</code>：在发生错误时触发。连接无法存续。</li><li><code>close</code>：在连接关闭时触发。</li></ul><p><code>WebSocket</code>对象不支持 DOM Level2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程序来监听这些事件：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const socket = new WebSocket(&#x27;ws://www.example.com/server.php&#x27;)
socket.onopen = function () {
  alert(&#x27;Connection established.&#x27;)
}
socket.onopen = function () {
  alert(&#x27;Connection error.&#x27;)
}
socket.onclose = function () {
  alert(&#x27;Connection closed.&#x27;)
}</code>
        </deckgo-highlight-code><p>在这些事件中，只有<code>close</code>事件的<code>event</code>对象上有额外信息。这个对象上有 3 个额外属性：<code>wasClean</code>、<code>code</code>和<code>reason</code>。其中，<code>wasClean</code>是一个布尔值，表示连接是否干净地关闭；<code>code</code>是一个来自服务器的数值状态码；<code>reason</code>是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">socket.onclose = function (event) {
  console.log(
    `as clean? ${event.wasClean} Code=${event.code} Reason=${event.reason}`
  )
}</code>
        </deckgo-highlight-code><h1>安全</h1><p>探讨 Ajax 安全的文章已经有了很多了，事实上也出版了很多专门讨论这个话题的书。大规模 Ajax 应用程序需要考虑的安全问题非常多，但在通用层面上一般需要考虑以下几个问题。</p><p>首先，任何 Ajax 可以访问的 URL，也可以通过浏览器或服务器访问，例如下面这个 URL：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">/getuserinfo.php?id=23</code>
        </deckgo-highlight-code><p>请求这个 URL，可以假定返回 ID 为 23 的用户信息。访问者可以将 23 改为其他任何值。getuserinfo.php 文件必须知道访问者是否拥有访问相应数据的权限。否则服务器就会大门敞开，泄露所有用户的信息。</p><p>在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（CSRF，cross-site request forgery）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax 应用程序，无论大小，都会受到 CSRF 攻击的影响，包括无害的漏洞验证工具和恶意的数据盗窃或数据破坏攻击。</p><p>关于安全防护 Ajax 相关 URL 的一般理论认为，需要验证请求发送者拥有对资源的访问权限。可以通过如下方式实现：</p><ul><li>要求通过 SSL 访问能够被 Ajax 访问的资源。</li><li>要求每个请求都发送一个按约定算法计算好的令牌（token）。</li></ul><p>注意，以下手段对防护 CSRF 攻击是无效的：</p><ul><li>要求 POST 而非 GET 请求（很容易修改请求方法）。</li><li>使用来源 URL 验证来源（来源 URL 很容易伪造）。</li><li>基于 cookie 验证（同样很容易伪造）。</li></ul><h1>小结</h1><p>Ajax 是无需刷新当前页面即可从服务器获取数据的一个方法，具有以下特点：</p><ul><li>让 Ajax 迅速流行的中心对象是<code>XMLHttpRequest</code>（XHR）。</li><li>这个对象最早由微软发明，并在 IE5 中作为通过 JavaScript 从服务器获取 XML 数据的一种手段。</li><li>之后，Firefox、Safari、Chrome 和 Opera 都复刻了相同的实现。W3C 随后将 XHR 行为写入 Web 标准。</li><li>虽然不同浏览器的实现有些差异，但 XHR 对象的基本使用在所有浏览器中相对是规范的，因此可放心地在 Web 应用程序中使用。</li></ul><p>XHR 的一个主要限制是同源策略，即通信只能在相同域名、相同端口和相同协议的前提下完成。访问超出这些限制之外的资源会导致安全错误，除非使用了正式的跨域方案。这个方案叫做跨源资源共享（CORS，Cross-Origin Resource Sharing），XHR 对象原生支持 CORS。图片探测和 JSONP 是另外两种跨域通信技术，但没有 CORS 可靠。</p><p>Fetch API 是作为对 XHR 对象的一种端到端的替代方案而提出的。这个 API 提供了优秀的基于期约的结构、更直观的接口，以及对 Stream API 的最好支持。</p><p>Web Socket 是与服务器的全双工、双向通信渠道。这与其他方案不同，Web Socket 不使用 HTTP，而使用了自定义协议，目的是更快地发送小数据块。这需要专用的服务器，但速度优势明显。</p></div><div class="navigator-switch" style="display:none"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="list" class="svg-inline--fa fa-list " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M88 48C101.3 48 112 58.75 112 72V120C112 133.3 101.3 144 88 144H40C26.75 144 16 133.3 16 120V72C16 58.75 26.75 48 40 48H88zM480 64C497.7 64 512 78.33 512 96C512 113.7 497.7 128 480 128H192C174.3 128 160 113.7 160 96C160 78.33 174.3 64 192 64H480zM480 224C497.7 224 512 238.3 512 256C512 273.7 497.7 288 480 288H192C174.3 288 160 273.7 160 256C160 238.3 174.3 224 192 224H480zM480 384C497.7 384 512 398.3 512 416C512 433.7 497.7 448 480 448H192C174.3 448 160 433.7 160 416C160 398.3 174.3 384 192 384H480zM16 232C16 218.7 26.75 208 40 208H88C101.3 208 112 218.7 112 232V280C112 293.3 101.3 304 88 304H40C26.75 304 16 293.3 16 280V232zM88 368C101.3 368 112 378.7 112 392V440C112 453.3 101.3 464 88 464H40C26.75 464 16 453.3 16 440V392C16 378.7 26.75 368 40 368H88z"></path></svg></div><div class="article-navigator" style="display:block"><div class="article-navigator-toggler"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="xmark" class="svg-inline--fa fa-xmark " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"></path></svg></div><h4>electron</h4><p title="electron中的进程模型" class="">electron中的进程模型</p><h4>前端杂谈</h4><p title="跨源资源共享（CORS）" class="">跨源资源共享（CORS）</p><p title="V8引擎中的对象属性访问" class="">V8引擎中的对象属性访问</p><p title="关于no-cors的误区" class="">关于no-cors的误区</p><p title="地图工具中的线条吸附——一个简单方案" class="">地图工具中的线条吸附——一个简单方案</p><p title="渲染页面：浏览器的工作原理" class="">渲染页面：浏览器的工作原理</p><p title="React diffing算法" class="">React diffing算法</p><p title="Vercel简介 静态博客部署" class="">Vercel简介 静态博客部署</p><h4>JavaScript数据结构和算法</h4><p title="（八）字典和散列表" class="">（八）字典和散列表</p><p title="（十）树" class="">（十）树</p><h4>JavaScript高级程序设计</h4><p title="（一）什么是JavaScript？" class="">（一）什么是JavaScript？</p><p title="（二）HTML中的JavaScript" class="">（二）HTML中的JavaScript</p><p title="（三）JavaScript语言基础" class="">（三）JavaScript语言基础</p><p title="（四）变量、作用域与内存" class="">（四）变量、作用域与内存</p><p title="（五）基本引用类型" class="">（五）基本引用类型</p><p title="（六）集合引用类型" class="">（六）集合引用类型</p><p title="（七）迭代器与生成器" class="">（七）迭代器与生成器</p><p title="（十一）期约与异步函数" class="">（十一）期约与异步函数</p><p title="（十四）DOM" class="">（十四）DOM</p><p title="（十五）DOM扩展" class="">（十五）DOM扩展</p><p title="（十七）事件" class="">（十七）事件</p><p title="（二十）JavaScript API" class="">（二十）JavaScript API</p><p title="（二十三）JSON" class="">（二十三）JSON</p><p title="（二十四）网络请求与远程资源" class="highlighted-navigator-item">（二十四）网络请求与远程资源</p><p title="（二十五）客户端存储" class="">（二十五）客户端存储</p><p title="（二十六）模块" class="">（二十六）模块</p></div>0</main><footer class="footer"><div class="wrapper"><p style="font-size:1.3rem"><span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="weixin" class="svg-inline--fa fa-weixin " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M385.2 167.6c6.4 0 12.6 .3 18.8 1.1C387.4 90.3 303.3 32 207.7 32 100.5 32 13 104.8 13 197.4c0 53.4 29.3 97.5 77.9 131.6l-19.3 58.6 68-34.1c24.4 4.8 43.8 9.7 68.2 9.7 6.2 0 12.1-.3 18.3-.8-4-12.9-6.2-26.6-6.2-40.8-.1-84.9 72.9-154 165.3-154zm-104.5-52.9c14.5 0 24.2 9.7 24.2 24.4 0 14.5-9.7 24.2-24.2 24.2-14.8 0-29.3-9.7-29.3-24.2 .1-14.7 14.6-24.4 29.3-24.4zm-136.4 48.6c-14.5 0-29.3-9.7-29.3-24.2 0-14.8 14.8-24.4 29.3-24.4 14.8 0 24.4 9.7 24.4 24.4 0 14.6-9.6 24.2-24.4 24.2zM563 319.4c0-77.9-77.9-141.3-165.4-141.3-92.7 0-165.4 63.4-165.4 141.3S305 460.7 397.6 460.7c19.3 0 38.9-5.1 58.6-9.9l53.4 29.3-14.8-48.6C534 402.1 563 363.2 563 319.4zm-219.1-24.5c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.8 0 24.4 9.7 24.4 19.3 0 10-9.7 19.6-24.4 19.6zm107.1 0c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.5 0 24.4 9.7 24.4 19.3 .1 10-9.9 19.6-24.4 19.6z"></path></svg></span><span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="qq" class="svg-inline--fa fa-qq " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433.8 420.4c-11.53 1.393-44.86-52.74-44.86-52.74 0 31.34-16.14 72.25-51.05 101.8 16.84 5.192 54.84 19.17 45.8 34.42-7.316 12.34-125.5 7.881-159.6 4.037-34.12 3.844-152.3 8.306-159.6-4.037-9.045-15.25 28.92-29.21 45.78-34.42-34.92-29.54-51.06-70.44-51.06-101.8 0 0-33.33 54.13-44.86 52.74-5.37-.65-12.42-29.64 9.347-99.7 10.26-33.02 21.1-60.48 40.14-105.8C60.68 98.06 108.1 .006 224 0c113.7 .006 163.2 96.13 160.3 214.1 18.12 45.22 29.91 72.85 40.14 105.8 21.77 70.06 14.72 99.05 9.346 99.7z"></path></svg></span><span><a href="mailto:k1664032884@gmail.com"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="envelope" class="svg-inline--fa fa-envelope " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 352c-16.53 0-33.06-5.422-47.16-16.41L0 173.2V400C0 426.5 21.49 448 48 448h416c26.51 0 48-21.49 48-48V173.2l-208.8 162.5C289.1 346.6 272.5 352 256 352zM16.29 145.3l212.2 165.1c16.19 12.6 38.87 12.6 55.06 0l212.2-165.1C505.1 137.3 512 125 512 112C512 85.49 490.5 64 464 64h-416C21.49 64 0 85.49 0 112C0 125 6.01 137.3 16.29 145.3z"></path></svg></a></span><span><a href="https://github.com/kqhasaki" target="_blank" rel="noreferrer"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></span><span><a href="/static/resume-08fc1b875e1170d51d0db05970b525a7.pdf" download="resume.pdf" title="简历下载"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="file" class="svg-inline--fa fa-file " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M256 0v128h128L256 0zM224 128L224 0H48C21.49 0 0 21.49 0 48v416C0 490.5 21.49 512 48 512h288c26.51 0 48-21.49 48-48V160h-127.1C238.3 160 224 145.7 224 128z"></path></svg></a></span><span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"></path></svg></span></p><p>CopyRight © 2022 Louis K</p></div><div class="wrapper" style="align-items:flex-end"><h3>Links</h3><ul><li><span><a href="https://reactjs.org/" rel="noreferrer" target="_blank">React</a></span></li><li><span><a href="https://developer.mozilla.org/zh-CN/" rel="noreferrer" target="_blank">MDN</a></span></li><li><span><a href="https://leafletjs.com/reference.html" rel="noreferrer" target="_blank">Leaflet</a></span></li><li><span><a href="https://ant.design/index-cn" rel="noreferrer" target="_blank">Ant Design</a></span></li><li><span><a href="https://webpack.docschina.org/concepts/" rel="noreferrer" target="_blank">webpack</a></span></li></ul></div></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/redbook-series/redbook-chapter24/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a6a9e8476add1045c345.js"],"app":["/app-2669451f6c27cf91d5d9.js"],"component---src-pages-404-js":["/component---src-pages-404-js-54d2912befce789e6bfb.js"],"component---src-pages-articles-mdx-slug-js":["/component---src-pages-articles-mdx-slug-js-cb30643db792e4279ec0.js"],"component---src-pages-index-js":["/component---src-pages-index-js-e908787b5c4c5bd3c929.js"],"component---src-pages-non-tech-js":["/component---src-pages-non-tech-js-65bcb85d2f534953958b.js"]};/*]]>*/</script><script src="/polyfill-a6a9e8476add1045c345.js" nomodule=""></script><script src="/component---src-pages-articles-mdx-slug-js-cb30643db792e4279ec0.js" async=""></script><script src="/commons-621e910004da52b2e8e5.js" async=""></script><script src="/a9a7754c-992c6b2080a7db331a45.js" async=""></script><script src="/cb1608f2-001f1ae553ac1c271243.js" async=""></script><script src="/app-2669451f6c27cf91d5d9.js" async=""></script><script src="/framework-f27b074ecebec0f1dbc4.js" async=""></script><script src="/webpack-runtime-616a2703339e1825be33.js" async=""></script></body></html>