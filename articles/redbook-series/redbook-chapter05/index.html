<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><script>
            const cachedTheme = localStorage.getItem('theme');
            if (cachedTheme) {
              document.documentElement.dataset.theme = cachedTheme;
            } else {
              const preferredTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
              document.documentElement.dataset.theme = preferredTheme;
            }

            const isMacOS = navigator.platform === 'MacIntel'
            if (!isMacOS) {
              document.documentElement.dataset.usrfont = 'non-mac';
            }
            </script><style data-href="/styles.a02f8e879a51b9c6a46e.css" data-identity="gatsby-global-css">.modal-wrapper{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background:rgba(0,0,0,.6);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:999}.modal-content-wrapper::-webkit-scrollbar{width:0}.modal-content{background:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:1rem;max-width:1080px;min-width:600px;padding:1.5rem;position:relative;width:50vw}.modal-content-wrapper{max-height:70vh;min-height:50vh;overflow-y:auto;width:100%}.modal-closer{cursor:pointer;font-size:1.2rem;position:absolute;right:.8rem;top:.8rem}.modal-closer:hover{color:var(--blue)}@media (max-width:900px){.modal-content{min-width:90%;width:90%}}.post-card-img{background-color:var(--background-color);border-radius:12px;bottom:0;box-shadow:0 0 6px rgba(0,0,0,.15);height:200px;left:50%;-o-object-fit:cover;object-fit:cover;position:absolute;-webkit-transform:translate(-50%) rotate(-8deg);transform:translate(-50%) rotate(-8deg);transition:.2s;width:300px}.img-line{height:120px;margin-bottom:2rem;position:relative}.post-card{align-items:center;border:1px solid var(--card-background-border-color);border-radius:1.5rem;cursor:pointer;display:flex;flex-direction:column;justify-content:center;margin:140px auto 0;max-width:50rem;padding:1.5rem 2rem;position:relative;transition:.2s}.post-card:hover{box-shadow:0 0 1rem var(--card-box-shadow)}.post-card:active{box-shadow:0 0 1.5rem var(--blue)}.post-card:hover .post-card-img{-webkit-transform:translate(-50%) rotate(0deg);transform:translate(-50%) rotate(0deg)}.post-card h2:after{background:var(--blue);content:"";display:block;height:2px;margin-left:auto;margin-right:auto;margin-top:10px;width:60px}.post-card-meta{background-color:var(--card-background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;font-size:.9rem;font-weight:300;margin:1rem 0 0;padding:5px 10px}@media (max-width:750px){.post-card{border-left:none;border-radius:0;border-right:none;padding:1.5rem .8rem}}.article-navigator{background-color:var(--background-color);border-right:1px solid var(--card-background-border-color);height:100vh;overflow-y:auto;padding:2.5rem 1.2rem 2.5rem 2rem;position:-webkit-sticky;position:sticky;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}.article-navigator::-webkit-scrollbar{width:0}.article-navigator-visible{-webkit-transform:translateX(0)!important;transform:translateX(0)!important}@media (max-width:1100px){.article-navigator{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;box-shadow:0 0 8px rgba(0,0,0,.1);height:100%;left:0;left:auto!important;max-width:400px;padding:0;position:fixed;-webkit-transform:translateX(-100%);transform:translateX(-100%);transition:.3s;width:calc(100% - 80px);z-index:10}.article-navigator h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.article-navigator p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;padding-left:2rem!important;padding-right:2rem!important;transition:background .3s}.article-navigator p:hover{background:var(--navigator-hover-color)}.article-navigator-switch{visibility:visible!important}}.article-navigator h4{font-size:15px;margin-bottom:.5rem;margin-top:1rem}.article-navigator h4:first-child{margin-top:0}.article-navigator-switch{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;font-size:.8rem;height:30px;left:.5rem;line-height:29px;position:fixed;text-align:center;top:4.5rem;visibility:hidden;width:30px;z-index:9}.article-navigator p{cursor:pointer;font-size:14px;margin:0;overflow-x:hidden;padding-left:.5rem;text-overflow:ellipsis;white-space:nowrap;width:100%}.article-navigator p:hover,.highlighted-navigator-item{color:var(--blue)}.item-list{align-items:center;border-left:3px solid var(--blue);display:flex;flex-direction:column;justify-content:center;margin:0 auto 0 1rem}.item-list .item{margin:0;padding:1rem;position:relative;width:100%}.item:before{background-color:var(--blue);border-radius:50%;content:"";height:.8rem;left:-.5rem;position:absolute;top:2rem;transition:.2s;width:.8rem}.item:hover:before{-webkit-transform:scale(1.2);transform:scale(1.2)}.item-list .item-label{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.item-list .item-content{padding-top:.5rem}.homepage-title{font-weight:700;margin:2rem 0 1rem}.item a{transition:.3s}.item a:hover{color:var(--font-color-highlight)}.footer{background-color:#212121;color:#efefef;font-size:15px;height:184px;justify-content:space-evenly;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}.footer,.footer .wrapper{display:flex;flex-direction:row}.footer .wrapper{align-items:center;justify-content:space-around;padding:.5rem;width:100%}.footer .wrapper div{margin:0 8px}.footer h3{font-size:1.6rem;font-weight:lighter;margin-top:8px;width:100%}.footer p{line-height:1.2rem;margin:0;padding:.5rem 0;text-align:center}.footer span{cursor:pointer;font-size:1.6rem;margin-right:12px}.wrapper li{padding:4px 0}.footer span:hover{color:var(--blue)}@media (max-width:750px){.footer .wrapper{flex-direction:column!important;margin-bottom:1rem;width:100%}.base-wrapper,.base-wrapper[name=article-wrapper]{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 0;width:100%}.base-wrapper{margin-top:64px}.not-found-background{aspect-ratio:9/20;user-select:none}}.messager{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;box-shadow:0 0 .8rem var(--card-box-shadow);left:0;margin-left:auto;margin-right:auto;max-width:200px;padding:.5rem 1rem;position:fixed;right:0;text-align:center;top:1rem;-webkit-transform:scale(.2);transform:scale(.2);transition:.2s;z-index:1000}.navbar{background-color:#212121;box-shadow:0 0 1rem rgba(0,0,0,.1);font-family:Lato,Georgia,serif;height:64px;min-width:350px;padding:12px 0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:100%}.navbar nav{align-items:center;display:flex;flex-direction:row;justify-content:space-evenly;max-width:1080px;min-width:375px;width:64%}.nav-link .img-label{font-size:15px;min-width:54px;padding-left:2px}@media (max-width:750px){.navbar{position:absolute;z-index:10}.nav-link .img-label{display:none}}.nav-link{align-items:center;color:#fff;cursor:pointer;display:flex;flex-direction:row;font-size:2.2rem;justify-content:center;margin:0 1rem;min-width:3rem;transition:.2s}.nav-link>img{border-radius:50%;display:inline-block;height:2rem}.nav-link:hover{color:var(--blue);text-decoration:none}.nav-link .link-label{display:block;font-size:16px;text-align:center;width:8rem}.link-active{color:var(--blue)}.game .question{margin:1.5rem 0}.game .question input{-webkit-appearance:none;appearance:none;background:none;border:none;border-bottom:1px solid var(--font-color);color:var(--font-color);display:inline-block;font-weight:700;max-width:120px;outline:none;padding:1px 8px}.game .question button{background:var(--card-background-color);border-radius:4px;color:var(--font-color);cursor:pointer;font-size:12px;margin-left:8px;padding:2px 6px}.game img{aspect-ratio:16/9;border-radius:8px;height:auto;margin-bottom:.5rem;margin-top:1rem;-o-object-fit:cover;object-fit:cover;overflow:hidden;padding:0;width:100%}.game img,.lamp{position:relative}.lamp{--lamp-lightness:60%;--lamp-color:hsl(0deg 0% var(--lamp-lightness));--outline-offset:var(--sp--3);--outline-color:#fff;background-color:transparent;cursor:pointer;height:45px;-webkit-transform:scale(.711);transform:scale(.711);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:45px}.lamp>*{display:block}.lamp-base{background-color:var(--lamp-color);border-radius:4px 4px 0 0;bottom:0;box-shadow:inset 0 .5px 2px rgba(0,0,0,.6);height:7px;position:absolute;right:5px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:30px}.lamp-base-down:after{height:0!important}.lamp-base:after{background-color:#fff;border-radius:1px 1px 0 0;content:"";height:6px;left:4px;position:absolute;top:-2px;-webkit-transform:translateZ(-1px);transform:translateZ(-1px);width:6px}.lamp-neck{bottom:5px;right:8px;-webkit-transform:translateZ(-1px) rotate(20deg);transform:translateZ(-1px) rotate(20deg)}.lamp-neck,.lamp-neck:after{background-color:var(--lamp-color);height:20px;position:absolute;width:4px}.lamp-neck:after{content:"";left:-8px;top:-14px;-webkit-transform:rotate(-60deg);transform:rotate(-60deg)}.lamp-head{--lamp-color-light:hsl(0deg 0% calc(var(--lamp-lightness) - 5%));background-image:linear-gradient(to bottom,var(--lamp-color-light) 5%,var(--lamp-color) 90%,var(--lamp-color-light) 5%);border-radius:100px 100px 0 0;box-shadow:0 4px 4px -2px #e6e6e6;height:10px;left:10px;position:absolute;top:4px;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:20px}.lamp-head:before{background-color:var(--lamp-color);border-radius:50%;display:block;height:6px;right:6px;top:-4px;width:6px px}.lamp-head:after,.lamp-head:before{content:"";position:absolute;-webkit-transform:translateZ(-1px);transform:translateZ(-1px)}.lamp-head:after{background:var(--lamp-head-background);-webkit-clip-path:polygon(30% 0,70% 0,100% 100%,0 100%);clip-path:polygon(30% 0,70% 0,100% 100%,0 100%);height:40px;right:0;top:10px;width:20px}.paginator{font-family:monospace;height:5rem;margin-top:4.5rem;-webkit-user-select:none;-ms-user-select:none;user-select:none}.paginator,.paginator .paginator-item{align-items:center;display:flex;justify-content:center}.paginator .paginator-item{border:1px solid var(--navigator-border-color);border-radius:20px;color:var(--navigator-border-color);cursor:pointer;flex-direction:column;height:40px;margin:0 4px;transition:.3s;width:40px}.paginator .paginator-item:hover{background-color:var(--quote-background-color);color:var(--font-color)}.paginator .paginator-item-active{color:var(--font-color)}.paginator .ellipsis{color:var(--navigator-border-color);display:flex;flex-direction:column;font-size:2rem;height:2.8rem;justify-content:center;width:2.8rem}:root{--deckgo-highlight-code-font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}html[data-theme=dark]{--blue:#02bbff;--background-color:#141414;--background-color-transparent:rgba(0,0,0,.9);--font-color:#dedede;--font-color-header:#fff;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#c678dd;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:#1c1c1c;--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030;--lamp-head-background:transparent}html[data-theme=light]{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#000;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#313131;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed;--lamp-head-background:linear-gradient(hsla(0,0%,100%,.8),hsla(0,0%,100%,.35),hsla(0,0%,100%,.05))}html{background-color:#212121;border:none}html[data-usrfont=non-mac]{font-family:STSong,sans-serif!important}body{background-color:#212121;color:var(--font-color);font-family:Lato,Georgia,serif}a{color:inherit;text-decoration:none}*{-webkit-tap-highlight-color:rgba(0,0,0,0);border:none;box-sizing:border-box;list-style-type:none;margin:0;padding:0}ol{margin:.7rem 0}ol li{list-style-type:decimal;margin:.6rem 0 .6rem 2rem}p{-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;display:block;line-height:1.8;margin-block-end:1em;margin-block-start:1em;margin-bottom:.7rem;margin-inline-end:0;margin-inline-start:0;margin-top:.7rem}::selection{background-color:var(--blue);color:#fff}body{word-wrap:break-word;font-kerning:normal;margin:0;padding:0}header{align-items:center;display:flex;flex-direction:row;justify-content:space-around;padding-bottom:0}header>.route-link{margin:0 1rem}.layout{background-color:var(--background-color);display:flex;flex-direction:row}.article-body .article-cover{aspect-ratio:16/10;border-radius:6px!important;-o-object-fit:contain;object-fit:contain;width:225px!important}.article-body p strong{font-family:sans-serif;font-weight:700}.base-wrapper{margin-left:auto;margin-right:auto;max-width:1080px;min-height:100%;min-width:350px;padding:2.625rem 1.3125rem;width:60%}.article-body .article-title{font-size:2.2rem;font-weight:700;margin-bottom:2rem;margin-top:.5rem;text-align:center}.article-body strong{color:var(--font-color-highlight)}.article-meta{font-size:.9rem;margin:1rem auto;margin-bottom:3rem!important;text-align:center}.article-meta>span{background-color:var(--card-background-color);border-radius:.5rem;font-weight:lighter;padding:.5rem 1rem}.article-body h1,h2,h3{cursor:pointer}.article-body p{font-size:16px;font-weight:400;margin-bottom:1.2rem;margin-top:1.2rem}.article-body h1{color:var(--font-color-header);font-size:2rem;font-weight:700;margin-bottom:1.8rem;margin-top:3.5rem}.article-body h1 code{font-size:2rem}.article-body h2{color:var(--font-color-header);font-size:1.6rem;font-weight:700;margin-bottom:1rem;margin-top:2.5rem}.article-body h2 code{font-size:1.5rem}.article-body h3{color:var(--font-color-header);font-size:1.3rem;font-weight:700;line-height:1.8;margin-bottom:1rem;margin-top:1.8rem}.article-body h3 code{font-size:1.2rem;font-weight:700}.article-body h4{color:var(--font-color-header);font-weight:500;margin-bottom:1rem;margin-top:1.5rem}.article-body h4 code{font-size:1rem}.article-body h1:first-child{border-radius:.5rem}.article-body h1.article-title:before{content:none!important}.article-body h1:before{margin-bottom:.5rem}.article-body h1:before,.article-body h2:before{background:var(--blue);content:"";display:block;height:2px;width:70px}.article-body h2:before{margin-bottom:.3rem}.article-body code{background-color:var(--code-background-color);border:1px solid var(--code-border-color);border-radius:4px;color:var(--code-font-color);font-family:Menlo,Monaco,Consolas,monospace;font-size:15px;margin:0 2px;padding:1px 4px}.article-body blockquote{background-color:var(--quote-background-color);border-left:2px solid var(--blue);border-radius:0 .5rem .5rem 0;color:var(--font-color-quote);margin-top:1rem;padding:1rem}.article-body blockquote code{color:var(--code-font-color)}.article-body .article-cover{border-radius:16px;box-shadow:0 0 1px rgba(0,0,0,.1);margin:18px auto 20px;width:80%}.article-body .article-cover,.article-body img{display:block;min-width:330px;-o-object-fit:cover;object-fit:cover}.article-body img{border-radius:12px;margin:18px auto;width:85%}.article-body ul{margin:.7rem 0}.article-body ul li{list-style-type:disc;margin:.6rem 0 .6rem 2rem}.article-body a{color:#189fff}a:hover{text-decoration:underline}.article-body a:after{content:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMSIgaGVpZ2h0PSIxMSIgY2xhc3M9InByZWZpeF9faWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCI+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTkyNC40MDIgMTAyMy4wNjhILjY4Vjk5LjM0NUg0NjIuNTR2OTguOTFIOTkuNTk3VjkyNC4xNWg3MjUuODk2VjU2MS4yMDdoOTguOTF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0ibTkzMC44MDUgMjIuOTc3IDY5Ljk2NiA2OS45NjYtNDUzLjQ5MyA0NTMuNDkyLTY5Ljk2NS02OS45MDF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTEwMjIuNDY0IDMwNC4wM2gtOTguOTE3Vjk5LjM0NUg3MDkuMjMxVi40MjhoMzEzLjIzM3oiLz48L3N2Zz4=);padding-left:2px}.article-body table{word-wrap:normal;border-collapse:collapse;table-layout:fixed;width:100%}th{background-color:rgba(0,0,0,.06);text-align:center}td{background-color:hsla(0,0%,100%,.01);font-weight:300}table,td,th{border:1px solid var(--table-border-color);overflow:auto;padding:.5rem}.theme-changer{border-radius:50%;bottom:1rem;cursor:pointer;position:fixed;right:1rem}.theme-changer img{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;height:30px;padding:6px;width:30px}.iframe-wrapper{aspect-ratio:16/9;border-radius:8px;height:auto;margin-bottom:.5rem;margin-top:1rem;overflow:hidden;padding:0;position:relative;width:100%}.iframe-wrapper .loader{color:#dcdcdc;font-family:sans-serif;font-size:2.5rem;left:50%;position:absolute;text-align:center;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-user-select:none;-ms-user-select:none;user-select:none}iframe{aspect-ratio:16/9;height:auto;width:100%}deckgo-highlight-code{background-color:var(--code-block-background);border-radius:.5rem;box-shadow:none!important;cursor:pointer;font-size:14px;margin-top:1rem;position:relative}.not-found-background,deckgo-highlight-code{-webkit-user-select:none;-ms-user-select:none;user-select:none}.not-found-background{aspect-ratio:16/9;width:100%}.not-found-background h1{background-color:rgba(0,0,0,.8);border-radius:8px;box-shadow:0 0 3rem rgba(0,0,0,.9);color:#ef3939;margin-top:4rem;padding:8px;text-align:center}.foot-post-navigator{align-items:center;display:flex;flex-direction:row;justify-content:space-between;margin-bottom:2rem;padding:0 1rem}.foot-post-navigator button{background:none;color:var(--font-color);cursor:pointer;display:flex;flex-direction:column;font-family:inherit!important;margin:0 4px;text-decoration:none;transition:.2s}.foot-post-navigator button.next{align-items:flex-end}.foot-post-navigator button div{margin-bottom:6px}.foot-post-navigator button span{font-size:15px;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.foot-post-navigator button.to-non-tech:hover{color:gold}.foot-post-navigator button:hover{color:var(--blue)}@media (min-width:900px){deckgo-highlight-code:after{content:"双击复制";font-size:11px;height:2rem;opacity:0;position:absolute;right:1rem;text-align:center;top:1rem;transition:.4s;width:4rem}deckgo-highlight-code:hover:after{opacity:1}}@media (max-width:1100px){.base-wrapper[name=article-wrapper]{margin-left:0;padding-left:0;padding-right:0;width:75%}.base-wrapper{width:80%}.article-body h1,.article-body h2,.article-body h3,.article-body p{padding-left:.8rem;padding-right:.8rem}.article-body li{padding-right:.8rem}.article-body li p{margin:0}.article-body img,.iframe-wrapper,blockquote,deckgo-highlight-code{border-radius:0!important}.article-body img{width:100%}}@media (max-width:750px){.base-wrapper,.base-wrapper[name=article-wrapper]{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 0;width:100%}.base-wrapper{margin-top:64px}.not-found-background{aspect-ratio:9/20;-webkit-user-select:none;-ms-user-select:none;user-select:none}}.avatar{align-items:center;display:flex;flex-direction:row;height:8rem;justify-content:center}.avatar>img{border-radius:50%;box-shadow:0 0 4px rgba(0,0,0,.1);max-height:100%;-o-object-fit:cover;object-fit:cover;-o-object-position:center center;object-position:center center;opacity:1;padding:.5rem;transition:none 0s ease 0s}.progresser{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:15px 0 0 15px;border-right:none;bottom:4rem;color:var(--font-color);cursor:pointer;font-family:Courier New,Courier,monospace;font-size:13px;font-weight:lighter;height:30px;line-height:30px;position:fixed;right:0;text-align:center;transition:.2s;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:48px;z-index:9}.progresser:after{background-color:var(--quote-background-color);border-radius:15px 0 0 15px;content:"";opacity:0;transition:.2s}.progresser:after,.progresser:hover:after{bottom:0;left:0;position:absolute;right:0;top:0}.progresser:hover:after{content:"up";opacity:1}.progresser-hide{-webkit-transform:translateX(100%);transform:translateX(100%)}.table-of-content{background-color:var(--background-color);border-left:1px solid var(--card-background-border-color);height:100vh;position:-webkit-sticky;position:sticky;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}.table-of-content-main{height:100%;overflow-y:auto;padding:2.5rem 1.2rem 3rem}.table-of-content-main::-webkit-scrollbar{width:0}.table-of-content-switch{display:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.table-of-content-visible{-webkit-transform:translateX(0)!important;transform:translateX(0)!important}@media (max-width:1100px){.table-of-content{width:25%}}@media (max-width:750px){.table-of-content{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;box-shadow:0 0 8px rgba(0,0,0,.1);height:100%;max-width:400px;padding:0;position:fixed;right:0;-webkit-transform:translateX(100%);transform:translateX(100%);transition:.3s;width:calc(100% - 80px);z-index:11}p.header-level-h1:first-child{padding-left:14px!important;-webkit-transform:translateX(0);transform:translateX(0)}.table-of-content-main{padding:2rem 0}.table-of-content h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.table-of-content p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;margin-top:0!important;padding-right:2rem!important;transition:background .3s}.table-of-content p.header-level-h1{font-weight:700;margin-top:.8rem;padding-left:2rem}.table-of-content p.header-level-h2{font-size:15px;margin-top:.4rem;padding-left:3rem}.table-of-content .header-level-h3{font-size:15px;margin-top:.2rem;padding-left:4rem}.table-of-content p:hover{background:var(--navigator-hover-color)}.table-of-content-switch{background-color:blue;background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;display:block;font-size:.8rem;height:30px;line-height:30px;position:fixed;right:.5rem;text-align:center;top:4.5rem;width:30px;z-index:8}}.table-of-content::-webkit-scrollbar{display:none}.table-of-content p{cursor:pointer;margin:0;overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.table-of-content .topHeader{color:var(--blue)!important}.table-of-content p:hover{color:var(--blue)}p.header-level-h1:first-child{border-left:2px solid var(--blue);padding-left:4px;-webkit-transform:translateX(-8px);transform:translateX(-8px)}p.header-level-h1{font-size:15px;font-weight:700;margin-top:.8rem}p.header-level-h2{font-size:14px;margin-top:.4rem;padding-left:1rem}p.header-level-h3{font-size:14px;margin-top:.2rem;padding-left:2rem}</style><meta name="generator" content="Gatsby 4.4.0"/><link rel="icon" href="/favicon-32x32.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link as="script" rel="preload" href="/webpack-runtime-ac47d41b9012053d70c4.js"/><link as="script" rel="preload" href="/framework-f27b074ecebec0f1dbc4.js"/><link as="script" rel="preload" href="/app-cb8cf455a629701e7063.js"/><link as="script" rel="preload" href="/cb1608f2-cc8649749445c1088879.js"/><link as="script" rel="preload" href="/commons-62d414c82abc9b4aa190.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-9d4b15df0cdbe7fceee1.js"/><link as="fetch" rel="preload" href="/page-data/articles/redbook-series/redbook-chapter05/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2757060725.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3605573801.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><title>Louis K - Software Engineer</title><header class="navbar"><nav><div class="nav-link"><img alt="avatar" src="/static/avatar-05f3b9b1e1ce151053fb8a66dbc70489.png"/><span class="img-label">Louis K</span></div><a class="nav-link" href="/"><span class="link-label">Tech</span></a><a class="nav-link" href="/non-tech/"><span class="link-label">Ramble</span></a><div class="nav-link"><button class="lamp" aria-pressed="true" type="button"><span class="lamp-base"></span><span class="lamp-neck"></span><span class="lamp-head"></span></button></div></nav></header><main class="layout"><div class="article-navigator-switch"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="list" class="svg-inline--fa fa-list " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M88 48C101.3 48 112 58.75 112 72V120C112 133.3 101.3 144 88 144H40C26.75 144 16 133.3 16 120V72C16 58.75 26.75 48 40 48H88zM480 64C497.7 64 512 78.33 512 96C512 113.7 497.7 128 480 128H192C174.3 128 160 113.7 160 96C160 78.33 174.3 64 192 64H480zM480 224C497.7 224 512 238.3 512 256C512 273.7 497.7 288 480 288H192C174.3 288 160 273.7 160 256C160 238.3 174.3 224 192 224H480zM480 384C497.7 384 512 398.3 512 416C512 433.7 497.7 448 480 448H192C174.3 448 160 433.7 160 416C160 398.3 174.3 384 192 384H480zM16 232C16 218.7 26.75 208 40 208H88C101.3 208 112 218.7 112 232V280C112 293.3 101.3 304 88 304H40C26.75 304 16 293.3 16 280V232zM88 368C101.3 368 112 378.7 112 392V440C112 453.3 101.3 464 88 464H40C26.75 464 16 453.3 16 440V392C16 378.7 26.75 368 40 368H88z"></path></svg></div><div class="article-navigator"><h4>electron</h4><p title="electron中的进程模型" class="">electron中的进程模型</p><h4>前端杂谈</h4><p title="“关于Unicode和字符集，你至少应该了解这些”" class="">“关于Unicode和字符集，你至少应该了解这些”</p><p title="跨源资源共享（CORS）" class="">跨源资源共享（CORS）</p><p title="利用ESLint、Prettier统一团队内代码风格" class="">利用ESLint、Prettier统一团队内代码风格</p><p title="V8引擎中的对象属性访问" class="">V8引擎中的对象属性访问</p><p title="关于no-cors的误区" class="">关于no-cors的误区</p><p title="地图工具中的线条吸附——一个简单方案" class="">地图工具中的线条吸附——一个简单方案</p><p title="渲染页面：浏览器的工作原理" class="">渲染页面：浏览器的工作原理</p><p title="React diffing算法" class="">React diffing算法</p><p title="Vercel简介 静态博客部署" class="">Vercel简介 静态博客部署</p><h4>JavaScript数据结构和算法</h4><p title="（八）字典和散列表" class="">（八）字典和散列表</p><p title="（十）树" class="">（十）树</p><p title="（十四）算法设计与技巧" class="">（十四）算法设计与技巧</p><h4>JavaScript高级程序设计</h4><p title="（一）什么是JavaScript？" class="">（一）什么是JavaScript？</p><p title="（二）HTML中的JavaScript" class="">（二）HTML中的JavaScript</p><p title="（三）JavaScript语言基础" class="">（三）JavaScript语言基础</p><p title="（四）变量、作用域与内存" class="">（四）变量、作用域与内存</p><p title="（五）基本引用类型" class="highlighted-navigator-item">（五）基本引用类型</p><p title="（六）集合引用类型" class="">（六）集合引用类型</p><p title="（七）迭代器与生成器" class="">（七）迭代器与生成器</p><p title="（十一）期约与异步函数" class="">（十一）期约与异步函数</p><p title="（十四）DOM" class="">（十四）DOM</p><p title="（十五）DOM扩展" class="">（十五）DOM扩展</p><p title="（十七）事件" class="">（十七）事件</p><p title="（二十）JavaScript API" class="">（二十）JavaScript API</p><p title="（二十三）JSON" class="">（二十三）JSON</p><p title="（二十四）网络请求与远程资源" class="">（二十四）网络请求与远程资源</p><p title="（二十五）客户端存储" class="">（二十五）客户端存储</p><p title="（二十六）模块" class="">（二十六）模块</p></div><main class="base-wrapper" name="article-wrapper"><main><div class="progresser">0<!-- -->%</div><article class="article-body" style="margin-bottom:4rem"><img alt="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nij4egf8j20p00gtq3m.jpg" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nij4egf8j20p00gtq3m.jpg" class="article-cover"/><h1 class="article-title">（五）基本引用类型</h1><p class="article-meta"><span><span role="img" aria-label="field-time" class="anticon anticon-field-time"><svg viewBox="64 64 896 896" focusable="false" data-icon="field-time" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M945 412H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h256c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM811 548H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h122c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM477.3 322.5H434c-6.2 0-11.2 5-11.2 11.2v248c0 3.6 1.7 6.9 4.6 9l148.9 108.6c5 3.6 12 2.6 15.6-2.4l25.7-35.1v-.1c3.6-5 2.5-12-2.5-15.6l-126.7-91.6V333.7c.1-6.2-5-11.2-11.1-11.2z"></path><path d="M804.8 673.9H747c-5.6 0-10.9 2.9-13.9 7.7a321 321 0 01-44.5 55.7 317.17 317.17 0 01-101.3 68.3c-39.3 16.6-81 25-124 25-43.1 0-84.8-8.4-124-25-37.9-16-72-39-101.3-68.3s-52.3-63.4-68.3-101.3c-16.6-39.2-25-80.9-25-124 0-43.1 8.4-84.7 25-124 16-37.9 39-72 68.3-101.3 29.3-29.3 63.4-52.3 101.3-68.3 39.2-16.6 81-25 124-25 43.1 0 84.8 8.4 124 25 37.9 16 72 39 101.3 68.3a321 321 0 0144.5 55.7c3 4.8 8.3 7.7 13.9 7.7h57.8c6.9 0 11.3-7.2 8.2-13.3-65.2-129.7-197.4-214-345-215.7-216.1-2.7-395.6 174.2-396 390.1C71.6 727.5 246.9 903 463.2 903c149.5 0 283.9-84.6 349.8-215.8a9.18 9.18 0 00-8.2-13.3z"></path></svg></span> <!-- -->2022-04-26<!-- --> | <span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span> <!-- -->10000<!-- -->words <!-- -->36<!-- -->min</span></p><p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称为“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p><blockquote><p>引用类型虽然有点像”类“，但跟类并不是一个概念。</p></blockquote><p>对象被认为是某个特定引用类型的<strong>实例</strong>。新对象通过使用<code>new</code>操作符后跟一个<strong>构造函数</strong>（constructor）来创建。构造函数就是用来创建新对象的函数，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const now = new Date()</code>
        </deckgo-highlight-code><p>这行代码创建了引用类型<code>Date</code>的一个新实例，并将它保存在变量<code>now</code>中。<code>Date()</code>在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像<code>Date</code>这样的原生引用类型，帮助开发者实现常见的任务。</p><h1><code>Date</code></h1><p>ECMAScript 的<code>Date</code>类型参考了 Java 早期版本中的<code>java.util.Date</code>。为此，<code>Date</code>类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过毫秒数。使用这种存储格式，<code>Date</code>类型可以精确表示 1970 年 1 月 1 日至之后 285616 年的日期。</p><p>要创建日期对象，就使用<code>new</code>操作符来调用<code>Date</code>构造函数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const now = new Date()</code>
        </deckgo-highlight-code><p>在不给<code>Date</code>构造函数传参数的情况下，创建的对象将保存当前的日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript 为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。</p><p><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。</p><blockquote><p>注意：由于浏览器兼容性问题，强烈建议不要使用<code>Date.parse()</code>和<code>Date</code>构造函数解析字符串来构造时间，见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E4%BE%8B%E5%AD%90">MDN 文档</a>。</p></blockquote><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const someData = new Date(Date.parse(&#x27;May 23, 2019&#x27;))

// 与上面的代码等价
const someDate = new Date(&#x27;May 23, 2019&#x27;)</code>
        </deckgo-highlight-code><p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code>。</p><p><code>Date.UTC()</code>方法也返回日期的毫秒表示，但是用的是跟<code>Date.parse()</code>不同的信息来生成这个值。传给<code>Date.UTC()</code>的参数是年、零起点月数（1 月是 0，2 月是 1，类推）、日（1 ～ 31）、时（0 ～ 23）、分、秒和毫秒。参数里面只有年和月是必须的。不提供日，则默认为 1 日，其他参数的默认值都是 0。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const y2k = new Date(Date.UTC(2000, 0))

const allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55))</code>
        </deckgo-highlight-code><p>ECMAScript 还提供了<code>Date.now()</code>方法，返回表示方法执行日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 起始时间
const start = Date.now()

// 调用函数
doSomething()

// 结束时间
const stop = Date.now()</code>
        </deckgo-highlight-code><h2>继承的方法</h2><p>和其他类型一样，<code>Date</code>类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。但与其他类型不同，重写后这些方法的返回值不一样。<code>Date</code>类型的<code>toLocaleString()</code>方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM 或 PM，但不包含时区信息。<code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0 ～ 23）表示的。</p><p>由于浏览器对这两个方法的返回值可能不尽相同。意味着<code>toLocaleString()</code>和<code>toString()</code>可能只对调试有用，不能用于显示。</p><p><code>Date</code>类型的<code>valueOf()</code>方法被重写后返回日期的毫秒表示。因此，操作符（例如小于号和大于号）可以直接使用它的返回值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const date1 = new Date(2019, 0, 1) // 2019年1月1日
const date2 = new Date(2019, 1, 1) // 2019年2月1日

console.log(date1 &lt; date2) // true
console.log(date1 &gt; date2) // false</code>
        </deckgo-highlight-code><p>这也是确保日期先后的一个简单方式。</p><h2>日期格式化方法</h2><p><code>Date</code>类型有几个专门用于格式化日期的方法，它们都返回字符串。</p><ul><li><code>toDateString()</code>显示日期中的星期、月、日、年。</li><li><code>toTimeString()</code>显示日期中的时、分、秒和时区。</li><li><code>toLocaleDateString()</code>显示日期中的星期、月、日、年。</li><li><code>toLocaleTimeString()</code>显示日期中的时、分、秒。</li><li><code>toUTCString()</code>显示完整的 UTC 日期。</li></ul><p>这些方法的输出与<code>toLocaleString()</code>和<code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><h2>日期/时间组件方法</h2><p><code>Date</code>类型提供了大量方法直接涉及取得或设置日期值的特定部分。见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">MDN 文档</a></p><h1><code>RegExp</code></h1><p>ECMAScript 通过<code>RegExp</code>类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const expression = /pattern/flags</code>
        </deckgo-highlight-code><p>这个正则表达式的<code>pattern</code>模式可以是任何简单或负责的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个<code>flags</code>标记，用于控制正则表达式的行为。</p><ul><li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配内容就结束。</li><li><code>i</code>：不区分大小写，表示在查找匹配时忽略<code>pattern</code>和字符串的大小写。</li><li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找。</li><li><code>y</code>：粘附模式，表示只查找从<code>lastIndex</code>开始及之后的字符串。</li><li><code>u</code>：Unicode 模式，启用 Unicode 匹配。</li><li><code>s</code>：<code>dotAll</code>模式，表示元字符<code>.</code>匹配任何字符（包括<code>\n</code>或<code>\r</code>）。</li></ul><p>使用不同模式和标记可创建各种正则表达式，例如。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const pattern1 = /at/g

const pattern2 = /[bc]at/i

// 匹配所有at结尾的三字符组合，忽略大小写
const pattern3 = /.at/gi</code>
        </deckgo-highlight-code><p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义。</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">( [ { \ ^ $ | } ] ) ? * + .</code>
        </deckgo-highlight-code><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const pattern1 = /[bc]at/i

const pattern2 = /\[bc\]at/i

const pattern3 = /.at/gi

const pattern4 = /\.at/gi</code>
        </deckgo-highlight-code><p>前面的正则表达式都是用字面量定义的。正则表达式也可以使用<code>RegExp</code>构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const pattern1 = /[bc]at/i

const pattern2 = new RegExp(&#x27;[bc]at&#x27;, &#x27;i&#x27;)</code>
        </deckgo-highlight-code><p>这里的<code>pattern1</code>和<code>pattern2</code>是等效的正则表达式。注意，<code>RegExp</code>构造函数的两个参数都是字符串。因为<code>RegExp</code>的模式参数是字符串，所以在某些情况下需要<strong>二次转义</strong>。所有元字符都必须进行二次转义，包括转义字符序列。</p><blockquote><p>二次转义显然比直接用字面量麻烦，因此最好不要这样（给构造函数传模式参数和标记参数）构造正则表达式实例。</p></blockquote><p>此外，使用<code>RegExp</code>也可以给予已有的正则表达式实例，并可选择地修改它们的标记。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const reg1 = /cat/g
console.log(reg1) // &quot;/cat/g&quot;

const reg2 = new RegExp(re1)
console.log(reg2) // &quot;/cat/g&quot;

const reg3 = new RegExp(re1, &#x27;i&#x27;)
console.log(re3) // &quot;/cat/i&quot;</code>
        </deckgo-highlight-code><h2><code>RegExp</code>实例属性</h2><p>每个<code>RegExp</code>实例都有下列属性，提供有关模式的各方面信息。</p><ul><li><code>global</code>：布尔值，表示是否设置了<code>g</code>标记。</li><li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标记。</li><li><code>unicode</code>：布尔值，表示是否设置了<code>u</code>标记。</li><li><code>sticky</code>：布尔值，表示是否设置了<code>y</code>标记。</li><li><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li><li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标记。</li><li><code>dotAll</code>：布尔值，表示是否设置了<code>s</code>标记。</li><li><code>source</code>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li><li><code>falgs</code>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。</li></ul><p>通过这些属性可以全面了解正则表达式的信息，但是实际开发中用得不多，因为模式声明中包含了这些信息。</p><h2><code>RegExp</code>实例方法</h2><p><code>RegExp</code>实例的主要方法是<code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没有找到匹配项，则返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>是字符串中匹配模式的起始位置，<code>input</code>是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;mom and dad and baby&#x27;
const pattern = /mom( and dad( and baby)?)?/gi

const matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches.input) // &quot;mom and dad and baby&quot;
console.log(matches[0]) // &quot;mom and dad and baby&quot;
console.log(matches[1]) // &quot; and dad and baby&quot;
console.log(matches[2]) // &quot; and baby&quot;</code>
        </deckgo-highlight-code><p>如果模式设置了全局标记，则每次调用<code>exec()</code>方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次<code>exec()</code>，也只会返回第一个匹配的信息。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;cat, bat, sat, fat&#x27;
const pattern = /.at/

const matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 0

matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 0</code>
        </deckgo-highlight-code><p>上面例子中的模式没有设置全局标记，因此调用<code>exec()</code>只返回第一个匹配项<code>&quot;cat&quot;</code>。<code>lastIndex</code>在非全局模式下始终不变。</p><p>如果在这个模式上设置了<code>g</code>标记，则每次调用<code>exec()</code>都会在字符串中向前搜索下一个匹配项。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;cat, bat, sat, fat&#x27;
const pattern = /.at/g
let matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 3

matches = pattern.exec(text)
console.log(matches.index) // 5
console.log(matches[0]) // bat
console.log(pattern.lastIndex) // 8

matches = pattern.exec(text)
console.log(matches.index) // 10
console.log(matches[0]) // sat
console.log(pattern.lastIndex) // 13</code>
        </deckgo-highlight-code><p>这次模式设置了全局标记，因此每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的<code>lastIndex</code>属性每次都会变化。在全局匹配模式下，每次调用<code>exec()</code>都会更新<code>lastIndex</code>值，以反映上次匹配的最后一个字符的索引。</p><p>如果模式设置了粘附标记<code>y</code>，则每次调用<code>exec()</code>就只会在<code>lastIndex</code>的位置上寻找匹配项。粘附标记覆盖全局标记。</p><p>正则表达式的另一个方法是<code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。<code>test()</code>经常用在<code>if</code>语句中。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;000-00-0000&#x27;
const pattern = /\d{3}-\d{2}-d{4}/

if (pattern.test(text)) {
  console.log(&#x27;The pattern was matched.&#x27;)
}</code>
        </deckgo-highlight-code><p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p><p>无论正则表达式是怎么创建的，继承的方法<code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const pattern = new RegExp(&#x27;\\[bc\\]at&#x27;, &#x27;gi&#x27;)
console.log(pattern.toString()) // /\[bc\]at/gi
console.log(pattern.toLocaleString()) // /\[bc\]at/gi</code>
        </deckgo-highlight-code><p>这里的模式是通过<code>RegExp</code>构造函数创建的，但<code>toLocaleString()</code>和<code>toString()</code>返回的都是其字面量的形式。</p><blockquote><p>正则表达式的<code>valueOf()</code>方法返回正则表达式本身。</p></blockquote><h2><code>RegExp</code>构造函数的属性</h2><p><code>RegExp</code>构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。</p><blockquote><p>注意，<code>RegExp</code>构造函数的所有属性都没有任何 Web 标准出处，因此不要在代码中使用它们。</p></blockquote><h2>模式局限</h2><p>虽然 ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少 Perl 语言中的一些高级特性。例如<code>\A</code>和<code>\Z</code>锚、联合及交叉类、原子组、<code>x</code>（忽略空格）匹配模式、条件式匹配、正则表达式注释等。虽然还有这些局限，但 ECMAScript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。</p><h1>原始包装值类型</h1><p>为了方便操作原始值，ECMAScript 提供了三种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s1 = &#x27;some text&#x27;
const s2 = s1.substring(2)</code>
        </deckgo-highlight-code><p>在这里，<code>s1</code>是一个包含字符串的变量，它是一个原始值。第二行紧接着在<code>s1</code>上调用了<code>substring()</code>方法，并把结果保存在<code>s2</code>中。我们知道，原始值本身不是对象，因此在逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问<code>s1</code>时，是以读模式访问的，也就是要从内存中读取保存变量的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：</p><ol><li>创建一个<code>String</code>类型的实例</li><li>调用实例上的特定方法</li><li>销毁实例</li></ol><p>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s1 = new String(&#x27;Some text&#x27;)
const s2 = s1.substring(2)
s1 = null</code>
        </deckgo-highlight-code><p>这种行为可以让原始值拥有对象行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过使用的是<code>Boolean</code>和<code>Number</code>包装类型而已。</p><p>引用类型与原始包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s1 = &#x27;some text&#x27;
s1.color = &#x27;red&#x27;
console.log(s1.color) // undefined</code>
        </deckgo-highlight-code><p>这里的第二行代码尝试给字符串<code>s1</code>添加了一个<code>color</code>属性。可是，第三行代码访问<code>color</code>属性时，它却不见了。原因是第二行代码运行时会临时创建一个<code>String</code>对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的<code>String</code>对象，但这个对象没有<code>color</code>属性。</p><p>可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者迷惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用<code>typeof</code>会返回<code>&quot;object&quot;</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。</p><p>另外，<code>Object</code>构造函数作为一个工厂方法，能够根据传入的类型返回相应原始值包装类型的实例，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const obj = new Object(&#x27;some text&#x27;)
console.log(obj instanceof String) // true</code>
        </deckgo-highlight-code><p>如果传给<code>Object</code>的是字符串，则会返回一个<code>String</code>的实例。如果是数值，则会创建<code>Number</code>的实例。布尔值则会得到<code>Boolean</code>的实例。</p><p>注意，使用<code>new</code>调用原始包装类型的构造函数，与调用同名的转型函数并不一样。例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let value = &#x27;25&#x27;
let number = Number(value) // 转型函数
console.log(typeof number) // &quot;number&quot;
let obj = new Number(value) // 构造函数
console.log(obj) // &quot;object&quot;</code>
        </deckgo-highlight-code><p>在这个例子中，变量<code>number</code>中保存的是一个值为 25 的原始数值，而变量<code>obj</code>中保存的是一个<code>Number</code>实例。</p><p>虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。</p><h2><code>Boolean</code></h2><p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code>，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const booleanObject = new Boolean(true)</code>
        </deckgo-highlight-code><p><code>Boolean</code>的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。不过，<code>Boolean</code>对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会。因为<code>new Boolean(false)</code>实际上转化为布尔值后是一个<code>true</code>值。<code>typeof</code>操作符对原始值返回<code>boolean</code>，但对引用值返回<code>&quot;object&quot;</code>。</p><p>理解原始布尔值和<code>Boolean</code>对象之间的区别非常重要，强烈建议永远不要使用<code>Boolean</code>对象。</p><h2><code>Number</code></h2><p><code>Number</code>是对应数值的引用类型。要创建一个<code>Number</code>对象，就使用<code>Number</code>构造函数并传入一个数值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const numberObject = new Number(10)</code>
        </deckgo-highlight-code><p>与<code>Boolean</code>类型一样，<code>Number</code>类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法。<code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = 10
console.log(num.toString()) // &quot;10&quot;
console.log(num.toString(2)) // &quot;1010&quot;
console.log(num.toString(8)) // &quot;12&quot;
console.log(num.toString(10)) // &quot;10&quot;
console.log(num.toString(16)) // &quot;a&quot;</code>
        </deckgo-highlight-code><p>除了继承的方法，<code>Number</code>类型还提供了几个用于将数值格式化为字符串的方法。</p><p><code>toFixed()</code>方法返回包含执行小数点位数的数值字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = 10
console.log(num.toFixed(2)) // &quot;10.00&quot;</code>
        </deckgo-highlight-code><p>这里的<code>toFixed()</code>方法接收了参数<code>2</code>，表示返回的数值字符串要包含两位小数。结果返回值为<code>10.00</code>，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = 10.005
console.log(num.toFixed(2)) // &quot;10.01&quot;</code>
        </deckgo-highlight-code><p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。</p><p>另一个用于格式化数值的方法是<code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表示的数值字符串。与<code>toFixed()</code>一样，<code>toExponential()</code>也接收一个参数，表示结果中小数的位数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = 10
console.log(num.toExponential(1)) // &quot;1.0e+1&quot;</code>
        </deckgo-highlight-code><p>这段代码的输出为<code>&quot;1.0e+1&quot;</code>。一般来说这么小的数不需要表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用<code>toPrecision()</code>。</p><p><code>toPrecision()</code>方法会根据情况返回最合理的输出结果。可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = 99
console.log(num.toPrecision(1)) // &quot;1e+2&quot;
console.log(num.toPrecision(2)) // &quot;99&quot;
console.log(num.toPrecision(3)) // &quot;99.0&quot;</code>
        </deckgo-highlight-code><p>在这个例子中，首先要用 1 位数字表示数值 99，得到<code>&quot;1e+2&quot;</code>，也就是 100。因为 99 不能只用 1 位数字来精确表示，所以这个方法就将它舍入为 100，这样就可以只用 1 位数字（及其科学记数法形式）来表示了。</p><p>与<code>Boolean</code>对象类似，<code>Number</code>对象也为数值提供了重要能力。但是考虑到两者存在同样的潜在问题，因此并不建议直接实例化<code>Number</code>对象。</p><p>ES6 新增了<code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(Number.isInteger(1)) // true
console.log(Number.isInteger(1.0)) // true
console.log(Number.isInteger(1.01)) // false</code>
        </deckgo-highlight-code><p>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code>（-2^53 + 1）到<code>Number.MAX_SAFE_INTEGER</code>（2^53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用<code>Number.isSafeInteger()</code>方法。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(Number.isSafeInteger(-1 * 2 ** 53)) // false
console.log(Number.isSafeInteger(-1 * 2 ** 53 + 1)) // true
console.log(Number.isSafeInteger(2 ** 53)) // false
console.log(Number.isSafeInteger(2 ** 53 - 1)) // true</code>
        </deckgo-highlight-code><h2><code>String</code></h2><p><code>String</code>是对应字符串的引用类型。要创建一个<code>String</code>对象，使用<code>String</code>构造函数并传入一个数值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringObject = new String(&#x27;hello world&#x27;)</code>
        </deckgo-highlight-code><p><code>String</code>对象的方法可以在所有字符串原始值上调用。3 个继承的方法<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。</p><p>每个<code>String</code>对象都有一个<code>length</code>属性，表示字符串中字符的数量。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27;Hello World&#x27;
console.log(stringValue.length) // &quot;11&quot;</code>
        </deckgo-highlight-code><p>注意，即使字符串中包含双字节字符（而不是单字节的 ASCII 字符），也仍然会按单字符来记数。</p><p><code>String</code>类型提供了很多方法来解析和操作字符串。</p><h3>JavaScript 字符</h3><p>JavaScript 字符由 16 位<strong>码元</strong>（code unit）组成。对于多数字符来说，每 16 位码元对应一个字符。换句话说，字符串中的<code>length</code>属性表示字符串包含多少 16 位码元。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;abcde&#x27;
console.log(message.length) // 5</code>
        </deckgo-highlight-code><p>此外，<code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;abcde&#x27;

console.log(message.charAt(2)) // &quot;c&quot;</code>
        </deckgo-highlight-code><p>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000 ～ U+FFFF），这两种编码实际上是一样的。</p><p>使用<code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回索引位置的码元值，索引以整数指定。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;abcde&#x27;

console.log(message.charCodeAt(2)) // 99

console.log(99 === 0x63) // true</code>
        </deckgo-highlight-code><p><code>fromCharCode()</code>方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // &quot;abcde&quot;

// Ox0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101

console.log(String.fromCharCode(97, 98, 99, 100, 101)) // &quot;abcde&quot;</code>
        </deckgo-highlight-code><p>对于 U+0000~U+FFFF 范围内的字符，<code>length</code>、<code>charAt()</code>、<code>charCodeAt()</code>和<code>fromCharCode()</code>返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16 位表示的，而这几个方法也都基于 16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。</p><p>这个对应关系在扩展到 Unicode 增补平面时就不成立了。问题很简单，即 16 位只能唯一标识 65536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为<strong>基本多语言平面</strong>（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个<strong>增补平面</strong>。这种每个字符使用两个 16 位码元的策略称为<strong>代理对</strong>。</p><p>在涉及增补平面的字符串时，前面讨论的字符串方法就会出问题。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const str = &#x27;😊&#x27;

console.log(str.length) // 2

console.log(str.charAt(0)) // �

console.log(str.charCodeAt(0)) // 55357

console.log(String.fromCodePoint(0x1f60a)) // 😊

console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de</code>
        </deckgo-highlight-code><p>这些方法仍然将 16 位码元当作一个字符，事实上索引 0 和 1 对应的码元应该被看成一个代理对，只对应一个字符。<code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元组成），并正确地将其识别为一个 Unicode 笑脸字符。</p><p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用<code>codePointAt()</code>来代替<code>charCodeAt()</code>。跟使用<code>charCodeAt()</code>时类似，<code>codePointAt()</code>接收 16 位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是 Unicode 中一个字符的完整标识。例如<code>&quot;c&quot;</code>的码点是 0x0063，而<code>&quot;😊&quot;</code>的码点是 0x1f60a。码点可能是 16 位，也可能是 32 位。而<code>codePointAt()</code>方法可以从指定码元位置识别完整的码点。</p><p>注意如果传入的码元并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符串的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log([...&#x27;ab😊de&#x27;]) // [&quot;a&quot;, &quot;b&quot;, &quot;😊&quot;, &quot;d&quot;, &quot;e&quot;]</code>
        </deckgo-highlight-code><p>与<code>charCodeAt()</code>有对应的<code>codePointAt()</code>一样，<code>fromCharCode()</code>也有一个对应的<code>fromCodePoint()</code>。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab😊de
console.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab😊de</code>
        </deckgo-highlight-code><h3><code>normalize()</code>方法</h3><p>某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示。为了解决这个问题，Unicode 提供了 4 种规范化形式，可以将类似上面的字符串规范化为一致的格式，无论底层字符的代码是什么。可以使用<code>normalize()</code>方法对字符串应用规范化形式，使用时需要传入表示哪种形式的字符串：<code>&quot;NFD&quot;</code>、<code>&quot;NFC&quot;</code>、<code>&quot;NFKD&quot;</code>或<code>&quot;NFKC&quot;</code>。</p><h3>字符串操作方法</h3><p><code>concat()</code>用于将一个或多个字符串拼接为一个新字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let stringValue = &#x27;hello&#x27;
let result = stringValue.concat(&#x27;world&#x27;)

console.log(result) // &#x27;hello world&#x27;
console.log(stringValue) // &#x27;hello&#x27;</code>
        </deckgo-highlight-code><p>在这个例子中，对<code>stringValue</code>调用<code>concat()</code>方法的结果是得到<code>&quot;hello world&quot;</code>，但<code>stringValue</code>的值保持不变。<code>concat()</code>方法可以接收任意多个参数，因此可以一次性拼接多个字符串，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let stringValue = &#x27;hello&#x27;
let result = stringValue.concat(&#x27;world&#x27;, &#x27;!&#x27;)

console.log(result) // &#x27;hello world&#x27;
console.log(stringValue) // &#x27;hello&#x27;</code>
        </deckgo-highlight-code><p>虽然<code>concat()</code>方法可以拼接字符串，但更常用的方式是使用加号操作符<code>+</code>。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。</p><p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：<code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这 3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一个或两个参数。第一个参数表示字符串开始的位置，第二个参数表示字符串结束的位置。对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对<code>substr()</code>而言，第二个参数表示返回的子字符串中字符数量。</p><blockquote><p>注意，尽管<code>String.prototype.substr(...)</code>没有被严格废弃，但是它被认为是遗留的函数应该避免使用。并非 JavaScript 核心语言的一部分，未来可能被移除掉。如果可以的话，应该使用<code>substring()</code>替代它。</p></blockquote><p>常用的是<code>substring()</code>和<code>slice()</code>。</p><p><code>substring(indexStart, indexEnd)</code>提取从<code>indexStart</code>到<code>indexEnd</code>（不包括）之间的字符。特别的：</p><ul><li>如果<code>indexStart</code>等于<code>indexEnd</code>，返回一个空字符串。</li><li>如果省略<code>indexEnd</code>，提取字符一直到字符串末尾。</li><li>如果任一参数小于 0 或为<code>NaN</code>，则被当作 0。</li><li>如果任一参数大于<code>string.length</code>，则被当作<code>string.length</code>。</li><li>如果<code>indexStart</code>大于<code>indexEnd</code>，则<code>substring</code>的执行效果就像两个参数调换了一样。</li></ul><p><code>slice(beginIndex, endIndex)</code>提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。</p><ul><li><code>beginIndex</code>，从改索引开始提取原字符串中的字符。如果值为负数，那么会被当作<code>strLength + beginIndex</code>看待，这里的<code>strLength</code>是字符串的长度。</li><li><code>endIndex</code>，在该索引处结束提取字符串。如果参数为负数，则被看作是<code>strLength + endIndex</code>。</li></ul><h3>字符串位置方法</h3><p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到则返回<code>-1</code>）。这两者的区别在于，<code>indexOf()</code>方法从字符串开头开始查找字符串，而<code>lastIndexOf()</code>方法从字符串末尾开始查找字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let stringValue = &#x27;hello world&#x27;
console.log(stringValue.indexOf(&#x27;o&#x27;)) // 4
console.log(stringValue.lastIndexOf(&#x27;o&#x27;)) // 7</code>
        </deckgo-highlight-code><p>这两个方法都接收可选的第二个参数，表示开始搜索的位置。这意味着，<code>indexOf()</code>会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let stringValue = &#x27;hello world&#x27;
console.log(stringValue.indexOf(&#x27;o&#x27;, 6)) // 7
console.log(stringValue.lastIndexOf(&#x27;o&#x27;, 6)) // 4</code>
        </deckgo-highlight-code><h3>字符串包含方法</h3><p>ES6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：<code>startWith()</code>、<code>endsWith()</code>和<code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，<code>startsWith()</code>检查开始于索引 0 的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串。</p><p><code>startsWith()</code>和<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。</p><p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样。</p><h3><code>trim()</code>方法</h3><p>ECMAScript 在所有字符串上都提供了<code>trim()</code>方法。这个方法会创建字符串的一个副本，删除前后所有空格符，再返回结果。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27; hello world &#x27;
const trimmedStringValue = stringValue.trim()
console.log(stringValue) // &#x27; hello world &#x27;
console.log(trimmedStringValue) // &#x27;hello world&#x27;</code>
        </deckgo-highlight-code><p>另外，<code>trimLeft()</code>和<code>trimRight()</code>方法分别用于从字符串开始和末尾清理空格符。</p><h3><code>repeat()</code>方法</h3><p>ECMAScript 在所有字符串上都提供了<code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本的结果。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27;na &#x27;
console.log(stringValue.repeat(16) + &#x27;batman&#x27;)
// na na na na na na na na na na na na na na na na batman</code>
        </deckgo-highlight-code><h3><code>padStart()</code>和<code>padEnd()</code>方法</h3><p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27;foo&#x27;

console.log(stringValue.padStart(6)) // &#x27;   foo&#x27;
console.log(stringValue.padStart(9, &#x27;.&#x27;)) // &quot;......foo&quot;
console.log(stringValue.padEnd(6)) // &quot;foo   &quot;
console.log(stringValue.padEnd(9, &#x27;.&#x27;)) // &quot;foo......&quot;</code>
        </deckgo-highlight-code><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27;foo&#x27;

console.log(stringValue.padStart(8, &#x27;bar&#x27;)) // &quot;barbafoo&quot;
console.log(stringValue.padStart(2)) // &quot;foo&quot;
console.log(stringValue.padEnd(8, &#x27;bar&#x27;)) // &quot;foobarba&quot;
console.log(stringValue.padEnd(2)) // &quot;foo&quot;</code>
        </deckgo-highlight-code><h3>字符串迭代与解构</h3><p>字符串的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message = &#x27;abc&#x27;
let stringIterator = message[Symbol.iterator]()

console.log(stringIterator.next()) // { value: &#x27;a&#x27;, done: false }
console.log(stringIterator.next()) // { value: &#x27;b&#x27;, done: false }
console.log(stringIterator.next()) // { value: &#x27;c&#x27;, done: false }
console.log(strintIterator.next()) // { value: undefined, done: true }</code>
        </deckgo-highlight-code><p>在<code>for-of</code>循环中可以通过这个迭代器按序访问每个字符。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (const c of &#x27;abcde&#x27;) [console.log(c)]

// a
// b
// c
// d
// e</code>
        </deckgo-highlight-code><p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;abcde&#x27;

console.log([...message]) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</code>
        </deckgo-highlight-code><h3>字符串大小写转换</h3><p>下一组方法涉及大小写转换，包括 4 个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLowerCase()</code>和<code>toUpperCase()</code>方法是原来就有的方法，与<code>java.lang.String</code>中的方法同名。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中，Unicode 的大小写转换需要应用特殊规则，需要使用地区特定的方法才能实现正确转换。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const stringValue = &#x27;hello world&#x27;
console.log(stringValue.toLocaleUpperCase()) // &quot;HELLO WORLD&quot;
console.log(stringValue.toUpperCase()) // &quot;HELLO WORLD&quot;
console.log(stringValue.toLocaleLowerCase()) // &quot;hello world&quot;
console.log(stringValue.toLowerCase()) // &quot;hello world&quot;</code>
        </deckgo-highlight-code><p>通常，如果不知道代码涉及什么语言，则会好使用地区特定的转换方法。</p><h3>字符串模式匹配方法</h3><p><code>String</code>类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是<code>match()</code>方法，这个方法本质上跟<code>RegExp</code>对象的<code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;cat, bat, sat, fat&#x27;
const pattern = /.at/

// 等价于pattern.exec(text)
const matches = text.match(pattern)
console.log(matches.index) // 0
console.log(matches[0]) // &#x27;cat&#x27;
console.log(pattern.lastIndex) // 0</code>
        </deckgo-highlight-code><p><code>match()</code>方法返回的数组与<code>RegExp</code>对象的<code>exec()</code>方法返回的数值是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串。</p><p>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code>对象。这个方法返回模式第一个匹配的位置索引，如果没有找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;cat, bat, sat, fat&#x27;
const pos = text.search(/at/)
console.log(pos) // 1</code>
        </deckgo-highlight-code><p>这里，<code>search(/at/)</code>返回<code>1</code>，即<code>&quot;at&quot;</code>的第一个字符在字符串中的位置。</p><p>为了简化字符串替换操作，ECMAScript 提供了<code>replace()</code>方法。这个方法接收两个参数，第一个参数可以是一个<code>RegExp</code>对象或一个字符串（这个字符串避讳转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个字符串。想要替换所有子字符串，第一个参数必须为正则表达式并且带全局标记。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(result) // &quot;cond, bat, sat, fat&quot; 13
let text = &#x27;cat, bat, sat, fat&#x27;
let result = text.replace(&#x27;at&#x27;, &#x27;ond&#x27;)
result = text.replace(/at/g, &#x27;ond&#x27;)
console.log(result) // &quot;cond, bond, sond, fond&quot;</code>
        </deckgo-highlight-code><p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262 中规定了下表中的值。</p><table><thead><tr><th align="center">字符序列</th><th align="center">替换文本</th></tr></thead><tbody><tr><td align="center"><code>$$</code></td><td align="center"><code>$</code></td></tr><tr><td align="center"><code>$&amp;</code></td><td align="center">匹配整个模式的字符串。与<code>RegExp.lastMatch</code>相同</td></tr><tr><td align="center"><code>$&#x27;</code></td><td align="center">匹配的子字符串之前的字符串。与<code>RegExp.rightContext</code>相同</td></tr><tr><td align="center"><code>$` </code></td><td align="center">匹配的字符串之后的字符串。与<code>RegExp.leftContext</code>相同</td></tr><tr><td align="center"><code>$n</code></td><td align="center">匹配第<code>n</code>个捕获组的字符串，其中<code>n</code>是 0 ～ 9。例如<code>$1</code>是匹配第一个捕获组的字符串，<code>$2</code>是匹配第二个捕获组的字符串，依此类推。如果没有捕获组，则值为空字符串</td></tr><tr><td align="center"><code>$nn</code></td><td align="center">匹配第<code>nn</code>个捕获的字符串，其中<code>nn</code>是 01~99。例如，<code>$01</code>是匹配第一个捕获组的字符串，<code>$02</code>是匹配第二个捕获组的字符串，依此类推。如果没有捕获组，则值为空字符串。</td></tr></tbody></table><blockquote><p>这里再次说明，<code>RegExp</code>构造函数的所有属性都没有任何 Web 标准出处，因此不要使用它们。</p></blockquote><p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;cat, bat, sat, bat&#x27;
result = text.replace(/(.at)/g, &#x27;word ($1)&#x27;)
console.log(result) // word (cat), word (bat), word (sat), word (fat)</code>
        </deckgo-highlight-code><p><code>replace()</code>的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到三个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数，可以更精细地控制替换过程。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function htmlEscape(text) {
  return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) {
    switch (match) {
      case &#x27;&lt;&#x27;:
        return &#x27;&amp;lt;&#x27;
      case &#x27;&gt;&#x27;:
        return &#x27;&amp;gt&#x27;
      case &#x27;&amp;&#x27;:
        return &#x27;&amp;amp&#x27;
      case &#x27;\&#x27;:
        return &#x27;&amp;quot;&#x27;
    }
  })
}

console.log(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello World!&lt;/p&gt;&quot;))
// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</code>
        </deckgo-highlight-code><p>最后一个与模式匹配相关的字符串方法是<code>split()</code>，这个方法会根据传入的分隔符将字符串拆分成数组。还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let colorText = &#x27;red,blue,green,yellow&#x27;
let colors1 = colorText.split(&#x27;,&#x27;) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]
let colors2 = colorText.split(&#x27;,&#x27;, 2) // [&quot;red&quot;, &quot;blue&quot;]
let colors3 = colorText.split(/[^,]+/) // [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</code>
        </deckgo-highlight-code><p>最后一次<code>split()</code>时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头和末尾。</p><h3><code>localeCompare()</code>方法</h3><p>最后一个方法是<code>localeCompare()</code>，这个方法比较两个字符串，返回如下 3 个值中的一个。</p><ul><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。通常是-1，具体要看与实际值相关的实现。</li><li>如果字符串与字符串参数相等，返回 0。</li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。通常是-1，具体要看与实际值相关的实现。</li></ul><h3>HTML 方法</h3><p>早期的浏览器开发商认为使用 JavaScrip 动态生成 HTML 标签是一个需求。因此早期浏览器扩展了规范，增加了辅助生成 HTML 标签的方法。例如<code>anchor()</code>、<code>link()</code>等等，但是因为通常结果不是语义化标记，现在已经基本没有人使用了。</p><h1>单例内置对象</h1><p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象”。这意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面已经接触了大部分内置对象，包括<code>Object</code>、<code>Array</code>和<code>String</code>。本节介绍 ECMA-262 定义的另外两个单例内置对象：<code>Global</code>和<code>Math</code>。</p><h2><code>Global</code></h2><p><code>Global</code>对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定<code>Global</code>对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code>对象的属性。本书前面介绍的函数，包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和<code>parseFloat()</code>，实际上都是<code>Global</code>对象的方法。除了这些，<code>Global</code>对象上还有另外一些方法。</p><h3>URL 编码方法</h3><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，例如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。</p><p><code>encodeURI()</code>方法用于对整个 URI 进行编码，例如<code>&quot;www.wrox.com/illegal value js&quot;</code>。而<code>encodeURIComponent()</code>方法用于编码 URI 中单独的组件，例如前面 URL 中的<code>&quot;illegal value js&quot;</code>。这两个方法的主要区别是，<code>encodeURI()</code>不会编码属于 URL 组件的特殊字符，例如冒号、斜杠、问好、并号，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const url = &#x27;http://www.wrox.com/illegal value.js#start&#x27;

console.log(encodeURI(url))
// http://www.wrox.com/illegal%20value.js#start

console.log(encodeURIComponent(url))
// http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start</code>
        </deckgo-highlight-code><p>这里使用<code>encodeURI()</code>编码后，除空格被替换为<code>%20</code>之外，没有任何变化。而<code>encodeURIComponent()</code>方法将所有非字母字符都替换成了相应的编码形式。这就是使用<code>encodeURI()</code>编码整个 URI，但只使用<code>encodeURIComponent()</code>编码那些会追加到已有 URI 后面的字符串的原因。</p><blockquote><p>一般来说，使用<code>encodeURIComponent()</code>应该比使用<code>encodeURI()</code>的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p></blockquote><p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeUIRComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。例如，<code>%20</code>会被替换为空格，但<code>%23</code>不会被替换为井号（<code>#</code>），是因为井号不是由<code>encodeURI()</code>替换的。类似地，<code>decodeURIComponent()</code>解码所有被<code>encodeURIComponent()</code>编码的字符，基本上就是解码所有特殊值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const uri = &#x27;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&#x27;

console.log(decodeURI(uri))
// &#x27;http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start&#x27;

console.log(decodeURIComponent(uri))
// &#x27;http://www.wrox.com/illegal value.js#start&#x27;</code>
        </deckgo-highlight-code><blockquote><p>URI 方法<code>encodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURI()</code>和<code>decodeURIComponent()</code>取代了<code>escape()</code>和<code>unescape()</code>方法，后者在 ECMA-262 第 3 版中就已经废弃了。URI 方法始终是首选方法，因为它们对所有 Unicode 字符进行编码，而原来的方法只能正确编码 ASCII 字符。不要在生产环境使用<code>escape()</code>和<code>unescape()</code>。</p></blockquote><h3><code>eval()</code>方法</h3><p>最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是<code>eval()</code>。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">eval(&quot;console.log(&#x27;hi&#x27;)&quot;)</code>
        </deckgo-highlight-code><p>上面这行代码的功能与下一行等价：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(&#x27;hi&#x27;)</code>
        </deckgo-highlight-code><p>当解释器发现<code>eval()</code>调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过<code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let msg = &#x27;hello world&#x27;
eval(&#x27;console.log(msg)&#x27;) // &#x27;hello world&#x27;</code>
        </deckgo-highlight-code><p>这里，变量<code>msg</code>是在<code>eval()</code>调用的外部上下文中定义的，而<code>console.log()</code>显示了文本<code>&quot;hello world&quot;</code>。</p><p>类似地，可以在<code>eval()</code>内部定义一个函数函数或变量，然后在外部代码中引用。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">eval(&quot;function sayHi() { console.log(&#x27;hi&#x27;) }&quot;)
console.log(msg) // Reference Error: msg is not defined</code>
        </deckgo-highlight-code><p>通过<code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p><p>在严格模式下，在<code>eval()</code>内部创建的变量和函数无法被外部访问。</p><blockquote><p>解释代码字符串的能力非常强大，但也非常危险。在使用<code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。</p></blockquote><h3><code>Global</code>对象属性</h3><p><code>Global</code>对象有很多属性，其中一些前面已经提到过了。像<code>undefined</code>、<code>NaN</code>和<code>Infinity</code>等特殊值都是<code>Global</code>对象的属性。此外，所有原生引用类型构造函数，例如<code>Object</code>和<code>Function</code>，也都是<code>Global</code>对象的属性。</p><h3><code>window</code>对象</h3><p>虽然 ECMA-262 没有直接规定访问<code>Global</code>对象的方式，但浏览器将<code>window</code>对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code>的属性。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var color = &#x27;red&#x27;

function sayColor() {
  console.log(window.color)
}

window.sayColor() // &#x27;red&#x27;</code>
        </deckgo-highlight-code><p>这里定义了一个名为<code>color</code>的全局变量和一个名为<code>sayColor()</code>的全局函数。在<code>sayColor()</code>内部，通过<code>window.color</code>访问了<code>color</code>变量，说明全局变量变成了<code>window</code>的属性。接着，又通过<code>window</code>对象直接调用了<code>window.sayColor()</code>函数，从而输出字符串。</p><blockquote><p><code>window</code>对象在 JavaScript 中远不止实现了<code>ECMAScript</code>的<code>Global</code>对象那么简单。</p></blockquote><p>另一种获取<code>Global</code>对象的方式是使用如下的代码：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let global = (function () {
  return this
})()</code>
        </deckgo-highlight-code><p>这段代码创建一个立即调用的函数表达式，返回了<code>this</code>的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过<code>call()/apply()</code>）指定<code>this</code>值的情况下执行时，<code>this</code>值等于<code>Global</code>对象。因此，调用一个简单返回<code>this</code>的函数是在任何执行上下文中获取<code>Global</code>对象的通用方式。</p><h2><code>Math</code></h2><p>ECMAScript 提供了<code>Math</code>对象作为保存数学公式、信息和计算的地方。<code>Math</code>对象提供了一些辅助计算的属性和方法。</p><blockquote><p><code>Math</code>对象上提供的计算要比直接在 JavaScript 实现的快得多，因为<code>Math</code>对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用<code>Math</code>计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p></blockquote><h3><code>Math</code>对象属性</h3><p><code>Math</code>对象有一些属性，主要用于保存数学中的一些特殊值。</p><h3><code>min()</code>和<code>max()</code>方法</h3><p><code>Math</code>对象也提供了很多辅助执行简单或复杂数学计算的方法。<code>min()</code>和<code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let max = Math.max(3, 54, 32, 16)
console.log(max) // 54

let min = Math.min(3, 54, 32, 16)
console.log(min) // 3</code>
        </deckgo-highlight-code><p>在 3、54、32 和 16 中，<code>Math.max()</code>返回 54，<code>Math.min()</code>返回 3。使用这两个方法可以避免使用额外的循环和<code>if</code>语句来确定一组数值的最大最小值。</p><p>要知道数组中的最大值和最小值，可以像这样使用扩展操作符：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let values = [1, 2, 3, 4, 5, 6, 7, 8]
let max = Math.max(...values)</code>
        </deckgo-highlight-code><h3>舍入方法</h3><p>接下来是用于把小数值舍入为整数的 4 个方法：<code>Math.ceil()</code>、<code>Math.floor()</code>、<code>Math.round()</code>和<code>Math.fround()</code>。这几个方法处理舍入的方式如下：</p><ul><li><code>Math.ceil()</code>方法始终向上舍入为最接近的整数。</li><li><code>Math.floor()</code>方法始终向下舍入为最接近的整数。</li><li><code>Math.round()</code>方法执行四舍五入。</li><li><code>Math.fround()</code>方法返回数值最接近的单精度（32 位）浮点值表示。</li></ul><p>以下示例展示了这些方法的用法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(Math.ceil(25.9)) // 26
console.log(Math.ceil(25.5)) // 26
console.log(Math.ceil(25.1)) // 26
console.log(Math.round(25.9)) // 26
console.log(Math.round(25.5)) // 26
console.log(Math.round(25.1)) // 25
console.log(Math.fround(0.4)) // 0.4000000059604645
console.log(Math.fround(0.5)) // 0.5
console.log(Math.fround(25.9)) // 25.899999618530273
console.log(Math.floor(25.9)) // 25
console.log(Math.floor(25.5)) // 25
console.log(Math.floor(25.1)) // 25</code>
        </deckgo-highlight-code><p>对于 25 和 26（不包含）之间的所有值，<code>Math.cell()</code>都会返回 26，因为它始终向上舍入。<code>Math.round()</code>只在数值大于等于<code>25.5</code>时返回 26，否则返回 25。最后，<code>Math.floor()</code>对所有 25 和 26（不包含）之间的值都会返回 25。</p><h3><code>random()</code>方法</h3><p><code>Math.random()</code>方法返回一个 0 ～ 1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用<code>Math.random()</code>从一组整数中随机选择一个数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">number = Math.floor(
  Math.random() * total_number_of_choices + first_possible_value
)</code>
        </deckgo-highlight-code><p>这里使用了<code>Math.floor()</code>方法，因为<code>Math.random()</code>始终返回小数，即便乘以一个数再加上一个小数也是小数。因此，如果想从 1 ～ 10 范围内选择一个数，代码就是这样的：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = Math.floor(Math.random() * 10 + 1)</code>
        </deckgo-highlight-code><p>这样就有 10 个可能的值（1 ～ 10），其中最小的值是 1。如果想选择一个 2 ～ 10 范围内的值，则代码就想要写成这样：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = Math.floor(Math.random() * 9 + 2)</code>
        </deckgo-highlight-code><p>2 ～ 10 只有 9 个数，所以可选总数（<code>total_number_of_choices</code>）是 9，而最小可能的值（<code>first_possible_value</code>）是 2。很多时候，通过函数来算出可选总数和最小可能的值更方便，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function selectFrom(lowerValue, upperValue) {
  let choices = upperValue - lowerValue + 1
  return Math.floor(Math.random() * choices + lowerValue)
}
let num = selectFrom(2, 10)
console.log(num) //2~10范围内的值，其中包含2和10</code>
        </deckgo-highlight-code><p>这里的函数<code>selectFrom()</code>接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加 1 得到可选总数，然后再套用上面的公式。于是，调用<code>selectFrom(2, 10)</code>就可以从 2 ～ 10 范围内选择一个值了。使用这个函数，从一个数组中随机选择一个元素就很容易。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;purple&#x27;, &#x27;brown&#x27;]
let color = colors[selectFrom(0, colors.length - 1)]</code>
        </deckgo-highlight-code><p>在这个例子中，传给<code>selecFrom()</code>的第二参数是数组长度减 1，即数组最大的索引值。</p><blockquote><p>注意，这里使用<code>Math.random()</code>方法演示是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用<code>window.crypto.getRandomValues()</code>。</p></blockquote><h3>其他方法</h3><p><code>Math</code>对象还有很多涉及各种简单或高阶数运算的方法。讨论每种方法的具体细节或者它们的使用场景超出了本书的范畴。</p><h1>小结</h1><p>JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</p><ul><li>引用值与传统面向对象编程语言中的类相似，但实现不同。</li><li><code>Date</code>类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</li><li><code>RegExp</code>类型是 ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</li></ul><p>JavaScript 比较独特的一点是，函数实际上<code>Function</code>类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。</p><p>由于原始包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。它们都具备如下特点。</p><ul><li>每种包装类型都映射到同名的原始类型。</li><li>以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。</li><li>涉及原始值的语句执行完毕后，包装对象就会被销毁。</li></ul><p>当代码开始执行，全局上下文中会存在两个内置对象：<code>Global</code>和<code>Match</code>。其中，<code>Global</code>对象在大多数 ECMAScript 实现中无法直接访问。不过浏览器将其实现为<code>window</code>对象。所有全局变量和函数都是<code>Global</code>对象的属性。<code>Math</code>对象包含辅助完成复杂计算的属性和方法。</p></article><div class="foot-post-navigator"><button class="previous " style="visibility:visible"><div><span role="img" aria-label="left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></span>上一篇</div><span>（六）集合引用类型</span></button><button class="next " style="visibility:visible"><div>下一篇<span role="img" aria-label="right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span>（四）变量、作用域与内存</span></button></div><div id="commentBoxScript"></div></main></main><div class="table-of-content"><div class="table-of-content-header"></div><div class="table-of-content-main"></div></div><div class="table-of-content-switch"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></main><footer class="footer"><div class="wrapper"><div><h3>Thanks for reading!</h3><p>CopyRight © 2022 Louis K - Present</p></div><div><p style="font-size:1.3rem"><span><span role="img" aria-label="wechat" class="anticon anticon-wechat"><svg viewBox="64 64 896 896" focusable="false" data-icon="wechat" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M690.1 377.4c5.9 0 11.8.2 17.6.5-24.4-128.7-158.3-227.1-319.9-227.1C209 150.8 64 271.4 64 420.2c0 81.1 43.6 154.2 111.9 203.6a21.5 21.5 0 019.1 17.6c0 2.4-.5 4.6-1.1 6.9-5.5 20.3-14.2 52.8-14.6 54.3-.7 2.6-1.7 5.2-1.7 7.9 0 5.9 4.8 10.8 10.8 10.8 2.3 0 4.2-.9 6.2-2l70.9-40.9c5.3-3.1 11-5 17.2-5 3.2 0 6.4.5 9.5 1.4 33.1 9.5 68.8 14.8 105.7 14.8 6 0 11.9-.1 17.8-.4-7.1-21-10.9-43.1-10.9-66 0-135.8 132.2-245.8 295.3-245.8zm-194.3-86.5c23.8 0 43.2 19.3 43.2 43.1s-19.3 43.1-43.2 43.1c-23.8 0-43.2-19.3-43.2-43.1s19.4-43.1 43.2-43.1zm-215.9 86.2c-23.8 0-43.2-19.3-43.2-43.1s19.3-43.1 43.2-43.1 43.2 19.3 43.2 43.1-19.4 43.1-43.2 43.1zm586.8 415.6c56.9-41.2 93.2-102 93.2-169.7 0-124-120.8-224.5-269.9-224.5-149 0-269.9 100.5-269.9 224.5S540.9 847.5 690 847.5c30.8 0 60.6-4.4 88.1-12.3 2.6-.8 5.2-1.2 7.9-1.2 5.2 0 9.9 1.6 14.3 4.1l59.1 34c1.7 1 3.3 1.7 5.2 1.7a9 9 0 006.4-2.6 9 9 0 002.6-6.4c0-2.2-.9-4.4-1.4-6.6-.3-1.2-7.6-28.3-12.2-45.3-.5-1.9-.9-3.8-.9-5.7.1-5.9 3.1-11.2 7.6-14.5zM600.2 587.2c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9c0 19.8-16.2 35.9-36 35.9zm179.9 0c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9a36.08 36.08 0 01-36 35.9z"></path></svg></span></span><span><span role="img" aria-label="qq-circle" class="anticon anticon-qq-circle"><svg viewBox="64 64 896 896" focusable="false" data-icon="qq-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm210.5 612.4c-11.5 1.4-44.9-52.7-44.9-52.7 0 31.3-16.2 72.2-51.1 101.8 16.9 5.2 54.9 19.2 45.9 34.4-7.3 12.3-125.6 7.9-159.8 4-34.2 3.8-152.5 8.3-159.8-4-9.1-15.2 28.9-29.2 45.8-34.4-35-29.5-51.1-70.4-51.1-101.8 0 0-33.4 54.1-44.9 52.7-5.4-.7-12.4-29.6 9.4-99.7 10.3-33 22-60.5 40.2-105.8-3.1-116.9 45.3-215 160.4-215 113.9 0 163.3 96.1 160.4 215 18.1 45.2 29.9 72.8 40.2 105.8 21.7 70.1 14.6 99.1 9.3 99.7z"></path></svg></span></span><span><a href="mailto:k1664032884@gmail.com"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></span><span><a href="https://github.com/kqhasaki" target="_blank" rel="noopener noreferrer"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></span></p></div></div></footer></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/redbook-series/redbook-chapter05";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a6a9e8476add1045c345.js"],"app":["/app-cb8cf455a629701e7063.js"],"component---src-pages-404-js":["/component---src-pages-404-js-8f4b283686f95500832f.js"],"component---src-pages-about-js":["/component---src-pages-about-js-802e58d1b7358e2b6a67.js"],"component---src-pages-non-tech-js":["/component---src-pages-non-tech-js-89e7bc9937558a205dc4.js"],"component---src-templates-blog-list-js":["/component---src-templates-blog-list-js-73a188e2a6f7327575df.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-9d4b15df0cdbe7fceee1.js"]};/*]]>*/</script><script src="/polyfill-a6a9e8476add1045c345.js" nomodule=""></script><script src="/component---src-templates-blog-post-js-9d4b15df0cdbe7fceee1.js" async=""></script><script src="/commons-62d414c82abc9b4aa190.js" async=""></script><script src="/cb1608f2-cc8649749445c1088879.js" async=""></script><script src="/app-cb8cf455a629701e7063.js" async=""></script><script src="/framework-f27b074ecebec0f1dbc4.js" async=""></script><script src="/webpack-runtime-ac47d41b9012053d70c4.js" async=""></script></body></html>