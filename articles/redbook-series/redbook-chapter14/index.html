<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><script>
            const cachedTheme = localStorage.getItem('theme');
            if (cachedTheme) {
              document.documentElement.dataset.theme = cachedTheme;
            } else {
              const preferredTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
              document.documentElement.dataset.theme = preferredTheme;
            }

            const isMacOS = navigator.platform === 'MacIntel'
            if (!isMacOS) {
              document.documentElement.dataset.usrfont = 'non-mac';
            }
            </script><style data-href="/styles.18da6ebcbc41b1254814.css" data-identity="gatsby-global-css">.modal-wrapper{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background:rgba(0,0,0,.6);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:999}.modal-content-wrapper::-webkit-scrollbar{width:0}.modal-content{background:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:1rem;max-width:1080px;min-width:600px;padding:1.5rem;position:relative;width:50vw}.modal-content-wrapper{max-height:70vh;min-height:50vh;overflow-y:auto;width:100%}.modal-closer{cursor:pointer;font-size:1.2rem;position:absolute;right:.8rem;top:.8rem}.modal-closer:hover{color:var(--blue)}@media (max-width:900px){.modal-content{min-width:90%;width:90%}}.post-card-img{background-color:var(--background-color);border-radius:12px;bottom:0;box-shadow:0 0 6px rgba(0,0,0,.15);height:200px;left:50%;-o-object-fit:cover;object-fit:cover;position:absolute;-webkit-transform:translate(-50%) rotate(-8deg);transform:translate(-50%) rotate(-8deg);transition:.2s;width:300px}.img-line{height:120px;margin-bottom:2rem;position:relative}.post-card{align-items:center;border:1px solid var(--card-background-border-color);border-radius:1.5rem;cursor:pointer;display:flex;flex-direction:column;font-weight:300;justify-content:center;margin:140px auto 0;max-width:50rem;padding:1.5rem 2rem;position:relative;transition:.2s}.post-card:hover{box-shadow:0 0 1rem var(--card-box-shadow)}.post-card:active{box-shadow:0 0 1.5rem var(--blue)}.post-card:hover .post-card-img{-webkit-transform:translate(-50%) rotate(0deg);transform:translate(-50%) rotate(0deg)}.post-card h2{font-weight:400}.post-card h2:after{background:var(--blue);content:"";display:block;height:2px;margin-left:auto;margin-right:auto;margin-top:10px;width:60px}.post-card-meta{background-color:var(--card-background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;font-family:var(--font-serif);font-size:.9rem;font-weight:300;margin:1rem 0 0;padding:5px 10px}@media (max-width:750px){.post-card{border-left:none;border-radius:0;border-right:none;padding:1.5rem .8rem}}.article-navigator{background-color:var(--background-color);height:100vh;overflow-y:auto;padding:2.5rem 1.2rem 2.5rem 2rem;position:-webkit-sticky;position:sticky;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}.article-navigator::-webkit-scrollbar{width:0}.article-navigator-visible{-webkit-transform:translateX(0)!important;transform:translateX(0)!important}@media (max-width:1100px){.article-navigator{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;box-shadow:0 0 8px rgba(0,0,0,.1);height:100%;left:0;left:auto!important;max-width:400px;padding:0;position:fixed;-webkit-transform:translateX(-100%);transform:translateX(-100%);transition:.3s;width:calc(100% - 80px);z-index:10}.article-navigator h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.article-navigator p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;padding-left:2rem!important;padding-right:2rem!important;transition:background .3s}.article-navigator p:hover{background:var(--navigator-hover-color)}.article-navigator-switch{visibility:visible!important}}.article-navigator h4{font-size:15px;margin-bottom:.5rem;margin-top:1rem}.article-navigator h4:first-child{margin-top:0}.article-navigator-switch{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;font-size:.8rem;height:30px;left:.5rem;line-height:29px;position:fixed;text-align:center;top:4.5rem;visibility:hidden;width:30px;z-index:9}.article-navigator p{cursor:pointer;font-size:14px;margin:0;overflow-x:hidden;padding-left:.5rem;text-overflow:ellipsis;white-space:nowrap;width:100%}.article-navigator p:hover,.highlighted-navigator-item{color:var(--blue)}.item-list{align-items:center;border-left:3px solid var(--blue);display:flex;flex-direction:column;justify-content:center;margin:0 auto 0 1rem}.item-list .item{margin:0;padding:1rem;position:relative;width:100%}.item:before{background-color:var(--blue);border-radius:50%;content:"";height:.8rem;left:-.5rem;position:absolute;top:2rem;transition:.2s;width:.8rem}.item:hover:before{-webkit-transform:scale(1.2);transform:scale(1.2)}.item-list .item-label{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.item-list .item-content{padding-top:.5rem}.homepage-title{font-weight:700;margin:2rem 0 1rem}.item a{transition:.3s}.item a:hover{color:var(--font-color-highlight)}.footer{background-color:#212121;color:#efefef;font-size:15px;font-weight:100;height:184px;justify-content:space-evenly;min-width:350px;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}.footer,.footer .wrapper{display:flex;flex-direction:row}.footer .wrapper{align-items:center;justify-content:space-around;padding:.5rem;width:100%}.footer .wrapper div{margin:0 8px}.footer h3{font-size:1.6rem;font-weight:lighter;margin-top:8px;width:100%}.footer p{line-height:1.2rem;margin:0;padding:.5rem 0;text-align:center}.footer span{cursor:pointer;font-size:1.6rem;margin-right:12px}.wrapper li{padding:4px 0}.footer span:hover{color:var(--blue)}@media (max-width:750px){.footer .wrapper{flex-direction:column!important;margin-bottom:1rem;width:100%}.base-wrapper,.base-wrapper[name=article-wrapper]{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 0;width:100%}.base-wrapper{margin-top:64px}.not-found-background{aspect-ratio:9/20;user-select:none}}.messager{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;box-shadow:0 0 .8rem var(--card-box-shadow);left:0;margin-left:auto;margin-right:auto;max-width:200px;padding:.5rem 1rem;position:fixed;right:0;text-align:center;top:1rem;-webkit-transform:scale(.2);transform:scale(.2);transition:.2s;z-index:1000}.navbar{background-color:#212121;box-shadow:0 0 1rem rgba(0,0,0,.1);font-family:var(--font-sans-serif);font-weight:100;height:64px;min-width:350px;padding:12px 0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:100%}.navbar nav{align-items:center;display:flex;flex-direction:row;justify-content:space-evenly;max-width:1080px;min-width:375px;width:64%}.nav-link .img-label{font-size:15px;min-width:54px;padding-left:2px}@media (max-width:750px){.navbar{position:absolute;z-index:10}.nav-link .img-label{display:none}}.nav-link{align-items:center;color:#fff;cursor:pointer;display:flex;flex-direction:row;font-size:2.2rem;justify-content:center;margin:0 1rem;min-width:3rem;transition:.2s}.nav-link>img{border-radius:50%;display:inline-block;height:2rem}.nav-link:hover{color:var(--blue);text-decoration:none}.nav-link-gold:hover{color:gold!important;text-decoration:none}.nav-link .link-label{display:block;font-size:16px;text-align:center;width:8rem}.link-active{color:var(--blue)}.link-active-gold{color:gold}.game .question{margin:1.5rem 0}.game .question input{-webkit-appearance:none;appearance:none;background:none;border:none;border-bottom:1px solid var(--font-color);color:var(--font-color);display:inline-block;font-weight:700;max-width:120px;outline:none;padding:1px 8px}.game .question button{background:var(--card-background-color);border-radius:4px;color:var(--font-color);cursor:pointer;font-size:12px;margin-left:8px;padding:2px 6px}.game img{aspect-ratio:16/9;border-radius:8px;height:auto;margin-bottom:.5rem;margin-top:1rem;-o-object-fit:cover;object-fit:cover;overflow:hidden;padding:0;width:100%}.game img,.lamp{position:relative}.lamp{--lamp-lightness:60%;--lamp-color:hsl(0deg 0% var(--lamp-lightness));--outline-offset:var(--sp--3);--outline-color:#fff;background-color:transparent;cursor:pointer;height:45px;-webkit-transform:scale(.711);transform:scale(.711);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:45px}.lamp>*{display:block}.lamp-base{background-color:var(--lamp-color);border-radius:4px 4px 0 0;bottom:0;box-shadow:inset 0 .5px 2px rgba(0,0,0,.6);height:7px;position:absolute;right:5px;-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:30px}.lamp-base-down:after{height:0!important}.lamp-base:after{background-color:#fff;border-radius:1px 1px 0 0;content:"";height:6px;left:4px;position:absolute;top:-2px;-webkit-transform:translateZ(-1px);transform:translateZ(-1px);width:6px}.lamp-neck{bottom:5px;right:8px;-webkit-transform:translateZ(-1px) rotate(20deg);transform:translateZ(-1px) rotate(20deg)}.lamp-neck,.lamp-neck:after{background-color:var(--lamp-color);height:20px;position:absolute;width:4px}.lamp-neck:after{content:"";left:-8px;top:-14px;-webkit-transform:rotate(-60deg);transform:rotate(-60deg)}.lamp-head{--lamp-color-light:hsl(0deg 0% calc(var(--lamp-lightness) - 5%));background-image:linear-gradient(to bottom,var(--lamp-color-light) 5%,var(--lamp-color) 90%,var(--lamp-color-light) 5%);border-radius:100px 100px 0 0;box-shadow:0 4px 4px -2px #e6e6e6;height:10px;left:10px;position:absolute;top:4px;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;width:20px}.lamp-head:before{background-color:var(--lamp-color);border-radius:50%;display:block;height:6px;right:6px;top:-4px;width:6px px}.lamp-head:after,.lamp-head:before{content:"";position:absolute;-webkit-transform:translateZ(-1px);transform:translateZ(-1px)}.lamp-head:after{background:var(--lamp-head-background);-webkit-clip-path:polygon(30% 0,70% 0,100% 100%,0 100%);clip-path:polygon(30% 0,70% 0,100% 100%,0 100%);height:40px;right:0;top:10px;width:20px}.paginator{font-family:monospace;height:5rem;margin-top:4.5rem;-webkit-user-select:none;-ms-user-select:none;user-select:none}.paginator,.paginator .paginator-item{align-items:center;display:flex;justify-content:center}.paginator .paginator-item{border:1px solid var(--navigator-border-color);border-radius:20px;color:var(--navigator-border-color);cursor:pointer;flex-direction:column;height:40px;margin:0 4px;transition:.3s;width:40px}.paginator .paginator-item:hover{background-color:var(--quote-background-color);color:var(--font-color)}.paginator .paginator-item-active{color:var(--font-color)}.paginator .ellipsis{color:var(--navigator-border-color);display:flex;flex-direction:column;font-size:2rem;height:2.8rem;justify-content:center;width:2.8rem}:root{--deckgo-highlight-code-font-family:"PT Mono",ui-monospace,source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace;--font-sans-serif:PingFangSC,-apple-system,BlinkMacSystemFont,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Segoe UI","PingFang SC",HarmonyOS_Regular,"Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Helvetica,"Source Han Sans SC","Noto Sans CJK SC","WenQuanYi Micro Hei",Arial,sans-serif;--font-serif:Lato,Georgia,serif,STZhongsong,STSong,"Noto Serif SC","Noto Serif CJK",PMingLiu,SimSun,"WenQuanYi Bitmap Song","Times New Roman",Times}html[data-theme=dark]{--blue:#02bbff;--background-color:#141414;--background-color-transparent:rgba(0,0,0,.9);--font-color:#dedede;--font-color-header:#fff;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#64de64;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:#1c1c1c;--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030;--lamp-head-background:transparent}html[data-theme=light]{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#000;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#292929;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed;--lamp-head-background:linear-gradient(hsla(0,0%,100%,.8),hsla(0,0%,100%,.35),hsla(0,0%,100%,.05))}html{background-color:#212121;border:none;overflow-y:overlay}html[data-usrfont=non-mac] body{font-family:Microsoft Yahei,STSong,sans-serif!important}body{background-color:#212121;color:var(--font-color);font-family:var(--font-sans-serif);font-weight:400}a{color:inherit;text-decoration:none}*{-webkit-tap-highlight-color:rgba(0,0,0,0);border:none;box-sizing:border-box;list-style-type:none;margin:0;padding:0}ol{margin:.7rem 0}ol li{list-style-type:decimal;margin:.6rem 0 .6rem 2rem}p{-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;display:block;line-height:1.8;margin-block-end:1em;margin-block-start:1em;margin-bottom:.7rem;margin-inline-end:0;margin-inline-start:0;margin-top:.7rem}::selection{background-color:var(--blue);color:#fff}body{word-wrap:break-word;font-kerning:normal;margin:0;padding:0}header{align-items:center;display:flex;flex-direction:row;justify-content:space-around;padding-bottom:0}header>.route-link{margin:0 1rem}.layout{background-color:var(--background-color);display:flex;flex-direction:row}.article-body .article-cover{aspect-ratio:16/10;border-radius:6px!important;-o-object-fit:contain;object-fit:contain;width:225px!important}.base-wrapper{margin-left:auto;margin-right:auto;max-width:1080px;min-height:100%;min-width:350px;padding:2.625rem 1.3125rem;width:60%}.article-body .article-title{font-size:2.2rem;font-weight:400;margin-bottom:2rem;margin-top:.5rem;text-align:center}.article-body strong{color:var(--font-color-highlight)}.article-meta{font-size:.9rem;margin:1rem auto;margin-bottom:3rem!important;text-align:center}.article-meta>span{background-color:var(--card-background-color);border-radius:.5rem;font-family:var(--font-serif);font-weight:lighter;padding:.5rem 1rem}.article-body h1,h2,h3{cursor:pointer}.article-body{font-size:16px}.article-body p{margin-bottom:1.2rem;margin-top:1.2rem}.article-body h1{color:var(--font-color-header);font-size:2rem;font-weight:400;margin-bottom:1.8rem;margin-top:3.5rem}.article-body h1 code{font-size:2rem}.article-body h2{color:var(--font-color-header);font-size:1.6rem;font-weight:400;margin-bottom:1rem;margin-top:2.5rem}.article-body h2 code{font-size:1.5rem}.article-body h3{color:var(--font-color-header);font-size:1.3rem;font-weight:300;line-height:1.8;margin-bottom:1rem;margin-top:1.8rem}.article-body h3 code{font-size:1.2rem;font-weight:700}.article-body h4{color:var(--font-color-header);font-weight:500;margin-bottom:1rem;margin-top:1.5rem}.article-body h4 code{font-size:1rem}.article-body h1:first-child{border-radius:.5rem}.article-body h1.article-title:before{content:none!important}.article-body h1:before{background:var(--blue);content:"";display:block;height:2px;margin-bottom:.5rem;width:70px}.article-body code{background-color:var(--code-background-color);border:1px solid var(--code-border-color);border-radius:4px;color:var(--code-font-color);font-family:var(--deckgo-highlight-code-font-family);font-size:15px;margin:0 2px;padding:1px 4px}.article-body blockquote{background-color:var(--quote-background-color);border-left:2px solid var(--blue);border-radius:0 .5rem .5rem 0;color:var(--font-color-quote);font-weight:300;margin-top:1rem;padding:1rem}.article-body blockquote code{color:var(--code-font-color)}.article-body .article-cover{border-radius:16px;box-shadow:0 0 1px rgba(0,0,0,.1);margin:18px auto 20px;width:80%}.article-body .article-cover,.article-body img{display:block;min-width:330px;-o-object-fit:cover;object-fit:cover}.article-body img{border-radius:12px;margin:18px auto;width:85%}.article-body ul{margin:.7rem 0}.article-body ul li{list-style-type:disc;margin:.6rem 0 .6rem 2rem}.article-body a{color:#189fff}a:hover{text-decoration:underline}.article-body a:after{content:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMSIgaGVpZ2h0PSIxMSIgY2xhc3M9InByZWZpeF9faWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCI+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTkyNC40MDIgMTAyMy4wNjhILjY4Vjk5LjM0NUg0NjIuNTR2OTguOTFIOTkuNTk3VjkyNC4xNWg3MjUuODk2VjU2MS4yMDdoOTguOTF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0ibTkzMC44MDUgMjIuOTc3IDY5Ljk2NiA2OS45NjYtNDUzLjQ5MyA0NTMuNDkyLTY5Ljk2NS02OS45MDF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTEwMjIuNDY0IDMwNC4wM2gtOTguOTE3Vjk5LjM0NUg3MDkuMjMxVi40MjhoMzEzLjIzM3oiLz48L3N2Zz4=);padding-left:2px}.article-body table{word-wrap:normal;border-collapse:collapse;table-layout:fixed;width:100%}th{background-color:rgba(0,0,0,.06);text-align:center}td{background-color:hsla(0,0%,100%,.01);font-weight:300}table,td,th{border:1px solid var(--table-border-color);overflow:auto;padding:.5rem}.theme-changer{border-radius:50%;bottom:1rem;cursor:pointer;position:fixed;right:1rem}.theme-changer img{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;height:30px;padding:6px;width:30px}.iframe-wrapper{aspect-ratio:16/9;border-radius:8px;height:auto;margin-bottom:.5rem;margin-top:1rem;overflow:hidden;padding:0;position:relative;width:100%}.iframe-wrapper .loader{color:#dcdcdc;font-family:sans-serif;font-size:2.5rem;left:50%;position:absolute;text-align:center;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-user-select:none;-ms-user-select:none;user-select:none}iframe{aspect-ratio:16/9;height:auto;width:100%}deckgo-highlight-code{background-color:var(--code-block-background);border-radius:.5rem;box-shadow:none!important;font-size:14px;margin-top:1rem;position:relative}.not-found-background{aspect-ratio:16/9;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:100%}.not-found-background h1{background-color:rgba(0,0,0,.8);border-radius:8px;box-shadow:0 0 3rem rgba(0,0,0,.9);color:#ef3939;font-family:Lato,Georgia,serif;margin-top:4rem;padding:8px;text-align:center}.foot-post-navigator{align-items:center;display:flex;flex-direction:row;justify-content:space-between;margin-bottom:2rem;padding:0 1rem}.foot-post-navigator button{background:none;color:var(--font-color);cursor:pointer;display:flex;flex-direction:column;font-family:inherit!important;font-weight:300!important;margin:0 4px;max-width:45%;text-decoration:none;transition:.2s}.foot-post-navigator button.next{align-items:flex-end}.foot-post-navigator button div{margin-bottom:6px}.foot-post-navigator button span{font-size:15px;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.foot-post-navigator button.to-non-tech:hover{color:gold}.foot-post-navigator button:hover{color:var(--blue)}@media (max-width:1100px){.base-wrapper[name=article-wrapper]{margin-left:0;padding-left:0;padding-right:0;width:75%}.base-wrapper{width:80%}.article-body h1,.article-body h2,.article-body h3,.article-body p{padding-left:.8rem;padding-right:.8rem}.article-body li{padding-right:.8rem}.article-body li p{margin:0}.article-body img,.iframe-wrapper,blockquote,deckgo-highlight-code{border-radius:0!important}.article-body img{width:100%}}@media (max-width:750px){.base-wrapper,.base-wrapper[name=article-wrapper]{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 0;width:100%}.base-wrapper{margin-top:64px}.not-found-background{aspect-ratio:9/20;-webkit-user-select:none;-ms-user-select:none;user-select:none}}.avatar{align-items:center;display:flex;flex-direction:row;height:8rem;justify-content:center}.avatar>img{border-radius:50%;box-shadow:0 0 4px rgba(0,0,0,.1);max-height:100%;-o-object-fit:cover;object-fit:cover;-o-object-position:center center;object-position:center center;opacity:1;padding:.5rem;transition:none 0s ease 0s}.avatar-wrapper{font-weight:300}.avatar-wrapper a{text-decoration:none;transition:.3s}.avatar-wrapper a:hover{color:gold}.avatar-wrapper h1,.avatar-wrapper h2{font-weight:400}.progresser{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:15px 0 0 15px;border-right:none;bottom:4rem;color:var(--font-color);cursor:pointer;font-family:Courier New,Courier,monospace;font-size:13px;font-weight:lighter;height:30px;line-height:30px;position:fixed;right:0;text-align:center;transition:.2s;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:60px;z-index:9}.progresser:after{background-color:var(--quote-background-color);border-radius:15px 0 0 15px;content:"";opacity:0;transition:.2s}.progresser:after,.progresser:hover:after{bottom:0;left:0;position:absolute;right:0;top:0}.progresser:hover:after{content:"up";opacity:1}.progresser-hide{-webkit-transform:translateX(100%);transform:translateX(100%)}.table-of-content{background-color:var(--background-color);height:100vh;position:-webkit-sticky;position:sticky;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}.table-of-content-main{height:100%;overflow-y:auto;padding:2.5rem 1.2rem 3rem}.table-of-content-main::-webkit-scrollbar{width:0}.table-of-content-switch{display:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.table-of-content-visible{-webkit-transform:translateX(0)!important;transform:translateX(0)!important}@media (max-width:1100px){.table-of-content{width:25%}}@media (max-width:750px){.table-of-content{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;box-shadow:0 0 8px rgba(0,0,0,.1);height:100%;max-width:400px;padding:0;position:fixed;right:0;-webkit-transform:translateX(100%);transform:translateX(100%);transition:.3s;width:calc(100% - 80px);z-index:11}p.header-level-h1:first-child{padding-left:14px!important;-webkit-transform:translateX(0);transform:translateX(0)}.table-of-content-main{padding:2rem 0}.table-of-content h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.table-of-content p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;margin-top:0!important;padding-right:2rem!important;transition:background .3s}.table-of-content p.header-level-h1{font-weight:500;margin-top:.8rem;padding-left:2rem}.table-of-content p.header-level-h2{font-size:15px;margin-top:.4rem;padding-left:3rem}.table-of-content .header-level-h3{font-size:15px;margin-top:.2rem;padding-left:4rem}.table-of-content p:hover{background:var(--navigator-hover-color)}.table-of-content-switch{background-color:blue;background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;display:block;font-size:.8rem;height:30px;line-height:30px;position:fixed;right:.5rem;text-align:center;top:4.5rem;width:30px;z-index:8}}.table-of-content::-webkit-scrollbar{display:none}.table-of-content p{cursor:pointer;margin:0;overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.table-of-content .topHeader{color:var(--blue)!important}.table-of-content p:hover{color:var(--blue)}p.header-level-h1:first-child{border-left:2px solid var(--blue);padding-left:4px;-webkit-transform:translateX(-8px);transform:translateX(-8px)}p.header-level-h1{font-size:15px;font-weight:500;margin-top:.8rem}p.header-level-h2{font-size:14px;margin-top:.4rem;padding-left:1rem}p.header-level-h3{font-size:14px;font-weight:300;margin-top:.2rem;padding-left:2rem}</style><meta name="generator" content="Gatsby 4.4.0"/><link rel="icon" href="/favicon-32x32.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=d58da36a3a1345ad1c6bcba6e7d0c6de"/><link as="script" rel="preload" href="/webpack-runtime-fb9925dca62e4624cbf8.js"/><link as="script" rel="preload" href="/framework-f27b074ecebec0f1dbc4.js"/><link as="script" rel="preload" href="/app-cb8cf455a629701e7063.js"/><link as="script" rel="preload" href="/cb1608f2-cc8649749445c1088879.js"/><link as="script" rel="preload" href="/commons-63439ea553d45328beab.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-cf95b4debfeb2c79909f.js"/><link as="fetch" rel="preload" href="/page-data/articles/redbook-series/redbook-chapter14/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2757060725.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3605573801.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><title>Louis K - Software Engineer</title><header class="navbar"><nav><div class="nav-link"><img alt="avatar" src="/static/avatar-05f3b9b1e1ce151053fb8a66dbc70489.png"/><span class="img-label">Louis K</span></div><a class="nav-link" href="/"><span class="link-label">Tech</span></a><a class="nav-link-gold nav-link" href="/non-tech/"><span class="link-label">Ramble</span></a><div class="nav-link"><button class="lamp" aria-pressed="true" type="button"><span class="lamp-base"></span><span class="lamp-neck"></span><span class="lamp-head"></span></button></div></nav></header><main class="layout"><div class="article-navigator-switch"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="list" class="svg-inline--fa fa-list " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M88 48C101.3 48 112 58.75 112 72V120C112 133.3 101.3 144 88 144H40C26.75 144 16 133.3 16 120V72C16 58.75 26.75 48 40 48H88zM480 64C497.7 64 512 78.33 512 96C512 113.7 497.7 128 480 128H192C174.3 128 160 113.7 160 96C160 78.33 174.3 64 192 64H480zM480 224C497.7 224 512 238.3 512 256C512 273.7 497.7 288 480 288H192C174.3 288 160 273.7 160 256C160 238.3 174.3 224 192 224H480zM480 384C497.7 384 512 398.3 512 416C512 433.7 497.7 448 480 448H192C174.3 448 160 433.7 160 416C160 398.3 174.3 384 192 384H480zM16 232C16 218.7 26.75 208 40 208H88C101.3 208 112 218.7 112 232V280C112 293.3 101.3 304 88 304H40C26.75 304 16 293.3 16 280V232zM88 368C101.3 368 112 378.7 112 392V440C112 453.3 101.3 464 88 464H40C26.75 464 16 453.3 16 440V392C16 378.7 26.75 368 40 368H88z"></path></svg></div><div class="article-navigator"><h4>electron</h4><p title="electron中的进程模型" class="">electron中的进程模型</p><h4>前端杂谈</h4><p title="跨源资源共享（CORS）" class="">跨源资源共享（CORS）</p><p title="手动实现一个Promise" class="">手动实现一个Promise</p><p title="利用ESLint、Prettier统一团队内代码风格" class="">利用ESLint、Prettier统一团队内代码风格</p><p title="V8引擎中的对象属性访问" class="">V8引擎中的对象属性访问</p><p title="关于no-cors的误区" class="">关于no-cors的误区</p><p title="地图工具中的线条吸附——一个简单方案" class="">地图工具中的线条吸附——一个简单方案</p><p title="渲染页面：浏览器的工作原理" class="">渲染页面：浏览器的工作原理</p><p title="React diffing算法" class="">React diffing算法</p><p title="Vercel简介 静态博客部署" class="">Vercel简介 静态博客部署</p><p title="防抖和节流" class="">防抖和节流</p><h4>JavaScript数据结构和算法</h4><p title="（八）字典和散列表" class="">（八）字典和散列表</p><p title="（十）树" class="">（十）树</p><p title="（十二）图" class="">（十二）图</p><p title="（十三）排序和搜索算法" class="">（十三）排序和搜索算法</p><p title="（十四）算法设计与技巧" class="">（十四）算法设计与技巧</p><h4>JavaScript高级程序设计</h4><p title="（一）什么是JavaScript？" class="">（一）什么是JavaScript？</p><p title="（二）HTML中的JavaScript" class="">（二）HTML中的JavaScript</p><p title="（三）JavaScript语言基础" class="">（三）JavaScript语言基础</p><p title="（四）变量、作用域与内存" class="">（四）变量、作用域与内存</p><p title="（五）基本引用类型" class="">（五）基本引用类型</p><p title="（六）集合引用类型" class="">（六）集合引用类型</p><p title="（七）迭代器与生成器" class="">（七）迭代器与生成器</p><p title="（八）对象、类与面向对象编程" class="">（八）对象、类与面向对象编程</p><p title="（九）代理与反射" class="">（九）代理与反射</p><p title="（十一）期约与异步函数" class="">（十一）期约与异步函数</p><p title="（十四）DOM" class="highlighted-navigator-item">（十四）DOM</p><p title="（十五）DOM扩展" class="">（十五）DOM扩展</p><p title="（十七）事件" class="">（十七）事件</p><p title="（二十）JavaScript API" class="">（二十）JavaScript API</p><p title="（二十三）JSON" class="">（二十三）JSON</p><p title="（二十四）网络请求与远程资源" class="">（二十四）网络请求与远程资源</p><p title="（二十五）客户端存储" class="">（二十五）客户端存储</p><p title="（二十六）模块" class="">（二十六）模块</p></div><main class="base-wrapper" name="article-wrapper"><main><div class="progresser">0<!-- -->%</div><article class="article-body" style="margin-bottom:4rem"><img alt="https://tva1.sinaimg.cn/large/e6c9d24egy1h0xwa4k5h0j20rs0jg759.jpg" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0xwa4k5h0j20rs0jg759.jpg" class="article-cover"/><h1 class="article-title">（十四）DOM</h1><p class="article-meta"><span><span role="img" aria-label="field-time" class="anticon anticon-field-time"><svg viewBox="64 64 896 896" focusable="false" data-icon="field-time" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M945 412H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h256c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM811 548H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h122c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM477.3 322.5H434c-6.2 0-11.2 5-11.2 11.2v248c0 3.6 1.7 6.9 4.6 9l148.9 108.6c5 3.6 12 2.6 15.6-2.4l25.7-35.1v-.1c3.6-5 2.5-12-2.5-15.6l-126.7-91.6V333.7c.1-6.2-5-11.2-11.1-11.2z"></path><path d="M804.8 673.9H747c-5.6 0-10.9 2.9-13.9 7.7a321 321 0 01-44.5 55.7 317.17 317.17 0 01-101.3 68.3c-39.3 16.6-81 25-124 25-43.1 0-84.8-8.4-124-25-37.9-16-72-39-101.3-68.3s-52.3-63.4-68.3-101.3c-16.6-39.2-25-80.9-25-124 0-43.1 8.4-84.7 25-124 16-37.9 39-72 68.3-101.3 29.3-29.3 63.4-52.3 101.3-68.3 39.2-16.6 81-25 124-25 43.1 0 84.8 8.4 124 25 37.9 16 72 39 101.3 68.3a321 321 0 0144.5 55.7c3 4.8 8.3 7.7 13.9 7.7h57.8c6.9 0 11.3-7.2 8.2-13.3-65.2-129.7-197.4-214-345-215.7-216.1-2.7-395.6 174.2-396 390.1C71.6 727.5 246.9 903 463.2 903c149.5 0 283.9-84.6 349.8-215.8a9.18 9.18 0 00-8.2-13.3z"></path></svg></span> <!-- -->2022-02-12<!-- --> | <span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span> <!-- -->8800<!-- -->words <!-- -->31<!-- -->min</span></p><p>文档对象模型（DOM, Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML），<strong>DOM 现在是真正的跨平台、语言无关的表示和操作网页的方式</strong>。</p><p>DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。DOM 直接与浏览器中的 HTML 网页相关，并且在浏览器环境 JavaScript 中提供了 DOM API。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/cCOL7MC4Pl0" title="更多关于事件循环" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h1>节点层级</h1><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分为很多类型，每种类型对应着文档中不同的信息和标记，也都有自己不同的特性、数据和方法，并且和其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML 为例：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Sample Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello World!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
        </deckgo-highlight-code><p>它在 DOM 中就可以表示为层级结构。用<code>document</code>表示文档的根节点，根节点下面的唯一子节点是<code>&lt;html&gt;</code>元素，称为<strong>文档元素</strong><code>documentElement</code>。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档<strong>只能有一个文档元素</strong>。在 HTML 页面中，文档元素始终是<code>&lt;html&gt;</code>元素。在 XML 文档中，没有预定义这样的元素，任何元素都可能成为文档元素。</p><p>HTML 中的每段标记都可以表示为这个树形结构的一个节点。元素节点表示 HTML 元素，属性节点表示属性，文档节点表示文档类型，注释节点表示注释。DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。</p><h2><code>Node</code>类型</h2><p>DOM Level1 描述了名为<code>Node</code>的接口，这个接口是所有 DOM 节点类型都必须实现的。<code>Node</code>接口在 JavaScript 被实现为<code>Node</code>类型，在除 IE 之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承`Node·类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有<code>nodeType</code>属性，表示该节点的类型。节点类型由定义在<code>Node</code>类型上的 12 个数值常量表示：</p><ul><li><code>Node.ELEMENT_NODE</code>（1）</li><li><code>Node.ATTRIBUTE_NODE</code>（2）</li><li><code>Node.TEXT_NODE</code>（3）</li><li><code>Node.CDATA_SECTION_NODE</code>（4）</li><li><code>Node.ENTITY_REFERENCE_NODE</code>（5）</li><li><code>Node.ENTITY_NODE</code>（6）</li><li><code>Node.PROCESSING_INSTRUCTION_NODE</code>（7）</li><li><code>Node.COMMENT_NODE</code>（8）</li><li><code>Node.DOCUMENT_NODE</code>（9）</li><li><code>Node.DOCUMENT_TYPE_NODE</code>（10）</li><li><code>Node.DOCUMENT_FRAGMENT_NODE</code>（11）</li><li><code>Node.NOTATION_NODE</code>（12）</li></ul><p>节点类型可以通过与这些常量比较来确定，例如：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">if (someNode.nodeType === Node.ELEMENT_NODE) {
  alert(&#x27;Node is an element.&#x27;)
}</code>
        </deckgo-highlight-code><p>浏览器并不支持所有的 DOM 节点类型。开发者最常用的两个节点是<strong>元素节点</strong>和<strong>文本节点</strong>。<code>nodeName</code>和<code>nodeValue</code>保存着有关节点的信息。这两个属性的值完全取决于节点类型。</p><p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于将文档树比做家谱。在 HTML 中，<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>元素的子元素，而后者是前者的父元素。<code>&lt;head&gt;</code>元素是<code>&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code>&lt;html&gt;</code>。</p><p>每个节点都有一个<code>childNodes</code>属性，其中包含一个<code>NodeList</code>的实例。<code>NodeList</code>是一个类数组对象，用于存储可以按位置存取的有序节点。注意<code>NodeList</code>并不是<code>Array</code>的实例，但可以使用中括号访问它的值，也具有<code>length</code>属性。<code>NodeList</code>对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在<code>NodeList</code>中反映出来。我们通常说<code>NodeList</code>是实时的活动对象，而不是第一次访问时所获得内容的快照。</p><p>下面的例子展示了如何使用中括号或使用<code>item()</code>方法访问<code>NodeList</code>中的元素：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const firstChild = someNode.childNodes[0]
const secondChild = someNode.childNodes.item(1)
const count = someNode.childNodes.length</code>
        </deckgo-highlight-code><p>无论是使用中括号还是<code>item()</code>方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个类数组对象。注意，<code>length</code>属性表示那一时刻<code>NodeList</code>中节点的数量。使用<code>Array.from()</code>可以将<code>NodeList</code>对象转换为数组。</p><p>每个节点都一个<code>parentNode</code>属性，指向其 DOM 树中的父元素。<code>childNodes</code>中的所有节点都有同一个父元素，因此它们的<code>parentNode</code>属性都指向同一节点。此外<code>childNodes</code>列表中的每个节点都是同一列表中其他节点的同胞节点。而使用<code>previousSibling</code>和<code>nextSibling</code>可以在这个列表的节点间导航。第一个节点的<code>previousSibling</code>和最后一个节点的<code>nextSibling</code>属性也是<code>null</code>：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">if (someNode.nextSibling === null) {
  alert(`Last node in the parent&#x27;s childNodes list.`)
} else if (someNode.previousSibling === null) {
  alert(`First node in the parent&#x27;s childNodes list.`)
}</code>
        </deckgo-highlight-code><p>父节点中它的第一个和最后一个子节点也有专门属性：<code>firstChild</code>和<code>lastChild</code>分别指向<code>childNodes</code>中的第一个和最后一个子节点。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzc6n59b8oj31s50jtq4y.jpg"/></p><p>有了这些关系，<code>childNodes</code>属性的作用远远不是必备的属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，这种便利性就是<code>childNodes</code>的最大亮点。还有一个方法是<code>hasChildNodes()</code>，这个方法如果返回<code>true</code>则说明节点有一个或者多个子节点。</p><p>之后还有一个所有节点都共享的关系。<code>ownerDocument</code>属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档拥有，因为一个节点不可能同时存在于两个或多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐渐上溯了。</p><p>因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。<strong>最常用</strong>的方法是<code>appendChild()</code>，用于在<code>childNodes</code>列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。<code>appendChild()</code>方法返回新添加的节点，如下面所示：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const returnNode = someNode.appendChild(newNode)
alert(returnNode === newNode) // true
alert(someNode.lastChild === newNode) // true</code>
        </deckgo-highlight-code><p>如果将文档中已经存在的节点传给<code>appendChild()</code>，那么这个节点会从之前的位置被转移到新位置。即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多的地方。因此，如果调用<code>appendChild()</code>传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const returnNode = someNode.appendChild(someNode.firstChild)
alert(returnNode === someNode.firstChild) // false
alert(returnNode === someNode.lastChild) // true</code>
        </deckgo-highlight-code><p>如果想把放到<code>childNodes</code>中的特定位置而不是末尾，则可以使用<code>insertBefore()</code>方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是<code>null</code>，则<code>insertBefor()</code>与<code>appendChild()</code>效果相同：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">// 作为最后一个子节点插入
const retunNode = someNode.insertBefore(newNode, null)
alert(returnNode === someNode.lastChild) // true
// 作为新的第一个子节点插入
const returnNode = someNode.insertBefore(newNode, someNode.firstChild)
alert(returnNode === newNode) // true
alert(newNode === someNode.firstChild) // true
// 插入最后一个子节点前面
const returnNode = someNode.insertBefore(newNode, someNode.lastChild)
alert(newNode === someNode.childNodes[someNode.childNodes.length - 2]) // true</code>
        </deckgo-highlight-code><p><code>appendChild()</code>和<code>insertBefore()</code>在插入节点时不会删除任何已有节点。相对地，<code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点被返回并从文档树中完全移除，要插入的节点会取而代之。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">// 替换第一个子节点
const returnNode = someNode.replaceChild(newNode, someNode.firstChild)
// 替换最后一个子节点
const returnNode = someNode.replaceChild(newNode, someNode.lastChild)</code>
        </deckgo-highlight-code><p>使用<code>replaceChild()</code>插入一个节点后，所有的关系指针都会被从替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但是文档中已经没有它的位置。</p><p>要移除节点而不是替换节点，可以使用<code>removeChild()</code>方法，这个方法接受一个参数，即要删除的节点。被移除的节点会被返回。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">// 删除第一个子节点
const formerFirstChild = someNode.removeChild(someNode.firstChild)
// 删除最后一个子节点
const formerLastChild = someNode.removeChild(someNode.lastChild)</code>
        </deckgo-highlight-code><p>与<code>replaceChild()</code>方法一样，通过<code>removeChild()</code>被移除的节点从技术上说仍然被同一文档所拥有，但文档中已经没有它的位置。</p><p>上面介绍的 4 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面的<code>parentNode</code>属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。</p><p>所有节点类型还共享了两个方法。一个是<code>cloneNode()</code>，会返回与调用它的节点一模一样的节点。<code>cloneNode()</code>方法接收一个布尔值参数，表示是否深复制。在传入<code>true</code>参数时，会进行深复制，即复制子节点及其整个 DOM 树。如果传入<code>false</code>则只会复制调用该方法的节点。复制返回的节点<strong>属于文档所有</strong>，但是尚未指定父节点，所以可以成为<strong>孤儿节点</strong>。可以通过<code>appendChild()</code>、<code>insertBefore()</code>或者<code>replaceChild()</code>方法把孤儿节点添加到文档中；另一个方法是<code>normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或者 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用<code>normalize()</code>方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本的节点。</p><h2><code>Document</code>类型</h2><p><code>Document</code>类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象<code>document</code>是<code>HTMLDocument</code>的实例（<code>HTMLDocument</code>继承<code>Document</code>），表示整个 HTML 页面。<code>document</code>是<code>window</code>对象的属性，因此是一个全局对象。<code>Document</code>类型的节点有以下特征：</p><ul><li><code>nodeType</code>值为 9（<code>Node.DOCUMENT_NODE</code>）</li><li><code>nodeName</code>值为<code>#document</code></li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>null</code></li><li><code>ownerDocument</code>值为<code>null</code></li><li>子节点可以是<code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code>类型。</li></ul><p><code>Document</code>类型可以表示 HTML 页面后者其他 XML 文档，但是最常用的还是通过<code>HTMLDocument</code>实例获取<code>document</code>对象。<code>document</code>对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p><p>虽然 DOM 规范规定<code>Document</code>节点的子节点可以是<code>DocumentType</code>、<code>Element</code>、<code>ProcessingInstruction</code>或者<code>Comment</code>，但也提供了两个访问节点的快捷方式。一个是<code>documentElement</code>属性，始终指向 HTML 页面中的<code>&lt;html&gt;</code>元素。另外，通过<code>document.childNodes</code>中始终有<code>&lt;html&gt; </code>元素。</p><p>作为<code>HTMLDocument</code>的实例，<code>document</code>对象还有一个<code>body</code>属性，直接指向<code>&lt;body&gt;</code>元素。因为这个元素是开发者使用最多的元素，故而在 DOM 编程中经常看到<code>document.body</code>。</p><p>所有主流浏览器都支持<code>document.documentElement</code>和<code>document.body</code>。<code>Document</code>类型另一种可能的子节点是<code>DocumentType</code>。<code>&lt;!doctype&gt;</code>标签是文档中独立的部分，其信息可以通过<code>doctype</code>属性（在浏览器中是<code>document.doctype</code>来访问。</p><blockquote><p>一般来说，<code>appendChild()</code>、<code>removeChild()</code>和<code>replaceChild()</code>方法不会用在<code>document</code>对象上。这是因为文档类型（如果存在）是只读的，并且只能有一个<code>Element</code>类型的子节点（即<code>&lt;html&gt;</code>）。</p></blockquote><p>作为<code>HTMLDocument</code>实例的<code>document</code>对象，还有一些标准<code>Document</code>对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是<code>title</code>，包含了<code>&lt;title&gt;</code>元素中的文本，通常显示在浏览器窗口或者标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过修改<code>title</code>属性并不会改变<code>title</code>元素。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const originTitle = document.title
document.title = &#x27;New Page Title&#x27;</code>
        </deckgo-highlight-code><p>另外<code>URL</code>、<code>domain</code>和<code>referrer</code>属性含有网页的地址信息。其中<code>URL</code>包含当前页面的完整 URL（地址栏中的 URL），<code>domain</code>包含了页面的域名，而<code>referrer</code>包含链接到当前页面的那个页面的 URL。如果当前页面没有来源，那么<code>referrer</code>属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JavaScript 中通过这几个属性暴露出来而已。这几个属性中只有<code>domain</code>是可以设置的。出于安全考虑给<code>domain</code>属性的值是有限制的。如果 URL 包含子域名如<code>p2p.wrox.com</code>，则可以将<code>domain设置为</code>wrox.com`（URL 包含“WWW”也是一样）。不能给这个属性设置 URL 中不包含的值。</p><p>当页面中包含来自某个不同子域的窗格（<code>&lt;frame&gt;</code>）或者内嵌窗格（<code>&lt;iframe&gt;</code>）时，设置<code>document.domain</code>是有用的。因为跨源通信存在安全隐患，所以不同子域的页面无法通过 JavaScript 通信。此时，在每个页面上把<code>document.domain</code>设置为相同的值，这些页面就可以访问对方的 JavaScript 对象了。例如一个加载自<code>www.wrox.com</code>的页面中包含一个内嵌窗格，其中的页面加载自<code>p2p.wrox.com</code>。这两个页面的<code>document.domain</code>包含了不同的字符串，内部和外部之间不能访问对方的 JavaScript 对象。如果每个页面都把<code>document.domain</code>设置为<code>wrox.com</code>，俺么这两个页面之间就可以通信了。浏览器对<code>domain</code>属性还有一个限制，即这个属性一旦放松就不能再收紧。</p><blockquote><p>注：笔者摘抄的日期为 2022-02-15，在 chrome 浏览器中测试<code>domain</code>属性可以收紧回原来。</p></blockquote><p>使用 DOM 最常见的情形可能就是获取某个或某些元素的引用，然后对它们执行某些操作。<code>document</code>对象上暴露一些方法，可以实现这些操作。<code>getElementById()</code>和<code>getElementsByTagName()</code>就是<code>Document</code>类型提供的两个方法。</p><p><code>getElementById()</code>方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回<code>null</code>。参数 ID 必须跟元素在页面中的<code>id</code>属性值完全匹配，包括大小写。例如页面中有以下元素：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;div id=&quot;myDiv&quot;&gt;Some text&lt;/div&gt;</code>
        </deckgo-highlight-code><p>可以使用以下代码获取该元素：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const div = document.getElementById(&#x27;myDiv&#x27;) // 获取对&lt;div&gt;元素的引用</code>
        </deckgo-highlight-code><p>如果页面中确实存在多个具有相同 ID 的元素，则<code>getElementById()</code>返回在 DOM 树中出现的第一个元素。</p><p><code>getElementsByTagName()</code>是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或者多个元素的<code>NodeList</code>。在 HTML 文档中，这个方法返回一个<code>HTMLCollection</code>对象。考虑到这两者都是“实时”的列表，<code>HTMLCollection</code>和<code>NodeList</code>是很相似的。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const images = document.getElementsByTagName(&#x27;img&#x27;)</code>
        </deckgo-highlight-code><p>这里把返回的<code>HTMLCollection</code>对像保存在了变量<code>images</code>中。与<code>NodeList</code>对象一样，也可以使用中括号或者<code>item()</code>方法从<code>HTMLCollection</code>取得特定的元素。而取得元素的数量同样可以通过<code>length</code>属性得知。<code>HTMLCollection</code>对象还有一个额外的方法<code>namedItem()</code>，可以通过标签的<code>name</code>属性取得某一项的引用。例如，假设页面中包含如下的<code>&lt;img&gt;</code>元素：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot; /&gt;</code>
        </deckgo-highlight-code><p>那么也可以从<code>images</code>中获取对这个元素的引用：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const myImage = images.namedItem(&#x27;myImage&#x27;)</code>
        </deckgo-highlight-code><p>这样<code>HTMLCollection</code>就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于<code>name</code>属性的元素，还可以直接使用中括号来获取，如下面的例子所示：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const myImage = images[&#x27;myImage&#x27;]</code>
        </deckgo-highlight-code><p>对<code>HTMLCollection</code>对象而言，中括号既可以接受数值索引，也可以接受字符串索引。而在后台，数值索引会调用<code>item()</code>，字符串索引会调用<code>namedItem()</code>。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const allElements = document.getElementsByTagName(&#x27;*&#x27;)</code>
        </deckgo-highlight-code><p>传入通配符<code>*</code>可以获取文档中的所有元素。另外<code>document.getElementsByName()</code>方法可以匹配具有给定<code>name</code>属性的所有元素，也返回<code>HTMLCollection</code>。</p><p>另外<code>document</code>对象上还暴露了几个特殊集合，这些集合都是<code>HTMLCollection</code>的实例。这些集合是访问文档中公共部分的快捷方式：</p><ul><li><code>document.anchors</code>返回文档中所有带有<code>name</code>属性的<code>&lt;a&gt;</code>元素。</li><li><code>document.forms</code>返回文档中所有的<code>&lt;form&gt;</code>元素。</li><li><code>document.images</code>返回文档中所有<code>&lt;img&gt;</code>元素。</li><li><code>document.links</code>返回文档中所有带有<code>href</code>属性的<code>&lt;a&gt;</code>元素。</li></ul><p>这些特殊集合始终存在于<code>HTMLDocument</code>对象上，而且与所有<code>HTMLCollection</code>对象一样，其内容也会实时更新以符合当前文档的内容。</p><blockquote><p>由于 DOM 有多个 Level 和多个部分，因此确定浏览器实现了 DOM 的哪些部分是很必要的。<code>document.implementation</code>属性是一个对象，提供了与浏览器 DOM 实现相关的信息和能力。DOM Level 1 在<code>document.implementation</code>上定义了一个方法即<code>hasFeature()</code>。这个方法接收两个参数：特性名称和 DOM 版本。如果支持，则返回<code>true</code>：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const hasXmlDom = document.implementation.hasFeature(&#x27;XML&#x27;, &#x27;1.0&#x27;)</code>
        </deckgo-highlight-code><p>但是由于实现不一致，因此其返回值不可靠。目前这个方法已经被废弃，主流浏览器为了向后兼容仍然支持这个方法，但是无法检测什么都一律返回<code>true</code>。</p></blockquote><p><strong><code>document</code>对象有一个古老的能力</strong>，即向网页输出流中写入内容。这个能力对应四个方法：<code>write()</code>、<code>writeln()</code>、<code>open()</code>、<code>close()</code>。其中，<code>write()</code>和<code>written()</code>方法都能接受一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而<code>writeln()</code>在字符串末尾追加一个换行符<code>\n</code>。这两个方法可以用来在页面加载期间动态添加内容。页面渲染期间如果 JavaScript 脚本已经执行，则<code>document.write()</code>可以向文档中输入内容。但是如果在页面加载完之后再调用<code>document.write()</code>，则输出的内容会重写整个页面。<code>open()</code>和<code>close()</code>方法分别用于打开和关闭网页输出流。在调用<code>write()</code>和<code>writeln()</code>时，这两个方法都不是必须的。注意，现在已经没有理由使用这些古老的方法，因此不要在代码中出现。</p><h2><code>Element</code>类型</h2><p>除了<code>Document</code>类型，<code>Element</code>类型就是 Web 开发中最常用的类型了。<code>Element</code>表示 XML 或者 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。<code>Element</code>类型的节点具有以下特征：</p><ul><li><code>nodeType</code>等于 1</li><li><code>nodeName</code>值为元素的标签名</li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>Document</code>或者<code>Element</code>对象</li><li>子节点可以是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>、<code>EntityReference</code>类型。</li></ul><p>可以通过<code>nodeName</code>或者<code>tagName</code>属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会）。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const div = document.getElementById(&#x27;myDiv&#x27;)

console.log(div.tagName === div.nodeName)</code>
        </deckgo-highlight-code><p>例子中元素标签名称为<code>div</code>，ID 为<code>myDiv</code>。注意<code>tagName</code>返回的是大写。在 HTML 中元素标签名始终以全大写表示：在 XML 中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">if (element.tagName.toLowerCase() === &#x27;div&#x27;) {
  // 推荐，适用于所有文档
}</code>
        </deckgo-highlight-code><p>这个例子演示了比较<code>tagName</code>属性的情形，是推荐的写法。</p><p>所有的 HTML 元素都通过<code>HTMLElement</code>类型表示，包括其实例和间接实例。另外，<code>HTMLElement</code>直接继承了<code>Element</code>并增加了一些属性。每个属性都对应下列属性，它们是所有 HTML 元素都有的标准属性：</p><ul><li><code>id</code>，元素在文档中的唯一标识符；</li><li><code>title</code>，包含元素的额外信息，通常以提示条形式展示；</li><li><code>lang</code>，元素内容的语言代码，很少用；</li><li><code>dir</code>，语言的书写方向，很少用；</li><li><code>className</code>，相当于<code>class</code>属性，用于指定元素的 CSS 类，因为<code>class</code>是 ECMAScript 关键字，所以不能直接用这个名字。</li></ul><p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。例如有下面的 HTML 元素：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt;</code>
        </deckgo-highlight-code><p>修改<code>dir</code>会导致页面文本立即向左对齐或向右对齐。修改<code>className</code>会立即反映应用到新类名的 CSS 样式。</p><p>如前所述，所有 HTML 元素都是<code>HTMLElement</code>或其子类型的实例。所有元素都有多个属性，通常用于为元素或者其内容附加更多信息。与属性相关的 DOM 方法主要有三个：<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>。这些方法主要用于操纵属性，包括在<code>HTMLElement</code>类型上定义的属性。注意传递给<code>getAttribute()</code>的属性名和它们实际的属性名是一样的，因此这里要传<code>class</code>而非<code>className</code>，如果给定的属性不存在则<code>getAttribute()</code>返回<code>null</code>。</p><p><code>getAttribute()</code>方法也能取得不是 HTML 语言正式属性的自定义属性值，例如：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt;</code>
        </deckgo-highlight-code><p>这个元素有一个自定义属性，可以像其他属性一样使用<code>getAttribute()</code>取得这个属性的值：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const value = div.getAttribute(&#x27;my_special_attribute&#x27;)</code>
        </deckgo-highlight-code><p>注意，属性名不区分大小写，因此<code>ID</code>和<code>id</code>被认为是同一个属性。另外，根据 HTML5 规范的要求，自定义属性名应该前缀<code>data-</code>以方便验证。</p><p>元素的所有属性也可以通过相应的 DOM 元素对象的属性来取得。通过 DOM 对象访问的属性中有两个返回的值跟使用<code>getAttribute()</code>取得的值不一样。首先是<code>style</code>属性，这个属性用于为元素设定 CSS 样式。在使用<code>getAttribute()</code>访问<code>style</code>属性时，返回的是 CSS 字符串。而通过 DOM 对象的属性访问时，<code>style</code>属性返回的是一个<code>CSSStyleDeclaration</code>对象。DOM 对象的<code>style</code>属性用于以编程方式来读写元素样式，因此不会直接映射为元素中<code>style</code>属性的字符串值。</p><p>第二个属性其实是一类属性，即事件处理程序，例如<code>onclick</code>。在元素上使用事件属性时（例如<code>onclick</code>）、属性的值时一段 JavaScript 代码。如果使用<code>getAttribute()</code>访问事件属性，则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的是一个 JavaScript 函数（未指定该属性则返回<code>null</code>）。这是因为<code>onclick</code>及其他事件属性是可以接受函数作为值的。考虑到以上差异，开发者在进行 DOM 编程时通常会放弃使用<code>getAttribute()</code>而只使用对象属性。<strong>实际开发中，只使用<code>getAttribute()</code>来获取自定义属性的值</strong>。同理，实际上也很少使用<code>setAttribute()</code>为元素属性赋值，而是直接给 DOM 对象的属性属性赋值。</p><p>可以使用<code>document.createElement()</code>方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档是区分大小写的。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const div = document.createElement(&#x27;div&#x27;)</code>
        </deckgo-highlight-code><p>使用<code>createElement()</code>方法创建新元素的同时也会将其<code>ownerDocument</code>属性设置为<code>document</code>。此时可以再为其添加属性、添加更多子元素。</p><blockquote><p>在新元素设置这些属性只会附加信息，因为这个元素还没有添加到文档树，所以不会影响浏览器显示。</p></blockquote><p>要把元素添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>。元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改都会立即在浏览器中反映出来。</p><p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code>childNodes</code>属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或者处理指令。不同浏览器在识别这些节点时的表现有明显不同。要取得某个元素的子节点和其他后代节点，可以使用元素的<code>getElmentsByTagName()</code>方法。在元素上调用这个方法与文档上调用是一样的，只不过搜索范围限制在当前元素之内，只会返回当前元素的后代。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzgwfbuqwgj20u8032t9a.jpg"/></p><blockquote><p>注意<code>Element</code>类型上只定义了<code>getElementsByTagName</code>和<code>getElementsByClassName</code>方法（由 DOM1 扩展提供），没有<code>getElementById</code>。</p></blockquote><h2><code>Text</code>类型</h2><p><code>Text</code>节点由<code>Text</code>类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。<code>Text</code>类型的节点具有一下特征：</p><ul><li><code>nodeType</code>等于 3</li><li><code>nodeName</code>值为<code>#text</code></li><li><code>nodeValue</code>值为节点中包含的文本</li><li><code>parentNode</code>值为<code>Element</code>对象</li><li><strong>不支持子节点</strong></li></ul><p><code>Text</code>节点中包含的文本可以通过<code>nodeValue</code>属性访问，也可以通过<code>data</code>属性访问，这两个属性包含相同的值。修改<code>nodeValue</code>或者<code>data</code>的值，也会在另一个属性反映出来。文本节点包含了以下操作文本的方法：</p><ul><li><code>appendData(text)</code>，向节点末尾添加文本<code>text</code></li><li><code>deleteData(offset, count)</code>，从位置<code>offset</code>开始删除<code>count</code>个字符</li><li><code>insertData(offset, text)</code>，在位置<code>offset</code>插入<code>text</code></li><li><code>replaceData(offset, count, text)</code>，用<code>text</code>替换从位置<code>offset</code>到<code>offset + count</code>的文本</li><li><code>splitText(offset)</code>，在位置<code>offset</code>将当前文本节点拆分为两个文本节点</li><li><code>subStringData(offset, count)</code>，提取从位置<code>offset</code>到<code>offset + count</code>的文本</li></ul><p>除了这些方法，还可以通过<code>length</code>属性获取文本节点中包含的字符数量。这个值等于<code>nodeValue.length</code>和<code>data.length</code>。</p><p>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;div&gt;&lt;/div&gt;
&lt;!-- 没有内容，因此没有文本节点 --&gt;

&lt;div&gt;&lt;/div&gt;
&lt;!-- 有空格，因此有一个文本节点 --&gt;

&lt;div&gt;Hello World!&lt;/div&gt;
&lt;!-- 有内容，因此有一个文本节点 --&gt;</code>
        </deckgo-highlight-code><p>示例中的第一个<code>&lt;div&gt;</code>元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code>&lt;div&gt;</code>元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的<code>nodeValue</code>就是一个空格。第三个<code>&lt;div&gt;</code>元素也有一个文本节点的子节点，其<code>nodeValue</code>的值为<code>Hello World!</code>。下列代码可以用来访问这个文本节点：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const textNode = div.firstChild // 或div.childNodes[0]
div.firstChild.nodeValue = &#x27;some other message&#x27;</code>
        </deckgo-highlight-code><p>只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点需要注意，就是 HTML 或者 XML 代码会被转换成实体编码，即小于号、大于号或者引号会被转义：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">div.firstChild.nodeValue = &#x27;Some &lt;strong&gt;other&lt;/strong&gt; message&#x27;</code>
        </deckgo-highlight-code><p>这实际上是将 HTML 插入 DOM 文档前进行编码的有效方式。</p><p>使用<code>document.createTextNode()</code>可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有的文本节点的值一样，这些要插入的文本也会应用 HTML 或者 XML 编码。例如：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const textNode = document.createTextNode(&#x27;&lt;strong&gt;Hello&lt;/strong&gt; world!&#x27;)</code>
        </deckgo-highlight-code><p>创建文本节点后，其<code>ownerDocument</code>属性会被设置为<code>document</code>。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const element = document.createElement(&#x27;div&#x27;)
element.className = &#x27;message&#x27;

const textNode = document.createTextNode(&#x27;Hello World!&#x27;)
element.appendChild(textNode)

document.body.appendChild(element)</code>
        </deckgo-highlight-code><p>这个例子首先创建了一个<code>&lt;div&gt;</code>元素并给它添加了值为<code>message</code>的<code>class</code>属性，然后创建了一个文本节点并且添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。</p><p>一般来说一个元素只包含一个文本子节点。不过也可以染个元素包含多个文本子节点。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const element = document.createElement(&#x27;div&#x27;)
element.className = &#x27;message&#x27;

const textNode = document.createTextNode(&#x27;Hello World&#x27;)
element.appendChild(textNode)

const anotherTextNode = document.createTextNode(&#x27;Yippe!&#x27;)
element.appendChild(anotherTextNode)

document.body.appendChild(element)</code>
        </deckgo-highlight-code><p>将一个文本节点作为另一个文本节点的同胞插入之后，两个文本节点之间不会包含空格。</p><p>DOM 文档中的同胞文本节点可能导致困惑。因为一个文本节点足以表示一个文本字符串。同样，DOM 文档中也经常出现两个相邻文本节点。为此有一个方法可以合并相邻的文本节点。这个方法叫做<code>normalize()</code>，是在<code>Node</code>类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或者多个相邻文本节点的父节点上调用<code>normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的<code>nodeValue</code>就等于之前所有同胞节点<code>nodeValue</code>拼接在一起的到的字符串。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const element = document.createElement(&#x27;div&#x27;)
element.className = &#x27;message&#x27;

const textNode = document.createTextNode(&#x27;Hello World!&#x27;)
element.appendChild(textNode)

const anotherTextNode = document.createTextNode(&#x27;Yippee!&#x27;)
element.appendChild(anotherTextNode)

document.body.appendChild(element)

alert(element.childNodes.length) // 2
element.normalize()
alert(element.childNodes.length) // 1
alert(element.firstChild.nodeValue) // &#x27;Hello World!Yippee!&#x27;</code>
        </deckgo-highlight-code><p>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 DOM 脚本生成的文档树中。</p><p><code>Text</code>类型定义了一个与<code>normalize()</code>相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分<code>nodeValue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的<code>parentNode</code>。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const element = document.createElement(&#x27;div&#x27;)
element.className = &#x27;message&#x27;

const textNode = document.createTextNode(&#x27;hello world&#x27;)
element.appendChil(textNode)

document.body.appendChild(element)

const newNode = element.firstChild.splitText(5)</code>
        </deckgo-highlight-code><p>这个例子中，包含<code>hello world</code>的文本节点被从位置<code>5</code>拆分成两个文本节点。位置<code>5</code>对应<code>hello</code>和<code>world</code>之间的空格。拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。</p><h2><code>Comment</code>类型</h2><p>DOM 中的注释通过<code>Comment</code>类型表示。<code>Comment</code>类型节点具有以下特征：</p><ul><li><code>nodeType</code>等于 8</li><li><code>nodeName</code>值为<code>#comment</code></li><li><code>nodeValue</code>值为注释的内容</li><li><code>parentNode</code>值为<code>Document</code>或者<code>Element</code>对象</li><li>不支持子节点</li></ul><p><code>Comment</code>类型与<code>Text</code>类型继承同一个基类（<code>CharacterDatat</code>），因此拥有除<code>splitText()</code>之外<code>Text</code>节点所有的字符串操作方法。和<code>Text</code>类型相似，注释的实际内容可以通过<code>nodeValue</code>或者<code>data</code>属性获得。注释节点可以作为父节点的子节点来访问。例如：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;div id=&quot;myDiv&quot;&gt;
  &lt;!-- A comment --&gt;
&lt;/div&gt;</code>
        </deckgo-highlight-code><p>这里的注释是<code>&lt;div&gt;</code>元素的子节点，这意味着可以像下面这样访问它：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const div = document.getElementById(&#x27;myDiv&#x27;)
const comment = div.firstChild
alert(comment.data) // &#x27;A comment&#x27;</code>
        </deckgo-highlight-code><p>可以通过<code>document.createComment()</code>方法创建注释节点，参数为注释文本。显然，注释节点很少通过 JavaScript 创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的<code>&lt;/html&gt;</code>之后的注释。如果要访问注释节点，必须确定它们是<code>&lt;html&gt;</code>元素的后代。</p><h2><code>DocumentType</code>类型</h2><p><code>DocumentType</code>类型的节点包含文档的文档类型（<code>doctype</code>）信息，具有以下特征：</p><ul><li><code>nodeType</code>等于 10</li><li><code>nodeName</code>值为文档类型的名称</li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>Document</code>对象</li><li>不支持子节点</li></ul><p><code>DocumentType</code>对象在 DOM Level1 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，<code>DocumentType</code>对象保存在<code>document.doctype</code>属性中。DOM Level1 规定了<code>DocumentType</code>对象的 3 个属性：<code>name</code>、<code>entities</code>和<code>notations</code>。其中，<code>name</code>是文档类型的名称，<code>entities</code>是这个文档类型描述的实体的<code>NamedNodeMap</code>，而<code>notations</code>是这个文档类型描述的表示法的<code>NamedNodeMap</code>。因为浏览器中的文档通常是 HTML 或者 XHTML 文档类型，所以<code>entites</code>和<code>notations</code>列表为空。无论如何，只有<code>name</code>属性是有用的。这个属性包含文档类型的名称，即紧跟在<code>&lt;!DOCTYPE</code>后面的那串文本。</p><h2><code>DocumentFragment</code>类型</h2><p>在所有节点类型中，<code>DocumentFragment</code>类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。<code>DocumentFragment</code>节点具有以下特征：</p><ul><li><code>nodeType</code>等于 11</li><li><code>nodeName</code>值为<code>#document-fragment</code></li><li><code>nodeValue</code>值为<code>null</code></li><li><code>parentNode</code>值为<code>null</code></li><li>子节点可以是<code>Element</code>、<code>ProcessingInstruction</code>、<code>Comment</code>、<code>Text</code>、<code>CDATASection</code>或者<code>EntityReference</code></li></ul><p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用<code>document.createDocumentFragement()</code>方法创建文档片段。</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const fragment = document.createDocumentFragment()</code>
        </deckgo-highlight-code><p>文档片段从<code>Node</code>类型继承了所有文档类型具备的可以执行 DOM 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过<code>appendChild()</code>或者<code>insertBefore()</code>方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;</code>
        </deckgo-highlight-code><p>假设想要给这个<code>&lt;ul&gt;</code>元素添加三个列表项。如果分 3 次给这个元素添加列表项，浏览器就要重新渲染 3 次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了<code>&lt;ul&gt;</code>元素：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const fragment = document.createDocumentFragment()
const ul = document.getElementById(&#x27;myList&#x27;)

for (let i = 0; i &lt; 3; i++) {
  const li = document.createElement(&#x27;li&#x27;)
  li.appendChild(document.createTextNode(`Item ${i + 1}`))
  fragment.appendChild(li)
}

ul.appendChild(fragment)</code>
        </deckgo-highlight-code><p>这个例子先创建了一个文档片段，然后取得了<code>&lt;ul&gt;</code>元素的引用。接着通过<code>for</code>循环创建了 3 个列表项，每一项都包含表明自己身份的文本。为此创建<code>&lt;li&gt;</code>元素，再创建文本节点并添加到该元素。然后通过<code>appendChild()</code>把<code>&lt;li&gt;</code>元素添加到文档片段。循转结束后，将文档片段传给<code>appendChild()</code>将所有列表添加到了<code>&lt;ul&gt;</code>元素。此时文档片段的子节点全部被转移到了<code>&lt;ul&gt;</code>元素。</p><h2><code>Attr</code>类型</h2><p>元素数据在 DOM 中通过<code>Attr</code>类型表示。<code>Attr</code>类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素<code>attributes</code>属性中的节点。虽然属性节点也是节点，但是却不被认为是 DOM 文档树的一部分。</p><blockquote><p><code>Attr</code>节点几乎不使用，因为将属性作为节点来访问多数情况下并无必要。推荐使用<code>getAttribute()</code>、<code>removeAttribute()</code>和<code>setAttribute()</code>方法操作属性，而不是直接操作属性节点。</p></blockquote><h1>DOM 编程</h1><p>很多时候，操作 DOM 是很直观的。通过 HTML 代码能实现的，也一样可以通过 JavaScript 实现。但有些时候，DOM 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 DOM 的某些方面会复杂一些。</p><h2>动态脚本</h2><p><code>&lt;script&gt;</code>元素用于向网页中插入 JavaScript 代码，可以是<code>src</code>属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。与对应的 HTML 元素一样，有两种方式通过<code>&lt;script&gt;</code>动态为网页添加脚本：引入外部文件和直接插入源代码。</p><p>动态加载外部文件很容易实现，例如下面的<code>&lt;script&gt;</code>元素：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt;</code>
        </deckgo-highlight-code><p>可以像这样通过 DOM 编程创建这个节点：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const script = document.createElement(&#x27;script&#x27;)
script.src = &#x27;foo.js&#x27;
document.body = appendChild(script)</code>
        </deckgo-highlight-code><p>注意，在上面最后一样把<code>&lt;script&gt;</code>元素添加到页面之前，是不会开始下载外部文件的。当然也可以将其添加到<code>&lt;head&gt;</code>元素，同样可以实现动态脚本加载。这个过程可以封装为：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">function loadScript(url) {
  const script = document.createElement(&#x27;script&#x27;)
  script.src = url
  documend.body.appendChild(script)
}

// 可以加载外部JavaScript文件
loadScript(&#x27;client.js&#x27;)</code>
        </deckgo-highlight-code><p>加载之后这个脚本就可以对页面执行操作了。这里有个问题：怎么知道脚本什么时候加载完？这个问题并没标准答案。具体情况取决于使用的浏览器。</p><p>另一个动态插入 JavaScript 的方式是嵌入源代码：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const script = document.createElment(&#x27;script&#x27;)
script.appendChild(document.createTextNode(&#x27;function sayHi() {alert(&quot;hi&quot;)}&#x27;))
document.body.appendChild(script)</code>
        </deckgo-highlight-code><h2>动态样式</h2><p>CSS 样式在 HTML 页面中可以通过两个元素加载。<code>&lt;link&gt;</code>元素用于包含 CSS 外部文件，而<code>&lt;style&gt;</code>元素用于添加嵌入样式。和动态脚本类似，动态样式是页面初始加载时并不存在，而是在之后才添加到页面中的。</p><p>来看下面这个典型的<code>&lt;link&gt;</code>元素：</p><deckgo-highlight-code language="html" theme="one-dark">
          <code slot="code">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt;</code>
        </deckgo-highlight-code><p>这个元素很容易使用 DOM 编程创建出来：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const link = document.createElement(&#x27;link&#x27;)
link.rel = &#x27;stylesheet&#x27;
link.type = &#x27;text/css&#x27;
link.href = &#x27;styles.css&#x27;
let head = document.getElementByTagName(&#x27;head&#x27;)[0]
head.appendChild(link)</code>
        </deckgo-highlight-code><p>通过外部文件加载样式是一个异步过程。因此样式的加载和正执行的 JavaScript 代码并没有先后顺序。一般来说，也没有必要知道样式什么时候加载完成。另一种定义样式的方式是使用<code>&lt;script&gt;</code>元素包含嵌入的 CSS 规则，此处不赘述。</p><h2>使用<code>NodeList</code></h2><p><strong>理解<code>NodeList</code>对象和相关的<code>NamedNodeMap</code>、<code>HTMLCollection</code></strong>，是理解 DOM 编程的关键。这三个集合类型都是“实时的”，因为文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，<strong><code>NodeList</code>就是基于 DOM 文档的实时查询</strong>。例如，下面的代码会陷入死循环：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const divs = document.getElementsByTagName(&#x27;div&#x27;)

for (let i = 0; i &lt; divs.length; i++) {
  const div = document.createElement(&#x27;div&#x27;)
  document.body.appendChild(div)
}</code>
        </deckgo-highlight-code><p>以上代码中<code>divs</code>是包含文档中所有<code>div</code>元素的<code>HTMLCollection</code>。因为这个集合是“实时的”，所以任何时候向页面中添加一个新的<code>div</code>元素，这个查询集合就会多一项，因为浏览器不希望保存每次创建的集合，就会在每次访问时更新集合。这样就会出现以上问题。</p><p>使用 ES6 迭代器也不会解决这个问题，因为迭代的是一个永远增长的实时集合，以下代码仍然会导致死循环：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">for (const div of document.getElementsByTagName(&#x27;div&#x27;)) {
  const newDiv = document.createElement(&#x27;div&#x27;)
  document.body.appendChild(newDiv)
}</code>
        </deckgo-highlight-code><p>任何时候要迭代<code>NodeList</code>，最好再初始化一个保存变量保存当时查询时的长度，然后用循环变量与这个变量进行比较，例如：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const divs = document.getElementsByTagName(&#x27;div&#x27;)

for (let i = 0, len = divs.length; i &lt; len; i++) {
  const div = document.createElement(&#x27;div&#x27;)
  document.body.appendChild(div)
}</code>
        </deckgo-highlight-code><p>在这个例子中，又初始化了一个保存集合长度的变量<code>len</code>。因为<code>len</code>保存着循环开始时集合的长度，而这个值不会随着集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。</p><p>一般来说，最好限制操作<code>NodeList</code>的次数，因为每次访问这个对象都会触发一次新的查询，会搜索整个文档。因此最好把查询到的<code>NodeList</code>缓存起来。</p><h1><code>MutationObserver</code>接口</h1><p>不久前添加到 DOM 规范中的<code>MutationObserver</code>接口，可以在 DOM 被修改时异步执行回调。使用<code>MutationObserver</code>可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p><blockquote><p>新引进<code>MutationObserver</code>接口是为了取代废弃的<code>MutationEvent</code>。</p></blockquote><h2>基本用法</h2><p><code>MutationObserver</code>的实例要通过调用<code>MutationObserver</code>构造函数并传入一个回调函数来创建：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const observer = new MutationObserver(() =&gt; console.log(&#x27;DOM was mutated!&#x27;))</code>
        </deckgo-highlight-code><p>一个新建的<code>MutationObserver</code>实例不会关联 DOM 的任何部分。要把这个<code>observer</code>和 DOM 关联起来，需要使用<code>observer()</code>方法。这个方法接收两个必须的参数：需要观察其变化的 DOM 节点，以及一个<code>MutationObserverInit</code>对象。</p><p><code>MutationObserverInit</code>对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。例如，下面的代码会创建一个观察<code>observer</code>）并配置它观察<code>&lt;body&gt;</code>元素上的属性变化：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const observer = new MutationObserver(() =&gt;
  console.log(&#x27;&lt;body&gt; attributes changed&#x27;)
)
observer.observe(document.body, { attributes: true })</code>
        </deckgo-highlight-code><p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个<code>MutationObserver</code>实例发现，然后就会异步执行注册的回调函数。<code>&lt;body&gt;</code>元素后代的修改或者其他非属性修改都不会触发回调进入任务队列。可以通过以下代码验证：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const observer = new MutationObserver(() =&gt;
  console.log(&#x27;&lt;body&gt; attributes changed&#x27;)
)

observer.observe(document.body, { attributes: true })
document.body.className = &#x27;foo&#x27;</code>
        </deckgo-highlight-code><p>每个回调都会收到一个<code>MutationRecord</code>实例的数组。<code>MutationRecord</code>实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分收到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的<code>MutationRecord</code>实例的数组。<code>MutationRecord</code>实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的<code>MutationRecord</code>实例的数组。</p><p>默认情况下，只要被观察的元素不被垃圾回收，<code>MutationObserver</code>的回调就会响应 DOM 变化事件，从而被执行。要提前终止执行回调，可以调用<code>disconnect()</code>方法。下面的例演示了同步调用<code>disconnect()</code>之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p><deckgo-highlight-code language="javascript" theme="one-dark">
          <code slot="code">const observer = new MutationObserver(() =&gt;
  console.log(&#x27;&lt;body&gt; attributes changed&#x27;)
)

observer.observe(document.body, { attributes: true })
document.body.className = &#x27;foo&#x27;
observer.disconnect()
document.body.className = &#x27;bar&#x27;
// 没有日志输出</code>
        </deckgo-highlight-code><p>多次调用<code>observe()</code>方法可以敷用一个<code>MutationObserver</code>对象观察多个不同的目标节点。此时<code>MutationRecord</code>的<code>target</code>属性可以标识发生变化事件的目标节点。并且调用<code>disconnect()</code>并不会结束<code>MutationObserver</code>的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。</p><p><code>MutationObserverInit</code>对象用于控制对目标节点的观察范围。粗略来讲，观察者可以观察的事件包括属性的变化、文本变化和子节点变化。</p><blockquote><p>注意在调用<code>observe</code>时，<code>MutationObserverInit</code>对象中的<code>attribute</code>、<code>characterData</code>和<code>childList</code>属性必须至少有一项为<code>true</code>，否者会抛出错误，因为没有任何变化事件可能会触发回调。</p></blockquote><h2>异步回调与记录队列</h2><p><code>MutationObserver</code>接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件时不影响性能，每次变化的信息（由观察者实例决定）会保存在<code>MutationRecord</code>实例中，然后添加到<strong>记录队列</strong>。这个队列对每个<code>MutationObserver</code>实例都是唯一的，是所有 DOM 变化事件的有序列表。</p><p>每次<code>MutationRecord</code>被添加到<code>MutationObserver</code>的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化<code>MutationObserver</code>时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p><p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个<code>MutationRecord</code>实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实例就不存在了。回调执行后，这些<code>MutationRecord</code>就用不着了，因此记录队列会被清空，其内容会被丢弃。</p><blockquote><p>注意，<code>MutationObserver</code>会将回调推入微任务队列，而不是宏任务队列！</p></blockquote><h2>性能、内存与垃圾回收</h2><p>DOM Level 2 规范中描述的<code>MutationEvent</code>定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此 DOM Level 3 规定废弃了这些事件。<code>MutationObserver</code>接口就是为了替代这些事件而设计的更实用、性能更好的方案。</p><p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为<code>MutationObserver</code>而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。但是使用<code>MutationObserver</code>仍然<strong>不是没有代价的</strong>。因此理解什么时候避免出现这种情况很重要。</p><p><code>MutationObserver</code>实例和目标节点之间的引用关系是非对称的。<code>MutationObserver</code>拥有对要观察的目标节点的弱引用。因为是弱引用所以不会妨碍垃圾回收程序回收目标节点。然而，目标节点却拥有对<code>MutationObserver</code>的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，那么关联的<code>MutationObserver</code>也会被垃圾回收。</p><p>记录队列中的每个<code>MutationRecord</code>实例至少包含对已经 DOM 节点的一个引用。如果变化是<code>childList</code>类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个<code>MutationRecord</code>，然后让它们超出作用域并被垃圾回收。</p><p>有时候可能需要保存某个观察者的完整变化记录。保存这些<code>MutationRecord</code>实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快释放内存，建议从每个<code>MutationRecord</code>中抽取最有用的信息，然后保存到一个新对象中，最后抛弃<code>MutationRecord</code>。</p><h1>总结</h1><p>文档对象模型 DOM 是语言中立的 HTML 和 XML 文档的 API。DOM Level 1 将 HTML 和 XML 定义为一个节点的多层级结构，并暴露出 JavaScript 接口以操作文档的底层结构和外观。DOM 由一系列节点类型构成，主要包括：</p><ul><li><code>Node</code>是基准节点类型，是文档一个部分的抽象表示，其他类型都继承自<code>Node</code>。</li><li><code>Document</code>类型表示整个文档，对应树形结构的根节点。在 JavaScript 中，<code>document</code>对象是<code>Document</code>的实例，拥有查询和获取节点的很多方法。</li><li><code>Element</code>节点表示文档中所有 HTML 或者 XML 元素，可以用来操作它们的内容和属性。</li><li>其他节点类型分别表示文本内容、注释、文档类型、CDATA 区块和文档片段。</li></ul><p>DOM 编程在多数情况下没什么问题，在涉及<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素时会有一些兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们和其他元素区别对待。</p><p>要理解 DOM，最关键的一点是知道影响其性能的问题所在。DOM 操作在 JavaScript 代码中是代价高昂的，<code>NodeList</code>对象尤其需要注意。<code>NodeList</code>对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 DOM 操作的数量。</p><p><code>MutationObserver</code>是为替代性能不好的<code>MutationEvent</code>而问世的。使用它可以有效精准地监控 DOM 变化，而且 API 也相对简单。</p></article><div class="foot-post-navigator"><button class="previous " style="visibility:visible"><div><span role="img" aria-label="left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></span>上一篇</div><span>（十一）期约与异步函数</span></button><button class="next " style="visibility:visible"><div>下一篇<span role="img" aria-label="right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span>（十五）DOM扩展</span></button></div><div id="commentBoxScript"></div></main></main><div class="table-of-content"><div class="table-of-content-header"></div><div class="table-of-content-main"></div></div><div class="table-of-content-switch"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></main><footer class="footer"><div class="wrapper"><div><h3>Thanks for reading!</h3><p>CopyRight © 2022 Louis K - Present</p></div><div><p style="font-size:1.3rem"><span><span role="img" aria-label="wechat" class="anticon anticon-wechat"><svg viewBox="64 64 896 896" focusable="false" data-icon="wechat" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M690.1 377.4c5.9 0 11.8.2 17.6.5-24.4-128.7-158.3-227.1-319.9-227.1C209 150.8 64 271.4 64 420.2c0 81.1 43.6 154.2 111.9 203.6a21.5 21.5 0 019.1 17.6c0 2.4-.5 4.6-1.1 6.9-5.5 20.3-14.2 52.8-14.6 54.3-.7 2.6-1.7 5.2-1.7 7.9 0 5.9 4.8 10.8 10.8 10.8 2.3 0 4.2-.9 6.2-2l70.9-40.9c5.3-3.1 11-5 17.2-5 3.2 0 6.4.5 9.5 1.4 33.1 9.5 68.8 14.8 105.7 14.8 6 0 11.9-.1 17.8-.4-7.1-21-10.9-43.1-10.9-66 0-135.8 132.2-245.8 295.3-245.8zm-194.3-86.5c23.8 0 43.2 19.3 43.2 43.1s-19.3 43.1-43.2 43.1c-23.8 0-43.2-19.3-43.2-43.1s19.4-43.1 43.2-43.1zm-215.9 86.2c-23.8 0-43.2-19.3-43.2-43.1s19.3-43.1 43.2-43.1 43.2 19.3 43.2 43.1-19.4 43.1-43.2 43.1zm586.8 415.6c56.9-41.2 93.2-102 93.2-169.7 0-124-120.8-224.5-269.9-224.5-149 0-269.9 100.5-269.9 224.5S540.9 847.5 690 847.5c30.8 0 60.6-4.4 88.1-12.3 2.6-.8 5.2-1.2 7.9-1.2 5.2 0 9.9 1.6 14.3 4.1l59.1 34c1.7 1 3.3 1.7 5.2 1.7a9 9 0 006.4-2.6 9 9 0 002.6-6.4c0-2.2-.9-4.4-1.4-6.6-.3-1.2-7.6-28.3-12.2-45.3-.5-1.9-.9-3.8-.9-5.7.1-5.9 3.1-11.2 7.6-14.5zM600.2 587.2c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9c0 19.8-16.2 35.9-36 35.9zm179.9 0c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9a36.08 36.08 0 01-36 35.9z"></path></svg></span></span><span><span role="img" aria-label="qq-circle" class="anticon anticon-qq-circle"><svg viewBox="64 64 896 896" focusable="false" data-icon="qq-circle" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm210.5 612.4c-11.5 1.4-44.9-52.7-44.9-52.7 0 31.3-16.2 72.2-51.1 101.8 16.9 5.2 54.9 19.2 45.9 34.4-7.3 12.3-125.6 7.9-159.8 4-34.2 3.8-152.5 8.3-159.8-4-9.1-15.2 28.9-29.2 45.8-34.4-35-29.5-51.1-70.4-51.1-101.8 0 0-33.4 54.1-44.9 52.7-5.4-.7-12.4-29.6 9.4-99.7 10.3-33 22-60.5 40.2-105.8-3.1-116.9 45.3-215 160.4-215 113.9 0 163.3 96.1 160.4 215 18.1 45.2 29.9 72.8 40.2 105.8 21.7 70.1 14.6 99.1 9.3 99.7z"></path></svg></span></span><span><a href="mailto:k1664032884@gmail.com"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></span><span><a href="https://github.com/kqhasaki" target="_blank" rel="noopener noreferrer"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></span></p></div></div></footer></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/redbook-series/redbook-chapter14";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a6a9e8476add1045c345.js"],"app":["/app-cb8cf455a629701e7063.js"],"component---src-pages-404-js":["/component---src-pages-404-js-8f4b283686f95500832f.js"],"component---src-pages-about-js":["/component---src-pages-about-js-f8f16069eaaefaa5c6f9.js"],"component---src-pages-non-tech-js":["/component---src-pages-non-tech-js-89e7bc9937558a205dc4.js"],"component---src-templates-blog-list-js":["/component---src-templates-blog-list-js-73a188e2a6f7327575df.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-cf95b4debfeb2c79909f.js"]};/*]]>*/</script><script src="/polyfill-a6a9e8476add1045c345.js" nomodule=""></script><script src="/component---src-templates-blog-post-js-cf95b4debfeb2c79909f.js" async=""></script><script src="/commons-63439ea553d45328beab.js" async=""></script><script src="/cb1608f2-cc8649749445c1088879.js" async=""></script><script src="/app-cb8cf455a629701e7063.js" async=""></script><script src="/framework-f27b074ecebec0f1dbc4.js" async=""></script><script src="/webpack-runtime-fb9925dca62e4624cbf8.js" async=""></script></body></html>