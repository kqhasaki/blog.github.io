<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.38fc3de9caeb0eeaed43.css" data-identity="gatsby-global-css">.modal-wrapper{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background:rgba(0,0,0,.6);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1000}.modal-content-wrapper::-webkit-scrollbar{width:0}.modal-content{background:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:1rem;max-width:1080px;min-width:600px;padding:1.5rem;position:relative;width:50vw}.modal-content-wrapper{max-height:70vh;min-height:50vh;overflow-y:auto;width:100%}.modal-closer{cursor:pointer;font-size:1.2rem;position:absolute;right:.8rem;top:.8rem}.modal-closer:hover{color:var(--blue)}@media (max-width:900px){.modal-content{min-width:90%;width:90%}}.post-card-img{background-color:var(--background-color);border-radius:12px;bottom:0;box-shadow:0 0 6px rgba(0,0,0,.15);height:200px;left:50%;-o-object-fit:cover;object-fit:cover;position:absolute;-webkit-transform:translate(-50%) rotate(-8deg);transform:translate(-50%) rotate(-8deg);transition:.2s;width:300px}.img-line{height:120px;margin-bottom:2rem;position:relative}.post-card{align-items:center;border:1px solid var(--card-background-border-color);border-radius:1.5rem;cursor:pointer;display:flex;flex-direction:column;justify-content:center;margin:140px auto 0;max-width:45rem;padding:1.5rem 2rem;transition:.2s}.post-card:hover{box-shadow:0 0 1rem var(--card-box-shadow)}.post-card:active{box-shadow:0 0 1.5rem var(--blue)}.post-card:hover .post-card-img{-webkit-transform:translate(-50%) rotate(0deg);transform:translate(-50%) rotate(0deg)}.post-card h2:after{background:var(--blue);content:"";display:block;height:2px;margin-left:auto;margin-right:auto;margin-top:10px;width:60px}.post-card-meta{background-color:var(--card-background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;font-size:.9rem;font-weight:300;margin:1rem 0 0;padding:.5rem 1rem}@media (max-width:500px){.post-card{padding:1.5rem .8rem}}.item-list{align-items:center;border-left:3px solid var(--blue);display:flex;flex-direction:column;justify-content:center;margin:0 auto 0 1rem}.item-list .item{margin:0;padding:1rem;position:relative;width:100%}.item:before{background-color:var(--blue);border-radius:50%;content:"";height:.8rem;left:-.5rem;position:absolute;top:2rem;transition:.2s;width:.8rem}.item:hover:before{-webkit-transform:scale(1.2);transform:scale(1.2)}.item-list .item-label{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.item-list .item-content{padding-top:.5rem}.homepage-title{font-weight:700;margin:2rem 0 1rem}.item a{transition:.3s}.item a:hover{color:var(--font-color-highlight)}.messager{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:.5rem;box-shadow:0 0 .8rem var(--card-box-shadow);left:0;margin-left:auto;margin-right:auto;max-width:200px;padding:.5rem 1rem;position:fixed;right:0;text-align:center;top:1rem;-webkit-transform:scale(.2);transform:scale(.2);transition:.2s;z-index:999}.avatar{align-items:center;display:flex;flex-direction:row;height:8rem;justify-content:center}.avatar>img{border-radius:50%;box-shadow:0 0 4px rgba(0,0,0,.1);max-height:100%;-o-object-fit:cover;object-fit:cover;-o-object-position:center center;object-position:center center;opacity:1;padding:.5rem;transition:none 0s ease 0s}.footer{border-top:1px solid var(--card-background-border-color);color:var(--font-color);display:flex;flex-direction:row;font-size:13px;justify-content:space-evenly;margin-top:10rem;padding:2rem 0 8rem;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}.footer .wrapper{align-items:flex-start;display:flex;flex-direction:column;font-family:sans-serif;padding-left:.5rem;padding-right:1rem;width:50%}h3,ul{width:100%}h3{color:var(--font-color);margin-bottom:8px}.footer p{line-height:1.2rem;margin:0;padding:.5rem 0}.footer span{color:var(--font-color);cursor:pointer;margin-right:12px}.wrapper li{padding:4px 0}.footer span:hover{color:var(--font-color-highlight)}@media (max-width:600px){.footer{flex-direction:column}.footer .wrapper{margin-bottom:1rem;width:100%}}:root{--deckgo-highlight-code-font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}@media (prefers-color-scheme:dark){body{--blue:#02bbff;--background-color:#202124;--background-color-transparent:rgba(0,0,0,.9);--font-color:#bdc1c6;--font-color-header:#eaeaea;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#c678dd;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:rgba(0,0,0,.1);--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030}}@media (prefers-color-scheme:light){body{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#3c4043;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#313131;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed}}.dark{--blue:#02bbff;--background-color:#202124;--background-color-transparent:rgba(0,0,0,.9);--font-color:#bdc1c6;--font-color-header:#eaeaea;--font-color-highlight:#efefef;--btn-color:#333;--card-background-color:#222;--quote-background-color:#242424;--font-color-quote:#bdcbdc;--card-background-border-color:#2a2a2a;--card-box-shadow:#333;--code-font-color:#c678dd;--code-background-color:rgba(0,0,0,.1);--code-border-color:rgba(0,0,0,.02);--code-block-background:rgba(0,0,0,.1);--navigator-hover-color:hsla(0,0%,100%,.1);--navigator-border-color:#222;--table-border-color:#303030}.light{--blue:#02bbff;--background-color:#fff;--background-color-transparent:hsla(0,0%,100%,.9);--font-color:#3c4043;--font-color-header:#3c4043;--btn-color:#fff;--card-background-color:#efefef;--card-background-border-color:#efefef;--quote-background-color:#eaf8ff;--font-color-highlight:#000;--font-color-quote:#555;--card-box-shadow:rgba(0,0,0,.1);--code-font-color:#444;--code-background-color:rgba(255,229,100,.2);--code-border-color:rgba(255,229,100,.2);--code-block-background:#313131;--navigator-hover-color:rgba(0,0,0,.08);--navigator-border-color:#ddd;--table-border-color:#ededed}body,html{background-color:var(--background-color);color:var(--font-color);font-family:Arial,Helvetica,sans-serif}a{color:inherit;text-decoration:none}*{-webkit-tap-highlight-color:rgba(0,0,0,0);border:none;box-sizing:border-box;list-style-type:none;margin:0;padding:0}ol{margin:.7rem 0}ol li{list-style-type:decimal;margin:.6rem 0 .6rem 2rem}p{-webkit-margin-before:1em;-webkit-margin-after:1em;-webkit-margin-start:0;-webkit-margin-end:0;display:block;line-height:1.7;margin-block-end:1em;margin-block-start:1em;margin-bottom:.7rem;margin-inline-end:0;margin-inline-start:0;margin-top:.7rem}::selection{background-color:var(--blue);color:#fff}body{word-wrap:break-word;font-kerning:normal;margin:0;padding:0}header{align-items:center;display:flex;flex-direction:row;justify-content:space-around;padding-bottom:0}header>.route-link{margin:0 1rem}header img{box-shadow:0 0 .2rem rgba(0,0,0,.5)}.base-wrapper{margin-left:auto;margin-right:auto;max-width:1080px;min-height:100%;padding:2.625rem 1.3125rem;width:60%}.nav-link{align-items:center;color:var(--font-color);cursor:pointer;display:flex;flex-direction:column;font-size:2.2rem;justify-content:center;margin:0 1rem;min-width:3rem}.nav-link>img{border-radius:50%;height:2.2rem;-webkit-transform:scale(1.2);transform:scale(1.2)}.nav-link:hover{color:var(--blue);text-decoration:none}.nav-link:hover .link-label{-webkit-transform:scaleY(1);transform:scaleY(1)}.nav-link .link-label{bottom:-24px;display:block;font-size:.9rem;padding-top:6px;text-align:center;-webkit-transform:scaleY(0);transform:scaleY(0);transition:.2s;width:8rem}.link-active{color:var(--blue)}.article-body .article-title{font-size:2.2rem;font-weight:700;margin-bottom:2rem;text-align:center}.article-body strong{color:var(--font-color-highlight)}.article-meta{font-size:.9rem;margin:1rem auto 1.5rem;text-align:center}.article-meta>span{background-color:var(--card-background-color);border-radius:.5rem;font-weight:lighter;padding:.5rem 1rem}.article-body h1,h2,h3{cursor:pointer}.article-body p{font-size:17px;margin-bottom:1.2rem;margin-top:1.2rem}.article-body h1{color:var(--font-color-header);font-size:2rem;font-weight:700;margin-bottom:1.8rem;margin-top:3.5rem}.article-body h1 code{font-size:2rem}.article-body h2{color:var(--font-color-header);font-size:1.6rem;font-weight:700;margin-bottom:1rem;margin-top:2.5rem}.article-body h2 code{font-size:1.5rem}.article-body h3{color:var(--font-color-header);font-size:1.4rem;font-weight:700;line-height:1.8;margin-bottom:1rem;margin-top:1.8rem}.article-body h3 code{font-size:1.2rem;font-weight:700}.article-body h4{color:var(--font-color-header);font-weight:500;margin-bottom:1rem;margin-top:1.5rem}.article-body h4 code{font-size:1rem}.article-body h1:first-child{border-radius:.5rem}.article-body h1:not(:first-child):before{margin-bottom:.5rem}.article-body h1:not(:first-child):before,.article-body h2:before{background:var(--blue);content:"";display:block;height:2px;width:70px}.article-body h2:before{margin-bottom:.3rem}.article-body code{background-color:var(--code-background-color);border:1px solid var(--code-border-color);border-radius:4px;color:var(--code-font-color);font-family:Menlo,Monaco,Consolas,monospace;font-size:15px;margin:0 2px;padding:1px 4px}.article-body blockquote{background-color:var(--quote-background-color);border-left:2px solid var(--blue);border-radius:0 .5rem .5rem 0;color:var(--font-color-quote);margin-top:1rem;padding:1rem}.article-body blockquote code{color:var(--code-font-color)}.article-body .article-cover{border-radius:16px;box-shadow:0 0 1px rgba(0,0,0,.1);margin:18px auto 20px;width:80%}.article-body .article-cover,.article-body img{display:block;min-width:330px;-o-object-fit:cover;object-fit:cover}.article-body img{border-radius:12px;margin:18px auto;width:85%}.article-body ul{margin:.7rem 0}.article-body ul li{list-style-type:disc;margin:.6rem 0 .6rem 2rem}.article-body a{color:#189fff}a:hover{text-decoration:underline}.article-body a:after{content:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMSIgaGVpZ2h0PSIxMSIgY2xhc3M9InByZWZpeF9faWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCI+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTkyNC40MDIgMTAyMy4wNjhILjY4Vjk5LjM0NUg0NjIuNTR2OTguOTFIOTkuNTk3VjkyNC4xNWg3MjUuODk2VjU2MS4yMDdoOTguOTF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0ibTkzMC44MDUgMjIuOTc3IDY5Ljk2NiA2OS45NjYtNDUzLjQ5MyA0NTMuNDkyLTY5Ljk2NS02OS45MDF6Ii8+PHBhdGggZmlsbD0iIzE4OWZmZiIgZD0iTTEwMjIuNDY0IDMwNC4wM2gtOTguOTE3Vjk5LjM0NUg3MDkuMjMxVi40MjhoMzEzLjIzM3oiLz48L3N2Zz4=);padding-left:2px}.article-body table{word-wrap:normal;border-collapse:collapse;table-layout:fixed;width:100%}th{background-color:rgba(0,0,0,.06);text-align:center}td{background-color:hsla(0,0%,100%,.01);font-weight:300}table,td,th{border:1px solid var(--table-border-color);overflow:auto;padding:.5rem}.theme-changer{border-radius:50%;bottom:1rem;cursor:pointer;position:fixed;right:1rem}.theme-changer img{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;height:30px;padding:6px;width:30px}deckgo-highlight-code{background-color:var(--code-block-background);border-radius:.5rem;box-shadow:none!important;cursor:pointer;font-size:14px;margin-top:1rem;position:relative;-webkit-user-select:none;-ms-user-select:none;user-select:none}@media (min-width:900px){deckgo-highlight-code:after{content:"双击复制";font-size:11px;height:2rem;opacity:0;position:absolute;right:1rem;text-align:center;top:1rem;transition:.4s;width:4rem}deckgo-highlight-code:hover:after{opacity:1}}@media (max-width:900px){.base-wrapper{margin-left:auto;margin-right:auto;min-height:100%;padding:2.625rem 1rem;width:100%}}.progresser{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;font-family:Courier New,Courier,monospace;font-size:13px;font-weight:lighter;height:30px;line-height:29px;position:fixed;right:1rem;text-align:center;top:1rem;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:30px;z-index:999}.progresser:after{background-color:var(--quote-background-color);border-radius:50%;content:"";opacity:0;transition:.2s}.progresser:after,.progresser:hover:after{bottom:0;left:0;position:absolute;right:0;top:0}.progresser:hover:after{content:"up";opacity:1}.table-of-content{background-color:var(--background-color);border-left:1px solid var(--card-background-border-color);font-size:16px;height:100%;overflow-y:auto;padding:2.5rem 2rem 2.5rem 1.2rem;position:fixed;right:0;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%}@media (max-width:900px){.table-of-content{display:none}}.table-of-content::-webkit-scrollbar{display:none}.table-of-content p{cursor:pointer;margin:0;overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.table-of-content .topHeader{color:var(--blue)!important}.table-of-content p:hover{color:var(--blue)}p.header-level-h1{font-weight:700;margin-top:.8rem}p.header-level-h2{font-size:15px;margin-top:.4rem;padding-left:1rem}p.header-level-h3{font-size:15px;margin-top:.2rem;padding-left:2rem}.article-navigator{background-color:var(--background-color);border-right:1px solid var(--card-background-border-color);font-size:16px;height:100%;left:0;overflow-y:auto;padding:2.5rem 1.2rem 2.5rem 2rem;position:fixed;top:0;-webkit-user-select:none;-ms-user-select:none;user-select:none;width:20%;z-index:999}.article-navigator .article-navigator-toggler{cursor:pointer;font-size:1.3rem;height:2rem;line-height:2rem;position:absolute;right:0;top:1rem;visibility:hidden;width:2rem}.article-navigator .article-navigator-toggler:hover{color:var(--blue)}@media (max-width:900px){.article-navigator{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:var(--background-color-transparent);border:none;display:none;height:100%;left:0;padding:0;width:100vw}.article-navigator h4{font-size:1.2rem!important;margin-top:1rem!important;padding-left:1rem;padding-right:1rem}.article-navigator p{border-bottom:1px solid var(--navigator-border-color);font-size:1rem!important;line-height:2.8rem!important;padding-left:2rem!important;padding-right:2rem!important;transition:background .3s}.article-navigator p:hover{background:var(--navigator-hover-color)}.navigator-switch{display:block}.article-navigator .article-navigator-toggler{visibility:visible}}.article-navigator h4{font-size:16px;margin-bottom:.5rem;margin-top:1rem}.article-navigator h4:first-child{margin-top:0}.navigator-switch{background-color:var(--background-color);border:1px solid var(--card-background-border-color);border-radius:50%;color:var(--font-color);cursor:pointer;display:none;font-size:.8rem;height:30px;left:1rem;line-height:29px;position:fixed;text-align:center;top:1rem;width:30px;z-index:999}.article-navigator p{cursor:pointer;font-size:15px;margin:0;overflow-x:hidden;padding-left:.5rem;text-overflow:ellipsis;white-space:nowrap;width:100%}.article-navigator p:hover,.highlighted-navigator-item{color:var(--blue)}</style><meta name="generator" content="Gatsby 4.4.0"/><link rel="icon" href="/favicon-32x32.png?v=955b34d699199a783b1a23f58b90c7ba" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=955b34d699199a783b1a23f58b90c7ba"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=955b34d699199a783b1a23f58b90c7ba"/><link as="script" rel="preload" href="/webpack-runtime-6810787f743bb0650217.js"/><link as="script" rel="preload" href="/framework-f27b074ecebec0f1dbc4.js"/><link as="script" rel="preload" href="/app-482b53f1cff3eb5f0e6d.js"/><link as="script" rel="preload" href="/cb1608f2-001f1ae553ac1c271243.js"/><link as="script" rel="preload" href="/a9a7754c-992c6b2080a7db331a45.js"/><link as="script" rel="preload" href="/commons-be2d4d65e68c8bdaf6be.js"/><link as="script" rel="preload" href="/component---src-pages-articles-mdx-slug-js-e4bb5d7bfe68b7d30d0d.js"/><link as="fetch" rel="preload" href="/page-data/articles/redbook-series/redbook-chapter03/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2757060725.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3605573801.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="base-wrapper"><title>Louis K - Software Engineer</title><header><a class="nav-link" href="/nonTech/"><span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span><span class="link-label">杂谈文章</span></a><a class="nav-link" href="/"><span role="img" aria-label="desktop" class="anticon anticon-desktop"><svg viewBox="64 64 896 896" focusable="false" data-icon="desktop" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 140H96c-17.7 0-32 14.3-32 32v496c0 17.7 14.3 32 32 32h380v112H304c-8.8 0-16 7.2-16 16v48c0 4.4 3.6 8 8 8h432c4.4 0 8-3.6 8-8v-48c0-8.8-7.2-16-16-16H548V700h380c17.7 0 32-14.3 32-32V172c0-17.7-14.3-32-32-32zm-40 488H136V212h752v416z"></path></svg></span><span class="link-label">技术文章</span></a><div class="nav-link"><img alt="avatar" src="/static/avatar-427bcc9e4a03334af5649168991c08f0.png"/><span class="link-label">关于作者</span></div></header><main><div class="progresser">0</div><div class="article-body"><h1 class="article-title">红宝书系列（三）JavaScript语言基础</h1><p class="article-meta"><span><span role="img" aria-label="field-time" class="anticon anticon-field-time"><svg viewBox="64 64 896 896" focusable="false" data-icon="field-time" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M945 412H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h256c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM811 548H689c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h122c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM477.3 322.5H434c-6.2 0-11.2 5-11.2 11.2v248c0 3.6 1.7 6.9 4.6 9l148.9 108.6c5 3.6 12 2.6 15.6-2.4l25.7-35.1v-.1c3.6-5 2.5-12-2.5-15.6l-126.7-91.6V333.7c.1-6.2-5-11.2-11.1-11.2z"></path><path d="M804.8 673.9H747c-5.6 0-10.9 2.9-13.9 7.7a321 321 0 01-44.5 55.7 317.17 317.17 0 01-101.3 68.3c-39.3 16.6-81 25-124 25-43.1 0-84.8-8.4-124-25-37.9-16-72-39-101.3-68.3s-52.3-63.4-68.3-101.3c-16.6-39.2-25-80.9-25-124 0-43.1 8.4-84.7 25-124 16-37.9 39-72 68.3-101.3 29.3-29.3 63.4-52.3 101.3-68.3 39.2-16.6 81-25 124-25 43.1 0 84.8 8.4 124 25 37.9 16 72 39 101.3 68.3a321 321 0 0144.5 55.7c3 4.8 8.3 7.7 13.9 7.7h57.8c6.9 0 11.3-7.2 8.2-13.3-65.2-129.7-197.4-214-345-215.7-216.1-2.7-395.6 174.2-396 390.1C71.6 727.5 246.9 903 463.2 903c149.5 0 283.9-84.6 349.8-215.8a9.18 9.18 0 00-8.2-13.3z"></path></svg></span> <!-- -->2022-01-09<!-- --> | <span role="img" aria-label="read" class="anticon anticon-read"><svg viewBox="64 64 896 896" focusable="false" data-icon="read" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 161H699.2c-49.1 0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3A255.2 255.2 0 00324.8 161H96c-17.7 0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1 0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7 0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4 0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2 0H699.2c-54.4 0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488zM396.9 361H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm223.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9 0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9 0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9 0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z"></path></svg></span> <!-- -->13800<!-- -->words <!-- -->49<!-- -->min</span></p><img class="article-cover" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0xw24rfidj20zk0k0jtg.jpg" alt="https://tva1.sinaimg.cn/large/e6c9d24egy1h0xw24rfidj20zk0k0jtg.jpg"/><p>任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能，在此基础之上才可以构建复杂的解决方案。如前所属，ECMA-262 以一个名为 ECMAScript 的伪语言的形式，定义了 JavaScript 的所有这些方面。</p><p>ECMA-262 第 5 版（ES5）定义的 ECMAScript，是目前实现得最为广泛（受浏览器支持最好）的一个版本。第 6 版（ES6）在浏览器中的实现程度次之。到了 2017 年底，大多数主流浏览几乎或全部实现了这一版的规范。为此，本章接下来的内容主要基于 ECMAScript 的第 6 版。</p><h1>语法</h1><p>ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法。</p><h2>区分大小写</h2><p>首先要知道的是，ECMAScript 中的一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量<code>test</code>和<code>Test</code>是两个完全不同的变量。类似地，<code>typeof</code>不能作为函数名，因为它是一个关键字。但<code>Typeof</code>是一个完全有效的函数名。</p><h2>标识符</h2><p>所谓<strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p><ul><li>第一个字符必须是一个字母、下划线（<code>_</code>）或美元符号（<code>$</code>）</li><li>剩下的其他字符可以是字母、下划线、美元符号或数字</li></ul><p>标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符（但不推荐使用）。</p><p>按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，如：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">firstSecond
myCar
doSomethingImportant</code>
        </deckgo-highlight-code><p>虽然这种写法不是强制性的，但是因为这种形式跟 ECMAScript 内置函数和对象命名方式一致，所以算是最佳实践。</p><blockquote><p>注意，关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1d1rra2gij20nt054aap.jpg"/></p><blockquote><p>补充：一个有趣的现象是可以给<code>undefined</code>赋值而不报错，实际上<code>undefined</code>并不是语言的一个关键字或保留字，它是全局对象的一个只读的属性，因此可以赋值。但由于其只读，内部<code>[[writable]]</code>为<code>false</code>，因此赋值是无效的。而<code>null</code>是 JavaScript 中一个特殊的字面量，它和<code>true</code>、<code>false</code>一样不能被赋值。在严格模式下，给<code>undefined</code>赋值会报错，因为严格模式下，禁止给对象的只读属性赋值。类似的还有<code>NaN</code>、<code>Infinity</code>等。</p></blockquote><h2>注释</h2><p>ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 单行注释</code>
        </deckgo-highlight-code><p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，已其反向组合（<code>*/</code>）结尾，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">/* 这是多行
注释 */</code>
        </deckgo-highlight-code><h2>严格模式</h2><p>ES5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">&#x27;use strict&#x27;</code>
        </deckgo-highlight-code><p>虽然看起来像是个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持 ES5 的引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏 ECMAScript 3 语法。</p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function doSomething() {
  &#x27;use strict&#x27;
  // 函数体
}</code>
        </deckgo-highlight-code><p>严格模式会影响 JavaScript 执行的很多方面，所有现代浏览器都支持严格模式。</p><h2>语句</h2><p>ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，例如下面例子所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const sum = a + b // 没有分号也有效，但不推荐
const diff = a - b // 加分号有效，推荐</code>
        </deckgo-highlight-code><p>即使语句末尾的分号不是必须的，也应该加上。记着加分号有助于防止省略造成的问题，例如可以避免输入内容不完整。此外，加分号也有助于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。</p><blockquote><p>补充：需要说明的是，部分现代 JavaScript 框架的源码并不鼓励加分号，例如 Vue3、Next.js 等，甚至 Node.js 的官网样例也均不加分号。由于现代 JavaScript 开发过程中普遍使用现代构建、编译工具，最终交付给浏览器的生产代码都是加过分号并且经过压缩的。故而在开发代码库中是否需要加分号并不关系到运行时的问题，而更多地是一种偏好。省略分号在一定程度上提升代码的整洁度和可读性，而加分号可以避免部分换行不正确的错误（实际上有经验的开发者极少犯此类错误）。</p></blockquote><p>多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号<code>{</code>标识开始，一个右花括号<code>}</code>标识结束：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">if (test) {
  test = false
  console.log(test)
}</code>
        </deckgo-highlight-code><p><code>if</code>之类的控制语句只在执行多条语句时要求必须有代码块。不过最佳实践是始终在控制语句中使用代码块，即使只有一条语句，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">if (test) console.log(test)

// 推荐
if (test) {
  console.log(test)
}</code>
        </deckgo-highlight-code><p>在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。</p><h1>关键字与保留字</h1><p>ECMA-262 描述了一组保留的<strong>关键字</strong>，这些关键字有特殊用途，例如表示控制语句的开始或结束，或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。ES6 规定的所有关键字如下：</p><deckgo-highlight-code theme="one-dark">
          <code slot="code">break case catch class const continue debugger default delete
do else export extends finally for function if import
in instanceof new return super switch this throw try
typeof var void while with yield</code>
        </deckgo-highlight-code><blockquote><p>补充：一个有趣的现象是<code>let</code>并不是一个保留字，导致在非严格模式下可以给<code>let</code>赋值而不报错。这个问题是由于历史原因，早在 2000 年的 ES3 标准中就已经定义了所有的保留字。处于向前兼容的原因，无法扩展这个列表了（会导致部分老的 JavaScript 无法运行）。当时的标准制定者并没有预见到未来 JavaScript 的发展。因此有许多”新关键字“并没有在当时列入保留字，如果要让 JavaScript 引擎判定其为保留字，则需要开启严格模式。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1d3laaeq9j20iv050jro.jpg"/></p><p>规范中也描述了一组<strong>未来的保留字</strong>，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。</p><p>以下是 ES6 为将来保留的所有词汇：</p><table><thead><tr><th align="center">分类</th><th align="center">保留字</th></tr></thead><tbody><tr><td align="center">始终保留</td><td align="center"><code>enum</code></td></tr><tr><td align="center">严格模式下保留</td><td align="center"><code>implements</code>、<code>package</code>、<code>public</code>、<code>interface</code>、<code>protected</code>、<code>static</code>、<code>let</code>、<code>private</code></td></tr><tr><td align="center">模块代码中保留</td><td align="center"><code>await</code></td></tr></tbody></table><p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。</p><blockquote><p>补充：注意到<code>async</code>即使在 ES6 中也并未成为严格模式下的保留字，这或许是因为<code>async</code>由于其作为语法组成部分时，可以直接被判定，不会引起语义模糊。这一点和<code>await</code>不一样。参见<a href="https://stackoverflow.com/questions/45336937/why-is-async-not-a-a-reserved-word">stackoverflow 上的一个讨论</a>。</p></blockquote><h1>变量</h1><p>ECMAScript 是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中，<code>var</code>在 ECMAScript 任何版本中都可以使用，而<code>const</code>和<code>let</code>只能在 ECMAScript6 及更晚版本中使用。</p><h2><code>var</code>关键字</h2><p>要定义变量，可以使用<code>var</code>操作符（注意<code>var</code>是一个关键字），后跟变量名（即标识符，如前所述）：</p><deckgo-highlight-code language="js" theme="one-dark">
          <code slot="code">var message</code>
        </deckgo-highlight-code><p>这行代码定义了一个名为<code>message</code>的变量，可以用它保存任何类型的值。（不初始化的情况下，变量会保存一个特殊值<code>undefined</code>）。ECMAScript 实现变量初始化，因此可以同时定义变量并设置它的值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var message = &#x27;hi&#x27;</code>
        </deckgo-highlight-code><p>这里，<code>message</code>被定义为一个保存字符串值<code>hi</code>的变量。像这样初始化变量不会将它标识为字符串类型，只能一个简单的赋值而已。随后，不仅可以改变的值，也可以改变值的类型：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var message = &#x27;hi&#x27;
message = 100 // 合法，但不推荐</code>
        </deckgo-highlight-code><p>在这个例子中，变量<code>message</code>首先被定义为一个保存字符串值<code>hi</code>的变量，然后又被重写为保存了数值 100。虽然不推荐改变变量保存值的类型，但这在 ECMAScript 中是完全有效的。</p><h3><code>var</code>声明作用域</h3><p>关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。例如，使用<code>var</code>在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function test() {
  var message = &#x27;hi&#x27; // 局部变量，拥有函数级作用域
}

test()
console.log(message) // 出错</code>
        </deckgo-highlight-code><p>这里，<code>message</code>变量是在函数内部使用<code>var</code>定义的。函数叫<code>test()</code>，调用它会创建这个变量并给它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function test() {
  message = &#x27;hi&#x27; // 全局变量
}

test()
console.log(message) // &#x27;hi&#x27;</code>
        </deckgo-highlight-code><p>去掉之前的<code>var</code>操作符之后，<code>message</code>就变成了全局变量。只要调用一次函数<code>test()</code>，就会定义这个变量，并且可以在函数外部访问到。</p><blockquote><p>注意：虽然可以通过省略<code>var</code>操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略<code>var</code>是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出<code>ReferenceError</code>。</p></blockquote><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var message = &#x27;hi&#x27;,
  found = false,
  age = 29</code>
        </deckgo-highlight-code><p>这里定义并初始化了 3 个变量。因为 ECMAScript 是松散类型的，所以使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。</p><blockquote><p>补充：实际上好的 JavaScript 编码规范中，禁止在一条语句中声明多个变量。因为这样做的可读性更差，也不优雅。</p></blockquote><p>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p><h3><code>var</code>声明提升</h3><p>使用<code>var</code>时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function foo() {
  console.log(age)
  var age = 26
}
foo() // undefined</code>
        </deckgo-highlight-code><p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function foo() {
  var age
  console.log(age)
  age = 26
}
foo() // undefined</code>
        </deckgo-highlight-code><p>这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用<code>var</code>声明同一个变量也么有问题：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function foo() {
  var age = 16
  var age = 26
  var age = 36
  console.log(age)
}
foo() // 36</code>
        </deckgo-highlight-code><h2><code>let</code>声明</h2><p><code>let</code>跟<code>var</code>的作用差不多，但有着非常重要的区别。最明显的区别是，<code>let</code>声明的范围是块作用域，而<code>var</code>声明的范围是函数作用域。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">if (true) {
  var name = &#x27;Matt&#x27;
  console.log(name) // Matt
}
console.log(name) // Matt

if (true) {
  let age = 26
  console.log(age) // 26
}

console.log(age) // ReferenceError: age没有定义</code>
        </deckgo-highlight-code><p>在这里，<code>age</code>变量之所以不能在<code>if</code>块外部被使用，是因为它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p><p><code>let</code>也不允许同一个块作用域中出现冗余声明。这样会导致报错：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var name
var name

let age
let age // SyntaxError; 标识符age已经声明过了</code>
        </deckgo-highlight-code><p>当然，JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一块中没有重复声明：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var name = &#x27;Nicholas&#x27;
console.log(name) // &#x27;Nicholas&#x27;
if (true) {
  var name = &#x27;Matt&#x27;
  console.log(name) // &#x27;Matt&#x27;
}

let age = 30
console.log(age) // 30
if (true) {
  let age = 26
  console.log(age) // 26
}</code>
        </deckgo-highlight-code><p>对声明冗余报错不会因混用<code>let</code>和<code>var</code>而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var name
let name // SyntaxError

let age
var age // SyntaxError</code>
        </deckgo-highlight-code><h3>暂时性死区</h3><p><code>let</code>与<code>var</code>的另一个重要的区别，就是<code>let</code>声明的变量不会在作用域中被提升。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// name会被提升
console.log(name) // undefined
var name = &#x27;Matt&#x27;

// age不会被提升
console.log(age) // ReferenceError: age没有定义
let age = 26</code>
        </deckgo-highlight-code><p>在解析代码时，JavaScript 引擎也会注意出现在块后面的<code>let</code>声明，只不过在此之前不能以任何方式来使用未声明的变量。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<code>ReferenceError</code>。</p><h3>全局声明</h3><p>与<code>var</code>关键字不同，使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量则会）。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">var name = &#x27;Matt&#x27;
console.log(window.name) // &#x27;Matt&#x27;

let age = 26
console.log(window.age) // undefined</code>
        </deckgo-highlight-code><p>不过，<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在生命周期内存续。因此，为了避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p><h3>条件声明</h3><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p><p>因此，对于<code>let</code>这个新的 ES6 声明关键字，不能依赖条件声明模式。</p><blockquote><p>不能使用<code>let</code>进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。</p></blockquote><h3><code>for</code>循环中的<code>let</code>声明</h3><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (var i = 0; i &lt; 5; i++) {
  // 循环逻辑
}
console.log(i) // 5</code>
        </deckgo-highlight-code><p>改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (let i = 0; i &lt; 5; i++) {
  // 循环逻辑
}
console.log(i) // ReferenceError: i没有定义</code>
        </deckgo-highlight-code><p>在使用<code>var</code>的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (var i = 0; i &lt; 5; i++) {
  setTimeout(() =&gt; console.log(i), 0)
}

// 实际上输出5,5,5,5,5</code>
        </deckgo-highlight-code><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用<code>let</code>声明迭代变量时，JavaScript 引擎会在后台为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出了我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (let i = 0; i &lt; 5; i++) {
  setTimeout(() =&gt; console.log(i), 0)
}

// 会输出0,1,2,3,4</code>
        </deckgo-highlight-code><p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的<code>for</code>循环，包括<code>for-in</code>和<code>for-of</code>循环。</p><h2><code>const</code>声明</h2><p><code>const</code>的行为与<code>let</code>基本相同，唯一一个重要的区别是用它们声明变量时必须同时初始化变量，且尝试修改<code>const</code>声明的变量会导致运行时错误。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const age = 26
age = 36 // TypeError: 给常量赋值

// const也不允许重复声明
const name = &#x27;Matt&#x27;
const name = &#x27;Nicholas&#x27; // SyntaxError

// const声明的作用域也是块
const name = &#x27;Matt&#x27;
if (true) {
  const name = &#x27;Nicholas&#x27;
}
console.log(name) // Matt</code>
        </deckgo-highlight-code><p><code>const</code>声明的限制只使用于它指向的变量的引用。换句话说，如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const person = {}
person.name = &#x27;Matt&#x27; // ok</code>
        </deckgo-highlight-code><p><code>const</code>声明的限制只适用于它指向的变量的引用。换句话说，如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const person = {}
person.name = &#x27;Matt&#x27; // ok</code>
        </deckgo-highlight-code><p>JavaScript 引擎会为<code>for</code>循环中的<code>let</code>声明分别创建独立的变量实例，虽然<code>const</code>变量跟<code>let</code>变量很相似，但是不能用<code>const</code>来声明迭代变量（因为迭代变量会自增）：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">for (const i = 0; i &lt; 10; ++i) {} // TypeError: 给常量赋值</code>
        </deckgo-highlight-code><p>不过，如果你只想用<code>const</code>声明一个不会修改的<code>for</code>循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let i = 0
for (const j = 7; i &lt; 5; i++) {
  console.log(j)
}
// 7, 7, 7, 7, 7

for (const key in { a: 1, b: 2 }) {
  console.log(key)
}
// a, b

for (const value of [1, 2, 3, 4, 5]) {
  console.log(value)
}
// 1, 2, 3, 4, 5</code>
        </deckgo-highlight-code><h2>声明风格及最佳实践</h2><p>ECMAScript6 增加的<code>let</code>和<code>const</code>从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的<code>var</code>所造成的各种问题，已经让 JavaScript 社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p><h3>不使用<code>var</code></h3><p>有了<code>let</code>和<code>const</code>，大多数开发者发现自己不再需要<code>var</code>了。限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p><h3><code>const</code>优先，<code>let</code>次之</h3><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用<code>const</code>来声明变量，只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p><h1>数据类型</h1><p>ECMAScript 有 6 种简单数据类型（也称为<strong>原始类型</strong>）：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>和<code>symbol</code>。<code>symbol</code>（符号）是 ES6 新增的。还有一种复杂数据类型叫<code>Object</code>（对象）。<code>Object</code>是一种无序名值对的集合。因为在 ECMAScript 种不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p><h2><code>typeof</code>操作符</h2><p>因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。<code>typeof</code>操作符就是为此而生的。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p><ul><li><code>&quot;undefined&quot;</code>表示值未定义</li><li><code>&quot;boolean&quot;</code>表示值为布尔值</li><li><code>&quot;string&quot;</code>表示值为字符串</li><li><code>&quot;number&quot;</code>表示值为数值</li><li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code></li><li><code>&quot;function&quot;</code>表示值为函数</li><li><code>&quot;symbol&quot;</code>表示值为符号</li></ul><p>下面是使用<code>typeof</code>操作符的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;some string&#x27;
console.log(typeof message) // &quot;string&quot;
console.log(typeof message) // &quot;string&quot;
console.log(typeof 95) // &quot;number&quot;</code>
        </deckgo-highlight-code><p>在这个例子中，我们把一个变量（<code>message</code>）和一个数值字面量传给了<code>typeof</code>操作符。注意因为<code>typeof</code>是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><p>注意<code>typeof</code>在某些情况下返回的结果可能让人费解，但技术上讲还是正确的。例如，调用<code>typeof null</code>返回的是<code>object</code>。这是因为特殊值<code>null</code>被认为是一个空对象的引用。</p><blockquote><p>注意：严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过<code>typeof</code>操作符来区分函数和其他对象。</p></blockquote><h2><code>Undefined</code>类型</h2><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message
console.log(message === undefined) // true</code>
        </deckgo-highlight-code><p>在这个例子中，变量<code>message</code>在声明的时候并未初始化。而在比较它和<code>undefined</code>的字面值时，两者是相等的。这个例子等同于如下示例：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message = undefined
console.log(message === undefined) // true</code>
        </deckgo-highlight-code><p>这里，变量<code>message</code>显式地以<code>undefined</code>来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得<code>undefined</code>值。</p><blockquote><p>注意：一般来说，永远不用显式地给某个变量设置<code>undefined</code>值。字面值<code>undefined</code>主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（<code>null</code>）和未初始化变量的区别。</p></blockquote><p>注意，包含<code>undefined</code>值的变量跟未定义变量是有区别的。请看下面的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message // 这个变量被声明了，只是值为undefined

// 确保没有声明过这个变量
// let age

console.log(message) // &quot;undefined&quot;
console.log(age) // 报错</code>
        </deckgo-highlight-code><p>在上面的例子中，第一个<code>console.log</code>会指出变量<code>message</code>的值，即<code>&quot;undefined&quot;</code>。而第二个<code>console.log</code>要输出一个未声明的变量<code>age</code>的值，因此会导致报错。对未声明比的变量，只能执行一个有用的操作，就是对它调用<code>typeof</code>。（对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）</p><p>在对未初始化的变量调用<code>typeof</code>时，返回的结果是<code>&quot;undefined&quot;</code>，但对未声明的变量调用它时，返回的结果还是<code>&quot;undefined&quot;</code>，这就让人有点看不懂了，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message // 这个变量被声明了，只是值为undefined

// 确保没有声明过这个变量
// let age

console.log(typeof message) // &quot;undefined&quot;
console.log(typeof age) // undefined</code>
        </deckgo-highlight-code><p>无论是声明还是未声明，<code>typeof</code>返回的都是字符串<code>&quot;undefined&quot;</code>。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><blockquote><p>注意：即使未初始化的变量会被自动赋予<code>undefined</code>值，但我们仍然建议在声明变量的同时进行初始化。这样，当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p></blockquote><p><code>undefined</code>是一个假值。因此，如果需要，可以用更简洁的方式检测它。但是要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是假值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message

if (message) {
  // 这个块不会执行
}

if (!message) {
  // 这个块会执行
}

if (age) {
  // 这里会报错
}</code>
        </deckgo-highlight-code><h2><code>Null</code>类型</h2><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针，者也是给<code>typeof</code>传一个<code>null</code>会返回<code>Object</code>的原因：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let car = null
console.log(typeof car) // &quot;object&quot;</code>
        </deckgo-highlight-code><p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化，不要使用其他值。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">if (car !== null) {
  // car是一个对象的引用
}</code>
        </deckgo-highlight-code><p><code>undefined</code>值是由<code>null</code>值派生而来的，因此 ECMA-262 将他们定义为表面上相等：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(null == undefined) // true</code>
        </deckgo-highlight-code><p>注意，一般情况下应该避免使用<code>==</code>操作符，因为这个操作符会为了比较而转换它的操作数。</p><p>即使<code>null</code>和<code>undefined</code>有关系，它们的用途也完全不一样的。如前所述，永远不必显式地将变量值设置为<code>undefined</code>。但<code>null</code>不是这样的。任何时候，只要变量保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。</p><p><code>null</code>是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，很多其他值可能同样是假值。所以一定要明确自己想检测的就是<code>null</code>这个字面值，而不仅仅是假值。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message = null
let age

if (message) {
  // 这个块不会执行
}

if (!message) {
  // 这个块会执行
}

if (age) {
  // 这个块不会执行
}

if (!age) {
  // 这个块会执行
}</code>
        </deckgo-highlight-code><h2><code>Boolean</code>类型</h2><p><code>Boolean</code>（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：<code>true</code>和<code>false</code>。这个布尔值不同于数值，因此<code>true</code>不等于 1，<code>false</code>不等于 0。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let found = true
let lost = false</code>
        </deckgo-highlight-code><p>注意，布尔值字面量<code>true</code>和<code>false</code>是区分大小写的。</p><p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的<code>Boolean()</code>转型函数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const message = &#x27;Hello World&#x27;
const messageAsBoolean = Boolean(message)</code>
        </deckgo-highlight-code><p>在这个例子中，字符串<code>message</code>会被转换为布尔值并保存在变量<code>messageAsBoolean</code>中。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。</p><table><thead><tr><th align="center">数据类型</th><th align="center">转换为<code>true</code>的值</th><th align="center">转换为<code>false</code>的值</th></tr></thead><tbody><tr><td align="center"><code>Boolean</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr><tr><td align="center"><code>String</code></td><td align="center">非空字符串</td><td align="center"><code>&quot;&quot;</code>（空字符串）</td></tr><tr><td align="center"><code>Number</code></td><td align="center">非零数值（包括无穷值）</td><td align="center"><code>0</code>、<code>NaN</code></td></tr><tr><td align="center"><code>Object</code></td><td align="center">任意对象</td><td align="center"><code>null</code></td></tr><tr><td align="center"><code>Undefined</code></td><td align="center"><code>N/A</code>（不存在）</td><td align="center"><code>undefined</code></td></tr></tbody></table><p>理解以上转换非常重要，因为像<code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let message = &#x27;Hello World!&#x27;
if (message) {
  console.log(&#x27;Value is true&#x27;)
}</code>
        </deckgo-highlight-code><p>在这个例子中，<code>console.log</code>会输出字符串<code>&quot;Value is true&quot;</code>，因为字符串<code>message</code>会自动转换为等价的布尔值<code>true</code>。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><h2><code>Number</code>类型</h2><p>ECMAScript 中最有意思的数据类型或许就是<code>Number</code>了。<code>Number</code>类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度浮点值）。不同的数值类型相应地也不同的数值字面量格式。</p><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let intNum = 55 // 整数</code>
        </deckgo-highlight-code><p>整数也可以用八进制或十六进制字面量表示。对于八进制字面量，第一个数字必须是零，然后是相应的八进制数字（数值 0 ～ 7）。如果字面量中包含的数字超过了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let octalNum1 = 070 // 八进制56
let octalNum2 = 079 // 无效的八进制数值，当成79处理
let octaNum3 = 08 // 无效的八进制数值，当成8处理</code>
        </deckgo-highlight-code><p><strong>八进制字面量在严格模式下是无效的</strong>，会导致 JavaScript 引擎抛出语法错误。</p><p>要创建十六进制字面量，必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0 ～ 9 以及 A ～ F）。十六进制数字的字母大小写均可。下面是几个例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let hexNum1 = 0xa // 十六进制10
let hexNum2 = 0x1f // 十六进制31</code>
        </deckgo-highlight-code><p>使用八进制和十六进制创建的数值在所有数学操作中都会视为十进制数值。</p><blockquote><p>由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。</p></blockquote><h3>浮点值</h3><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let floatNum1 = 1.1
let floatNum2 = 0.1
let floatNum3 = 0.1 // 有效，但不推荐</code>
        </deckgo-highlight-code><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let floatNum1 = 1 // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0 // 小数点后面是零，当成整数10处理</code>
        </deckgo-highlight-code><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学计数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let floatNum = 3.125e7 // 等于31_250_000</code>
        </deckgo-highlight-code><p>在这个例子中，<code>floatNum</code>等于 31 250 000，只不过科学记数法更简洁。</p><p>科学记数法也可以表示非常小的数值。默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如，<code>0.000 000 3</code>会被转换为<code>3e-7</code>）。</p><p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。例如下面的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">if (a + b === 0.3) {
  // 别这么干！
  console.log(&#x27;You got 0.3.&#x27;)
}</code>
        </deckgo-highlight-code><p>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p><blockquote><p>之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。</p></blockquote><h3>值的范围</h3><p>由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在<code>Number.MIN_VALUE</code>种，这个值在多数浏览器中 5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值超过了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的<code>Infinity</code>（无穷）值。任何无法表示的负数以<code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以<code>Infinity</code>（正无穷大）表示。</p><p>如果计算返回正<code>Infinity</code>或负<code>Infinity</code>，则该值将不能再进一步用于任何计算。这是因为<code>Infinity</code>没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let result = Number.MAX_VALUE + Number.MAX_VALUE
console.log(isFinite(result)) //flase</code>
        </deckgo-highlight-code><p>虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。</p><blockquote><p>使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。没错，这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p></blockquote><h3><code>NaN</code></h3><p>又一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于<strong>表示本来要返回数值的操作失败了</strong>（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或-0 相除都会返回<code>NaN</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(0 / 0) // NaN
console.log(-0 / +0) // NaN</code>
        </deckgo-highlight-code><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回<code>Infinity</code>或<code>-Infinity</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(5 / 0) // Infinity
console.log(5 / -0) // -Infinity</code>
        </deckgo-highlight-code><p><code>NaN</code>有几个独特的属性。首先，任何设计<code>NaN</code>的操作使用返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。例如，下面的比较操作会返回<code>false</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(NaN === NaN) // false</code>
        </deckgo-highlight-code><p>为此，ECMAScript 提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给<code>isNaN()</code>后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串<code>&quot;10&quot;</code>或布尔值。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。举例如下：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(isNaN(NaN)) // true
console.log(isNaN(10)) // false, 10是数值
console.log(isNaN(&#x27;10&#x27;)) // false，可以转换为数值10
console.log(isNaN(&#x27;blue&#x27;)) // true，不可以转换为数值
console.log(isNaN(true)) // false，可以转换为数值1</code>
        </deckgo-highlight-code><p>上述的例子测试了 5 个不同的值。首先测试的是<code>NaN</code>本身，显然会返回<code>true</code>。接着测试了数值 10 和字符串<code>&quot;10&quot;</code>，都返回<code>false</code>，因为它们的数值都是 10。字符串<code>&quot;blue&quot;</code>不能转换为数值，因此函数返回<code>true</code>。布尔值<code>true</code>可以转换为数值 1，因此返回<code>false</code>。</p><blockquote><p>虽然不常见，但是<code>isNaN()</code>可以用于测试对象。此时，首先会调用对象的<code>valueOf()</code>方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用<code>toString()</code>方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式。</p></blockquote><h3>数值转换</h3><p>有三个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可以用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。</p><p><code>Number()</code>函数基于如下规则执行转换：</p><ul><li><p>布尔值，<code>true</code>转换为 1，<code>false</code>转换为 0。</p></li><li><p>数值，直接返回。</p></li><li><p><code>null</code>，返回 0。</p></li><li><p><code>undefined</code>，返回<code>NaN</code>。</p></li><li><p>字符串，应用以下规则：</p><ul><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，<code>Number(1)</code>返回 1，<code>Number(&quot;123&quot;)</code>返回 123，<code>Number(&quot;011&quot;)</code>返回 123，<code>Number(&quot;011&quot;)</code>返回 11（忽略前面的零）。</li><li>如果字符串包含有效的浮点值格式如<code>&quot;1.1&quot;</code>，则会转换为相应的浮点值。（同样，忽略前面的零）。</li><li>如果字符串包含有效的十六进制格式如<code>&quot;0xf&quot;</code>，则会转换为与该十六进制对应的十进制整数值。</li><li>如果是空字符串（不包含字符），则返回 0。</li><li>如果字符串包含除上述情况之外的其他字符，则返回<code>NaN</code>。</li></ul></li><li><p>对象，调用<code>valueOf()</code>方法，并按照上述规则转换返回的值。如果转换结果是<code>NaN</code>，则调用<code>toString()</code>方法，再按照转换字符串的规则转换。</p></li></ul><p>从不同数据类型到数值的转换有时候会比较复杂，看一看<code>Number()</code>的转换规则就知道了。下面是几个具体的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num1 = Number(&#x27;Hello World&#x27;) // NaN
let num2 = Number(&#x27;&#x27;) // 0
let num3 = Number(&#x27;000011&#x27;) // 11
let num4 = Number(true) // 1</code>
        </deckgo-highlight-code><p>可以看到，字符串<code>&quot;Hello world&quot;</code>转换之后是<code>NaN</code>，因为它找不到对应的数值。空字符串转换后是 0。字符串 000011 转换后是 11，因为前面的零被忽略了。最后，<code>true</code>被转换为 1。</p><blockquote><p>一元加操作符与<code>Number()</code>函数遵循相同的规则。</p></blockquote><p>考虑到用<code>Number()</code>函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符串开始转换。如果第一个数值不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。这意味着空字符串也会返回<code>NaN</code>（这一点跟<code>Number()</code>不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。例如，<code>&quot;12345blue&quot;</code>会被转换为 12345，因为<code>&quot;blue&quot;</code>会被完全忽略。类似地，<code>&quot;22.5&quot;</code>会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以<code>&quot;0x&quot;</code>开头，就会被解释为十六进制整数。如果字符串以<code>&quot;0&quot;</code>开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。</p><p>下面几个转换有助于理解上述规则：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num1 = parseInt(&#x27;1234blue&#x27;) // 1234
const num2 = parseInt(&#x27;&#x27;) // NaN
const num3 = parseInt(&#x27;0xA&#x27;) // 10，解释为十六进制整数
const num4 = parseInt(&#x27;22.5&#x27;) // 22
const num5 = parseInt(&#x27;70&#x27;) // 70，解释为十进制值
const num6 = parseInt(&#x27;0xf&#x27;) // 15，解释为十六进制整数</code>
        </deckgo-highlight-code><p>不同数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数，以便正确解析：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num = parseInt(&#x27;0xAF&#x27;, 16) // 175</code>
        </deckgo-highlight-code><p>事实上如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const num1 = parseInt(&#x27;AF&#x27;, 16) // 175
const num2 = parseInt(&#x27;AF&#x27;) // NaN</code>
        </deckgo-highlight-code><p>在这个例子中，第一个转换是正确的，而第二个转换失败了。区别在于第一次传入了进制数作为参数，告诉<code>parseInt()</code>要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回<code>NaN</code>。</p><p>通过第二个参数，可以极大扩展转换后获得的结果类型。例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num1 = parseInt(&#x27;10&#x27;, 2) // 2
let num2 = parseInt(&#x27;10&#x27;, 8) // 8
let num3 = parseInt(&#x27;10&#x27;, 10) // 10
let num4 = parseInt(&#x27;10&#x27;, 16) // 16</code>
        </deckgo-highlight-code><p>因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析，所以为避免出错，建议始终传给它第二个参数。</p><blockquote><p>多数情况下解析的应该都是 10 进制数，此时第二个参数就要传入 10。</p></blockquote><p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，<code>&quot;22.34.5&quot;</code>将转换成 22.34。</p><p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0，因为<code>parseFloat()</code>只解析十进制值，不能指定底数。最后如果字符串表示整数（没有小数点，或小数点后只有一个 0），则<code>parseFloat()</code>返回整数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num1 = parseFloat(&#x27;1234blue&#x27;) // 1234
let num2 = parseFloat(&#x27;0xA&#x27;) // 0
let num3 = parseFloat(&#x27;22.5&#x27;) // 22.5
let num4 = parseFloat(&#x27;22.34.5&#x27;) // 22.34
let num5 = parseFloat(&#x27;0908.5&#x27;) // 908.5
let num6 = parseFloat(&#x27;3.125e7&#x27;) // 31250000</code>
        </deckgo-highlight-code><h2><code>String</code>类型</h2><p><code>String</code>（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号<code>&quot;</code>、单引号<code>&#x27;</code>或反引号<code>`</code>表示。</p><p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须依然以该种引号作为字符串结尾。</p><h3>字符串字面量</h3><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符。</p><table><thead><tr><th align="center">字面量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\n</code></td><td align="center">换行</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表</td></tr><tr><td align="center"><code>\b</code></td><td align="center">退格</td></tr><tr><td align="center"><code>\r</code></td><td align="center">回车</td></tr><tr><td align="center"><code>\f</code></td><td align="center">换页</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠<code>\</code></td></tr><tr><td align="center"><code>\&#x27;</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\` </code></td><td align="center">反引号</td></tr><tr><td align="center"><code>\xnn</code></td><td align="center">以十六进制编码<code>nn</code>表示的字符，例如<code>\x41</code>等于<code>&quot;A&quot;</code></td></tr><tr><td align="center"><code>\unnnn</code></td><td align="center">以十六进制编码<code>nnnn</code>表示的 Unicode 字符（其中<code>n</code>是十六进制数值 0 ～ F），例如<code>\u03a3</code>等于希腊字符<code>&quot;Σ&quot;</code></td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，也可以作为单个字符被解释。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const text = &#x27;This is the letter sigma: \u03a3&#x27;</code>
        </deckgo-highlight-code><p>在这个例子中，即使包含 6 个字符长的转义序列，变量<code>text</code>仍然是 28 个字符长。因为转移序列表示一个字符，所以只能算一个字符。</p><p>字符串的长度可以通过其<code>length</code>属性获取：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(text.length) // 28</code>
        </deckgo-highlight-code><p>这个属性返回字符串中 16 位字符的个数。</p><blockquote><p>如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p></blockquote><h3>字符串的特点</h3><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let lang = &#x27;Java&#x27;
lang = lang + &#x27;Script&#x27;</code>
        </deckgo-highlight-code><p>这里变量<code>lang</code>一开始包含字符串<code>&quot;Java&quot;</code>。紧接着，<code>lang</code>被重新定义为包含<code>&quot;Java&quot;</code>和<code>&quot;Script&quot;</code>的组合，即<code>JavaScript</code>。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上<code>&quot;Java&quot;</code>和<code>&quot;Script&quot;</code>。最后销毁原始的字符串<code>&quot;Java&quot;</code>和<code>&quot;Script&quot;</code>，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如 Firefox1.0 之前的版本和 IE6.0）拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题。</p><h3>转换为字符串</h3><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let age = 11
let ageAsString = age.toString() // &quot;11&quot;
let found = true
let foundAsString = found.toString() // &quot;true&quot;</code>
        </deckgo-highlight-code><p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有<code>toString()</code>方法，该方法只是简单地返回自身的一个副本。）<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法。</p><p>多数情况下，<code>toString()</code>不接收任何参数。不过，在对数值调用这个方法时，<code>toString()</code>可以接收一个底层参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code>返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num = 10
num.toString() // &quot;10&quot;
num.toString(2) // &quot;1010&quot;
num.toString(8) // &quot;12&quot;
num.toString(10) // &quot;10&quot;
num.toString(16) // &quot;a&quot;</code>
        </deckgo-highlight-code><p>这个例子展示了传入底数参数时，<code>toString()</code>输出的字符串值也随之改变。数值 10 可以输出为任意数值格式。注意，默认情况下（不穿参数）的输入与传入参数 10 得到的结果相同。</p><p>如果你不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数，它始终返回表示相应类型值的字符串。<code>String()</code>函数遵循如下规则。</p><ul><li>如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。</li><li>如果值时<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</li></ul><blockquote><p>使用加号操作符给一个值加上一个空字符串也可以将其转换为字符串。</p></blockquote><h3>模板字面量</h3><p>ES6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行符，可以跨行定义字符串：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let myMultiLineString = &#x27;first line\nsecond line&#x27;
let myMultiLineTemplateLiteral = `first line 
second line`

console.log(myMultiLineString)
// first line
// second line

console.log(myMultiLineTemplateLiteral)
// first line
// second line

console.log(myMultiLineString === myMultiLineTemplateLiteral) // true</code>
        </deckgo-highlight-code><p>顾名思义，模板字面量在定义模板时特别有用，例如下面的 HTML 模板：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let pageHTML = `
&lt;div&gt;
  &lt;a href=&quot;#&quot;&gt;
    &lt;span&gt;Jake&lt;/span&gt;
  &lt;/a&gt;
&lt;/div&gt;`</code>
        </deckgo-highlight-code><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 这个模板字面量在换行符之后有 25 个空格符
let myTemplateLiteral = `first line
second line`
console.log(myTemplateLiteral.length) // 47 5

// 这个模板字面量以一个换行符开头
let secondTemplateLiteral = `
first line
second line`
console.log(secondTemplateLiteral[0] === &#x27;\n&#x27;) // true

// 这个模板字面量没有意料之外的字符
let thirdTemplateLiteral = `first line second line`
console.log(thirdTemplateLiteral)
// first line
// second line</code>
        </deckgo-highlight-code><h3>字符串插值</h3><p>模板字符串最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字符串不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在<code>${}</code>中使用一个 JavaScript 表达式实现。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let value = 5
let exponent = &#x27;second&#x27;

let interpolatedString = `${value} to the ${exponent} power is ${value * value}`

console.log(interpolateString) // 5 to the second power is 25</code>
        </deckgo-highlight-code><p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无序转义。</p><p>在表达式转换为字符串时会调用<code>toString()</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const foo = {
  toString() {
    return &#x27;World&#x27;
  },
}
console.log(`Hello, ${foo}!`) // Hello, World!</code>
        </deckgo-highlight-code><p>在插值表达式中可以调用函数和方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function capitalize(word) {
  return `${word[0].toUpperCase()}${word.slice(1)}`
}
console.log(`${capitalize(&#x27;hello&#x27;), ${capitalize(&#x27;world&#x27;)}!`) // Hello, World!</code>
        </deckgo-highlight-code><p>此外模板也可以插入自己之前的值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let value = &#x27;&#x27;
function append() {
  value = `${value}abc`
  console.log(value)
}

append() // abc
append() // abcabc
append() // abcabcabc</code>
        </deckgo-highlight-code><h3>模板字面量标签函数</h3><p>模板字面量页支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><p>标签函数本身是一个常规函数，通过前缀到模板字面量来引用自定义行为，如下例所示。标签函数接收到的参数依次是<strong>原始字符串数组</strong>和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p><p>最好通过一个例子来理解：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let a = 6
let b = 9

function simpleTag(strings, ...expressions) {
  console.log(strings)
  for (const expression of expressions) {
    console.log(expression)
  }

  return &#x27;foobar&#x27;
}

let taggedResult = simpleTag`${a} + ${b} = ${a + b}`

// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]
// 6
// 9
// 15

console.log(taggedResult) // &quot;foobar&quot;</code>
        </deckgo-highlight-code><p>对于有<em>n</em>个插值的模板字面量，传给标签函数的表达式参数的个数始终是<em>n</em>，而传给标签函数的第一个参数所包含的字符串个数则始终是<em>n+1</em>。因此，如果想要把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let a = 6
let b = 9

function zipTag(strings, ...expressions) {
  return (
    strings[0] + expressions.map((e, i) =&gt; `${e}${strings[i + 1]}`).join(&#x27;&#x27;)
  )
}

let untaggedResult = `${a} + ${b} = ${a + b}`
let taggedResult = zipTag`${a} + ${b} = ${a + b}`

console.log(untaggedResult) // &quot;6 + 9 = 15&quot;
console.log(taggedResult) // &quot;6 + 9 = 15&quot;</code>
        </deckgo-highlight-code><h3>原始字符串</h3><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的<code>String.raw</code>函数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// Unicode示例
// \u00A9是版权符号
console.log(`\u00a9`) // ©
console.log(String.raw`\u00a9`) // \u00a9

// 换行符示例
console.log(`first line\nsecond line`)
// first line
// second line

console.log(String.raw`first line\nsecond line`) // &quot;first line\nsecond line&quot;

// 对于实际的换行符来说是不行的
// 它们不会被转换成转义序列的形式
console.log(`first line
second line`)
// first line
// second line

console.log(String.raw`first line
second line`)
// first line
// second line</code>
        </deckgo-highlight-code><p>另外，也可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性取得每个字符串的原始内容：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function printRaw(strings) {
  console.log(&#x27;Actual characters:&#x27;)
  for (const string of strings) {
    console.log(string)
  }
  console.log(&#x27;Escaped characters;&#x27;)
  for (const rawString of stings.raw) {
    console.log(rawString)
  }
}

printRaw`\u00A9${&#x27;and&#x27;}\n`
// Actual characters:
// ©
//（换行符）
// Escaped characters:
// \u00A9
// \n</code>
        </deckgo-highlight-code><h2><code>Symbol</code>类型</h2><p><code>Symbol</code>（符号）是 ES6 新增的数据类型。符号是原始值，且符号示例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>尽管听起来与私有属性有点类似，但是符号并不是为了提供私有属性的行为才增加的（尤其是因为 Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h3>符号的基本用法</h3><p>符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let sym = Symbol()
console.log(typeof sym) // symbol</code>
        </deckgo-highlight-code><p>调用<code>Symbol()</code>函数，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let genericSymbol = Symbol()
let otherGenericSymbol = Symbol()

let fooSymbol = Symbol(&#x27;foo&#x27;)
let otherFooSymbol = Symbol(&#x27;foo&#x27;)

console.log(genericSymbol === otherGenericSymbol) // false
console.log(fooSymbol === otherFooSymbol) // false</code>
        </deckgo-highlight-code><p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建<code>Symbol()</code>示例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是对象属性。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let genericSymbol = Symbol()
console.log(genericSymbol) // Symbol()

let fooSymbol = Symbol(&#x27;foo&#x27;)
console.log(fooSymbol) // Symbol(foo)</code>
        </deckgo-highlight-code><p>最重要的是，<code>Symbol()</code>函数不能与<code>new</code>关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原初始值的包装对象：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let myBoolean = new Boolean()
console.log(typeof myBoolean) // &quot;object&quot;

let myString = new String()
console.log(typeof myString) // &quot;object&quot;

let myNumber = new Number()
console.log(typeof myNumber) // &quot;object&quot;

let mySymbol = new Symbol() // TypeError: Symbol is not a constuctor</code>
        </deckgo-highlight-code><p>如果你确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let mySymbol = Symbol()
let myWrappedSymbol = Object(mySymbol)
console.log(typeof myWrappedSymbol) // &quot;object&quot;</code>
        </deckgo-highlight-code><h3>使用全局符号注册表</h3><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。</p><p>为此，需要使用<code>Symbol.for()</code>方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;)
console.log(typeof fooGlobalSymbol) // symbol</code>
        </deckgo-highlight-code><p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;) // 创建新符号
let ohterFooGlobalSymbol = Symbol.for(&#x27;foo&#x27;) // 重用已有符号

console.log(fooGlobalSymbol === otherFooGlobalSymbol) // true</code>
        </deckgo-highlight-code><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let emptyGlobalSymbol = Symbol.for()
console.log(emptyGlobalSymbol) // Symbol(undefined)</code>
        </deckgo-highlight-code><p>还可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">// 创建全局符号
let s = Symbol.for(&#x27;foo&#x27;)
console.log(Symbol.keyFor(s)) // foo

// 创建普通符号
let s2 = Symbol(&#x27;bar&#x27;)
console.log(Symbol.keyFor(s2)) // undefined</code>
        </deckgo-highlight-code><p>如果传给<code>Symbol.keyFor()</code>的不是符号，该方法会抛出<code>TypeError</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">Symbol.keyFor(123) // TypeError: 123 is not a symbol</code>
        </deckgo-highlight-code><h3>使用符号作为属性</h3><p>凡是可以使用字符串或者数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s1 = Symbol(&#x27;foo&#x27;)
const s2 = Symbol(&#x27;bar&#x27;)
const s3 = Symbol(&#x27;baz&#x27;)
const s4 = Symbol(&#x27;qux&#x27;)

const o = {
  [s1]: &#x27;foo val&#x27;,
}

console.log(o)
// {Symbol(foo): foo val}

Object.defineProperty(o, s2, { value: &#x27;bar val&#x27; })

console.log(o)
// {Symbol(foo): foo val, Symbol(bar): bar val}

Object.defineProperties(o, {
  [s3]: { value: &#x27;baz, val&#x27; },
  [s4]: { value: &#x27;qux val&#x27; },
})

console.log(o)
// {Symbol(foo): foo val, Symbol(bar): bar val,
//  Symbol(baz): baz val, Symbol(qux): qux val}</code>
        </deckgo-highlight-code><p>类似于<code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规符和符号属性描述的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s1 = Symbol(&#x27;foo&#x27;)
const s2 = Symbol(&#x27;bar&#x27;)

const o = {
  [s1]: &#x27;foo val&#x27;,
  [s2]: &#x27;bar val&#x27;,
  baz: &#x27;baz val&#x27;,
  qux: &#x27;qux val&#x27;,
}

console.log(Object.getOwnPropertySymbols(o))
// [Symbol(foo), Symbol(bar)]

console.log(Object.getOwnPropertyNames(o))
// [&#x27;baz&#x27;, &#x27;qux&#x27;]

console.log(Object.getOwnPropertyDescriptors(o))
// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}}

console.log(Reflect.ownKeys(o))
// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</code>
        </deckgo-highlight-code><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号才能找到相应的属性键：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const o = {
  [Symbol(&#x27;foo&#x27;)]: &#x27;foo val&#x27;,
  [Symbol(&#x27;bar&#x27;)]: &#x27;bar val&#x27;,
}

console.log(o)
// {Symbol(foo): &#x27;foo val&#x27;, Symbol(bar): &#x27;bar val&#x27;}

const barSymbol = Object.getOwnPropertySymbols(o).find(symbol =&gt;
  symbol.toString().match(/bar/)
)

console.log(barSymbol)
// Symbol(bar)</code>
        </deckgo-highlight-code><h3>常用内置符号</h3><p>ES6 也引入了一批<strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以访问、重写或模拟这些行为。这些内置符号都以<code>Symbol</code>工厂函数字符串属性的形式存在。</p><p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p><p>这些内置符号也没有什么特别之处，它们就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。<strong>所有内置符号属性都是不可写、不可枚举、不可配置的</strong>。</p><blockquote><p>在提到 ECMAScript 规范时，经常会引用到符号在规范中的名称，前缀为<code>@@</code>。例如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p></blockquote><h3><code>Symbol.asyncIterator</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的<code>AsyncIterator</code>。由<code>for-await-of</code>语句使用“。换句话说，这个符号表示实现异步迭代器 API 的函数。</p><p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的<code>AsyncGenerator</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Foo {
  async *[Symbol.asyncIterator]() {}
}

let f = new Foo()

console.log(f[Symbol.asyncIterator]())
// AsyncGenerator {&lt;suspended&gt;}</code>
        </deckgo-highlight-code><p>技术上，这个由<code>Symbol.asyncIterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回<code>Promise</code>实例。可以通过显式调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Emitter {
  constructor(max) {
    this.max = max
    this.asyncIdx = 0
  }

  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      yield new Promise(resolve =&gt; resolve(this.asyncIdx++))
    }
  }
}

async function asyncCount() {
  let emitter = new Emitter(5)

  for await (const x of emitter) {
    console.log(x)
  }
}

asyncCount()
// 0
// 1
// 2
// 3
// 4</code>
        </deckgo-highlight-code><blockquote><p><code>Symbol.asyncIterator</code>是 ES2018 规范定义的，因此只有版本比较新的浏览器支持它。</p></blockquote><h3><code>Symbol.hasInstance</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用”。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。<code>instanceof</code>的典型使用场景如下：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function Foo() {}
const f = new Foo()
console.log(f instanceof Foo) // true

class Bar {}
const b = new Bar()
console.log(b instanceof Bar) // true</code>
        </deckgo-highlight-code><p>在 ES6 中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">function Foo() {}
const f = new Foo()
console.log(Foo[Symbol.hasInstance](f)) // true

class Bar {}
const b = new Bar()
console.log(Bar[Symbol.hasInstance](b)) // true</code>
        </deckgo-highlight-code><p>这个属性定义在<code>Function</code>的原型上，因此默认在所有函数和类上都可以调用。由于<code>instanceof</code>操作符会在原型链上寻找这个定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Bar {}
class Baz extends Bar {
  static [Symbol.hasInstance]() {
    return false
  }
}

const b = new Baz()
console.log(Bar[Symbol.hasInstance](b)) // true
console.log(b instanceof Bar) // true
console.log(Baz[Symbol.hasInstance](b)) // false
console.log(b instanceof Baz) // false</code>
        </deckgo-highlight-code><h3><code>Symbol.isConcatSpreadable</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个布尔值，如果是<code>true</code>，则意味着对象应该用<code>Array.prototype.concat()</code>打平其数组元素。ES6 中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p><p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下会被忽略。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const initial = [&#x27;foo&#x27;]

const array = [&#x27;bar&#x27;]
console.log(array[Symbol.isConcatSpreadable]) // undefined
console.log(initial.concat(array)) // [&#x27;foo&#x27;, &#x27;bar&#x27;]
array[Symbol.isConcatSpreadable] = false
console.log(initial.concat(array)) // [&#x27;foo&#x27;, Array(1)]

const arrayLikeObject = { length: 1, 0: &#x27;baz&#x27; }
console.log(arrayLikeObject[Symbol.isConcatSpreadable]) // undefined
console.log(initial.concat(arrayLikeSpreadable)) // [&#x27;foo&#x27;, {...}]
arrayLikeObject[Symbol.isConcatSpreadable] = true
console.log(initial.concat(arrayLikeObject)) // [&#x27;foo&#x27;, &#x27;baz&#x27;]

const otherObject = new Set().add(&#x27;qux&#x27;)
console.log(otherObject[Symbol.isConcatSpreadable]) // undefined
console.log(initial.concat(otherObject)) // [&#x27;foo&#x27;, Set(1)]
otherObject[Symbol.isConcatSpreadable] = true
console.log(initial.concat(otherObject)) // [&#x27;foo&#x27;]</code>
        </deckgo-highlight-code><h3><code>Symbol.iterator</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回默认对象的迭代器。由<code>for-of</code>语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。</p><p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的<code>Generator</code>：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Foo {
  *[Symbol.iterator]() {}
}

const f = new Foo()

console.log(f[Symbol.iterator]())
// Generator {&lt;suspended&gt;}</code>
        </deckgo-highlight-code><p>技术上，这个由<code>Symbol.iterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回值。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过生成器函数返回。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Emitter {
  constructor(max) {
    this.max = max
    this.idx = 0
  }

  *[Symbol.iterator]() {
    while (this.idx &lt; this.max) {
      yield this.idx++
    }
  }
}

function count() {
  const emitter = new Emitter(5)

  for (const x of emitter) {
    console.log(x)
  }
}

count()
// 0
// 1
// 2
// 3
// 4</code>
        </deckgo-highlight-code><h3><code>Symbol.match</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用”。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(RegExp.prototype[Symbol.match])
// f [Symbol.match]() { [native code] }

console.log(&#x27;foobar&#x27;.match(/bar/))
// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</code>
        </deckgo-highlight-code><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class FooMatcher {
  static [Symbol.match](target) {
    return target.includes(&#x27;foo&#x27;)
  }
}

console.log(&#x27;foobar&#x27;.match(FooMatcher)) // true
console.log(&#x27;barbaz&#x27;.match(FooMatcher)) // false

class StringMatcher {
  constructor(str) {
    this.str = str
  }

  [Symbol.match](target) {
    return target.includes(this.str)
  }
}

console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;foo&#x27;))) // true
console.log(&#x27;barbaz&#x27;.match(new StringMatcher(&#x27;qux&#x27;))) // false</code>
        </deckgo-highlight-code><h3><code>Symbol.replace</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>“方法使用。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(RegExp.prototype[Symbol.replace])
// f [Symbol.replace]() { [native code] }

console.log(&#x27;foobarbaz&#x27;.replace(/bar/, &#x27;qux&#x27;))
// &#x27;fooquxbaz&#x27;</code>
        </deckgo-highlight-code><p>给这个方法传入非正则表达式会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.replace</code>函数以取代对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。返回的值没有限制：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class FooReplacer {
  static [Symbol.replace](target, replacement) {
    return target.split(&#x27;foo&#x27;).join(replacement)
  }
}

console.log(&#x27;barfoobaz&#x27;.replace(FooReplacer, &#x27;qux&#x27;))
// &quot;barquxbaz&quot;

class StringReplacer {
  constructor(str) {
    this.str = str
  }

  [Symbol.replace](target, replacement) {
    return target.split(this.str).join(replacement)
  }
}

console.log(&#x27;barfoobaz&#x27;.replace(new StringReplacer(&#x27;foo&#x27;), &#x27;qux&#x27;))
// &quot;barquxbaz&quot;</code>
        </deckgo-highlight-code><h3><code>Symbol.search</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用“。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认由这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(RegExp.prototype[Symbol.search])
// f [Symbol.search]() { [native code] }

console.log(&#x27;foobar&#x27;.search(/bar/))
// 3</code>
        </deckgo-highlight-code><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class FooSearcher {
  static [Symbol.search](target) {
    return target.indexOf(&#x27;foo&#x27;)
  }
}

console.log(&#x27;foobar&#x27;.search(FooSearcher)) // 0
console.log(&#x27;barfoo&#x27;.search(FooSearcher)) // 3
console.log(&#x27;barbaz&#x27;.search(FooSearcher)) // -1

class StringSearcher {
  constructor(str) {
    this.str = str
  }

  [Symbol.search](target) {
    return target.indexOf(this.str)
  }
}

console.log(&#x27;foobar&#x27;.search(new StringSearcher(&#x27;foo&#x27;))) // 0
console.log(&#x27;barfoo&#x27;.search(new StringSearcher(&#x27;foo&#x27;))) // 3
console.log(&#x27;barbaz&#x27;.search(new StringSearcher(&#x27;qux&#x27;))) // -1</code>
        </deckgo-highlight-code><h3><code>Symbol.species</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，对于内置类型实例方法的返回值暴露实例化派生对象的方法。用<code>Symbol.species</code>定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Bar extends Array {}
class Baz extends Array {
  static get [Symbol.species]() {
    return Array
  }
}

let bar = new Bar()
console.log(bar instanceof Array) // true
console.log(bar instanceof Bar) // true
bar = bar.concat(&#x27;bar&#x27;)
console.log(bar instanceof Array) // true
console.log(bar instanceof Bar) // true

let baz = new Baz()
console.log(baz instanceof Array) // true
console.log(baz instanceof Baz) // true
baz = baz.concat(baz)
console.log(baz instanceof Array) // true
console.log(baz instanceof Baz) // false</code>
        </deckgo-highlight-code><blockquote><p>关于这个内置符号的使用，可以参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species#%E7%A4%BA%E4%BE%8B">MDN 上的示例</a>。</p></blockquote><h3><code>Symbol.split</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用”。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数。</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">console.log(RegExp.prototype[Symbol.split])
// f [Symbol.split]() { [native code] }

console.log(&#x27;foobarbaz&#x27;.split(/bar/))
// [&#x27;foo&#x27;, &#x27;baz&#x27;]</code>
        </deckgo-highlight-code><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class FooSpliter {
  static [Symbol.split](target) {
    return target.split(&#x27;foo&#x27;)
  }
}

console.log(&#x27;barfoobaz&#x27;.split(FooSplitter))
// [&quot;bar&quot;, &quot;baz&quot;]

class StringSplitter {
  constructor(str) {
    this.str = str
  }

  [Symbol.split](target) {
    return target.split(this.str)
  }
}

console.log(&#x27;barfoobaz&#x27;.split(new StringSplitter(&#x27;foo&#x27;)))
// [&quot;bar&quot;, &quot;baz&quot;]</code>
        </deckgo-highlight-code><h3><code>Symbol.toPrimitive</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p><p>根据提供给这个函数的参数（<code>sting</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">class Foo {}
let foo = new Foo()

console.log(3 + foo) // &quot;3[object Object]&quot;
console.log(3 - foo) // NaN
console.log(String(foo)) // &quot;[object Object]&quot;

class Bar {
  constructor() {
    this[Symbol.toPrimitive] = function (hint) {
      switch (hint) {
        case &#x27;number&#x27;:
          return 3
        case &#x27;stirng&#x27;:
          return &#x27;string bar&#x27;
        default:
          return &#x27;default bar&#x27;
      }
    }
  }
}

let bar = new Bar()

console.log(3 + bar) // &quot;3default bar&quot;
console.log(3 - bar) // 0
console.log(String(bar)) // &quot;string bar&quot;</code>
        </deckgo-highlight-code><h3><code>Symbol.toStringTag</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用”。</p><p>通过<code>toString()</code>方法获取对象标识事，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义实例还需要明确定义：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const s = new Set()

console.log(s) // Set(0) {}
console.log(s.toString()) // [object Set]
console.log(s[Symbol.toStringTag]) // Set

class Foo {}
const foo = new Foo()

console.log(foo) // Foo {}
console.log(foo.toString()) // [object Object]
console.log(foo[Symbol.toStringTag]) // undefined

class Bar {
  constructor() {
    this[Symbol.toStringTag] = &#x27;Bar&#x27;
  }
}
const bar = new Bar()

console.log(bar) // Bar {}
console.log(bar.toString()) // [object Bar]
console.log(bar[Symbol.toStringTag]) // Bar</code>
        </deckgo-highlight-code><h3><code>Symbol.unscopables</code></h3><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联的<code>with</code>环境绑定中排除”。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>绑定环境中，如下所示：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const o = { foo: &#x27;bar&#x27; }

with (o) {
  console.log(bar) // bar
}

o[Symbol.unscopables] = {
  foo: true,
}

with (o) {
  console.log(foo) // RefereceError
}</code>
        </deckgo-highlight-code><blockquote><p>注意：不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p></blockquote><h2><code>Object</code>类型</h2><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。开发者可以通过创建<code>Object</code>类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const o = new Object()</code>
        </deckgo-highlight-code><p>这个语法类似 Java，但是 ECMAScript 值要求在给构造函数提供参数时使用括号。如果没有参数，如上面例子所示，那么完全可以省略括号（不推荐）：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">const o = new Object() // 合法，但是不推荐</code>
        </deckgo-highlight-code><p><code>Object</code>的实例本身不是很有用，但是理解与它相关的概念非常重要。类似 Java 中的<code>java.lang.Object</code>，ECMAScript 中的<code>Object</code>也是派生其他对象的基类。<code>Object</code>类型的所有属性和方法在派生的对象上同样存在。</p><p>每个<code>Object</code>实例都有如下属性和方法；</p><ul><li><code>constructor</code>：用于创建当前对象的函数。在前面的例子中，这个属性的值就是<code>Object()</code>函数。</li><li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（例如<code>o.hasOwnProperty(&#x27;name&#x27;)</code>或符号。</li><li><code>isPrototypeOf(object)</code>：用于判断当前对象是否为另一个对象的原型。</li><li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：将对象转换为原始值。很少需要自己调用<code>valueOf()</code>方法，当遇到要预期的原始值的对象时，JavaScript 会自动调用它。</li></ul><blockquote><p>注：这里《JavaScript 高级程序设计第 4 版》所写“返回对象对应的字符串、数值或布尔值表示。通常与 <code>toString()</code>的返回值相同。“阐述并不准确，可参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf">MDN 文档</a>。</p></blockquote><p>因为在 ECMAScript 中<code>Object</code>是所有对象的基类，所以任何对象都有这些属性和方法。</p><blockquote><p>严格来讲，ECMA-262 中的对象行为不一定适合 JavaScript 中的其他对象。例如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承<code>Object</code>。</p></blockquote><h1>操作符</h1><p>ECMA-262 描述了一组可用于操作数据值的<strong>操作符</strong>，包括数学操作符（例如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和/或<code>toString()</code>方法来取得可以计算的值。</p><h2>一元操作符</h2><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator）。一元操作符是 ECMAScript 中最简单的操作符。</p><h3>递增/递减操作符</h3><p>递增和递减操祖父直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加 1，把两个加号（<code>++</code>）放到变量前头即可：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let age = 29
++age</code>
        </deckgo-highlight-code><p>在这个例子中，前缀递增操作符把<code>age</code>的值变成了 30。因此等价于：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let age = 29
age = age + 1</code>
        </deckgo-highlight-code><p>前缀递减操作符也类似，只不过是从一个数值减 1。使用前缀递减操作符，只要把两个减号（<code>--</code>）放到变量前头即可：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let age = 29
--age</code>
        </deckgo-highlight-code><p>执行之后，<code>age</code>的值变成了 28。</p><p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong>副作用</strong>。）看下面的例子：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let age = 29
let anotherAge = --age + 2

console.log(age) // 28
console.log(anotherAge) // 30</code>
        </deckgo-highlight-code><p>在这个例子中，变量<code>anotherAge</code>以<code>age</code>减 1 后的值再加 2 进行初始化。因为递减操作先发生，所以<code>age</code>的值先变成 28，然后再加 2，结果是 30。</p><p>前缀递增和递减语句中的优先级是相等的，因此会从左到右依次求值。例如：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num1 = 2
let num2 = 20
let num3 = --num1 + num2
let num4 = num1 + num2

console.log(num3) // 21
console.log(num4) // 21</code>
        </deckgo-highlight-code><p>递增和递减的后缀版语法一样，只不过要放在变量后面。后缀版本和前缀版本的区别在于，后缀版本递增和递减在语句被求值后才发生。</p><p><strong>这四个操作符可以作用于任何值</strong>，<strong>意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以</strong>。递增和递减操作符遵循如下规则：</p><ul><li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</li><li>对于字符串，如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。</li><li>对于布尔值，如果是<code>false</code>，则转换为 0 再应用改变。变量类型从布尔值变成数值。</li><li>对于布尔值，如果是<code>true</code>，则转换为 1 再应用改变。变量类型从布尔值变成数值。</li><li>对于浮点值，加 1 或减 1。</li><li>如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</li></ul><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let s1 = &#x27;2&#x27;
let s2 = &#x27;z&#x27;
let b = false
let f = 1.1
let o = {
  valueOf() {
    return -1
  },
}

console.log(++s1)
console.log(++s2)
console.log(++b)
console.log(--f)
console.log(--o)

// 3
// NaN
// 1
// 0.10000000000000009
// - 2</code>
        </deckgo-highlight-code><h3>一元加和减</h3><p>一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在数学的用途类似。一元加由一个加号表示，放在变量前面，对数值没有任何影响：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let num = -22.5
console.log(+num) // -22.5</code>
        </deckgo-highlight-code><p>如果将一元加应用到非数值，则会执行与使用<code>Number()</code>转型函数一样的类型转换：布尔值<code>false</code>和<code>true</code>转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的<code>valueOf()</code>和/或<code>toString()</code>方法可以得到转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><deckgo-highlight-code language="jsx" theme="one-dark">
          <code slot="code">let s1 = &#x27;01&#x27;
let s2 = &#x27;1.1&#x27;
let s3 = &#x27;z&#x27;
let b = false
let f = 1.1
let o = {
  valueOf() {
    return -1
  },
}

console.log(+s1)
console.log(+s2)
console.log(+s3)
console.log(+b)
console.log(+f)
console.log(+o)

// 1
// 1.1
// NaN
// 0
// 1.1
// -1</code>
        </deckgo-highlight-code><p>一元减由一个减号（<code>-</code>）表示，放在变量前头，主要用于把数值变成其相反数值。如果应用到非数值，会遵循和一元加同样的规则，先对它们进行转换，然后再取负值。</p><p>一元加和减操作符主要用于基本算术，但也可以像上面例子一样，用于数据类型转换。</p><h2>位操作符</h2><p>位操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ECMAScript 中的所有数字都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是<strong>先把值转换为 32 位整数</strong>再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。</p><p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一个位称为<strong>符号位</strong>（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。例如，数值 18 的二进制格式为 00000000000000000000000000010010。</p><p>负值以一种称为<strong>二补数</strong>（补码）的二进制编码存储。一个数值的补码通过如下 3 个步骤计算得到：</p><ul><li>确定绝对值的二进制表示</li><li>找到数值的一补数（反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0</li><li>给结果加 1</li></ul><blockquote><p>“补码系统的最大优点就是可以在加法或减法处理中，不许因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有符号加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有符号数加法及减法，在电路设计上相当方便。另外，补码系统的 0 只有一个表示方式，这和反码系统不同（0 有两种表示方式），因此在判断数值是否为 0 时，只要比较一次即可。” —— <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">维基百科</a></p></blockquote></div><div class="navigator-switch" style="display:none"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="list" class="svg-inline--fa fa-list " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M88 48C101.3 48 112 58.75 112 72V120C112 133.3 101.3 144 88 144H40C26.75 144 16 133.3 16 120V72C16 58.75 26.75 48 40 48H88zM480 64C497.7 64 512 78.33 512 96C512 113.7 497.7 128 480 128H192C174.3 128 160 113.7 160 96C160 78.33 174.3 64 192 64H480zM480 224C497.7 224 512 238.3 512 256C512 273.7 497.7 288 480 288H192C174.3 288 160 273.7 160 256C160 238.3 174.3 224 192 224H480zM480 384C497.7 384 512 398.3 512 416C512 433.7 497.7 448 480 448H192C174.3 448 160 433.7 160 416C160 398.3 174.3 384 192 384H480zM16 232C16 218.7 26.75 208 40 208H88C101.3 208 112 218.7 112 232V280C112 293.3 101.3 304 88 304H40C26.75 304 16 293.3 16 280V232zM88 368C101.3 368 112 378.7 112 392V440C112 453.3 101.3 464 88 464H40C26.75 464 16 453.3 16 440V392C16 378.7 26.75 368 40 368H88z"></path></svg></div><div class="article-navigator" style="display:block"><div class="article-navigator-toggler"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="xmark" class="svg-inline--fa fa-xmark " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"></path></svg></div><h4>数据结构和算法</h4><p title="算法与数据结构——数组" class="">算法与数据结构——数组</p><h4>electron</h4><p title="electron中的进程模型" class="">electron中的进程模型</p><h4>前端杂谈</h4><p title="跨源资源共享（CORS）" class="">跨源资源共享（CORS）</p><p title="关于no-cors的误区" class="">关于no-cors的误区</p><p title="地图工具中的线条吸附——一个简单方案" class="">地图工具中的线条吸附——一个简单方案</p><p title="渲染页面：浏览器的工作原理" class="">渲染页面：浏览器的工作原理</p><p title="React diffing算法" class="">React diffing算法</p><p title="Vercel简介 静态博客部署" class="">Vercel简介 静态博客部署</p><h4>抄书系列——“红宝书”</h4><p title="红宝书系列（一）什么是JavaScript？" class="">红宝书系列（一）什么是JavaScript？</p><p title="红宝书系列（二）HTML中的JavaScript" class="">红宝书系列（二）HTML中的JavaScript</p><p title="红宝书系列（三）JavaScript语言基础" class="highlighted-navigator-item">红宝书系列（三）JavaScript语言基础</p><p title="红宝书系列（四）变量、作用域与内存" class="">红宝书系列（四）变量、作用域与内存</p><p title="红宝书系列（六）集合引用类型" class="">红宝书系列（六）集合引用类型</p><p title="红宝书系列（七）迭代器与生成器" class="">红宝书系列（七）迭代器与生成器</p><p title="红宝书系列（十一）期约与异步函数" class="">红宝书系列（十一）期约与异步函数</p><p title="红宝书系列（十四）DOM" class="">红宝书系列（十四）DOM</p><p title="红宝书系列（十五）DOM扩展" class="">红宝书系列（十五）DOM扩展</p><p title="红宝书系列（十七）事件" class="">红宝书系列（十七）事件</p><p title="红宝书系列（二十）JavaScript API" class="">红宝书系列（二十）JavaScript API</p><p title="红宝书系列（二十三）JSON" class="">红宝书系列（二十三）JSON</p><p title="红宝书系列（二十四）网络请求与远程资源" class="">红宝书系列（二十四）网络请求与远程资源</p><p title="红宝书系列（二十五）客户端存储" class="">红宝书系列（二十五）客户端存储</p></div>0</main><footer class="footer"><div class="wrapper"><p style="font-size:1.3rem"><span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="weixin" class="svg-inline--fa fa-weixin " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M385.2 167.6c6.4 0 12.6 .3 18.8 1.1C387.4 90.3 303.3 32 207.7 32 100.5 32 13 104.8 13 197.4c0 53.4 29.3 97.5 77.9 131.6l-19.3 58.6 68-34.1c24.4 4.8 43.8 9.7 68.2 9.7 6.2 0 12.1-.3 18.3-.8-4-12.9-6.2-26.6-6.2-40.8-.1-84.9 72.9-154 165.3-154zm-104.5-52.9c14.5 0 24.2 9.7 24.2 24.4 0 14.5-9.7 24.2-24.2 24.2-14.8 0-29.3-9.7-29.3-24.2 .1-14.7 14.6-24.4 29.3-24.4zm-136.4 48.6c-14.5 0-29.3-9.7-29.3-24.2 0-14.8 14.8-24.4 29.3-24.4 14.8 0 24.4 9.7 24.4 24.4 0 14.6-9.6 24.2-24.4 24.2zM563 319.4c0-77.9-77.9-141.3-165.4-141.3-92.7 0-165.4 63.4-165.4 141.3S305 460.7 397.6 460.7c19.3 0 38.9-5.1 58.6-9.9l53.4 29.3-14.8-48.6C534 402.1 563 363.2 563 319.4zm-219.1-24.5c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.8 0 24.4 9.7 24.4 19.3 0 10-9.7 19.6-24.4 19.6zm107.1 0c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.5 0 24.4 9.7 24.4 19.3 .1 10-9.9 19.6-24.4 19.6z"></path></svg></span><span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="qq" class="svg-inline--fa fa-qq " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433.8 420.4c-11.53 1.393-44.86-52.74-44.86-52.74 0 31.34-16.14 72.25-51.05 101.8 16.84 5.192 54.84 19.17 45.8 34.42-7.316 12.34-125.5 7.881-159.6 4.037-34.12 3.844-152.3 8.306-159.6-4.037-9.045-15.25 28.92-29.21 45.78-34.42-34.92-29.54-51.06-70.44-51.06-101.8 0 0-33.33 54.13-44.86 52.74-5.37-.65-12.42-29.64 9.347-99.7 10.26-33.02 21.1-60.48 40.14-105.8C60.68 98.06 108.1 .006 224 0c113.7 .006 163.2 96.13 160.3 214.1 18.12 45.22 29.91 72.85 40.14 105.8 21.77 70.06 14.72 99.05 9.346 99.7z"></path></svg></span><span><a href="mailto:k1664032884@gmail.com"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="envelope" class="svg-inline--fa fa-envelope " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 352c-16.53 0-33.06-5.422-47.16-16.41L0 173.2V400C0 426.5 21.49 448 48 448h416c26.51 0 48-21.49 48-48V173.2l-208.8 162.5C289.1 346.6 272.5 352 256 352zM16.29 145.3l212.2 165.1c16.19 12.6 38.87 12.6 55.06 0l212.2-165.1C505.1 137.3 512 125 512 112C512 85.49 490.5 64 464 64h-416C21.49 64 0 85.49 0 112C0 125 6.01 137.3 16.29 145.3z"></path></svg></a></span><span><a href="https://github.com/kqhasaki" target="_blank" rel="noreferrer"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></span><span><a href="/static/resume-ef27ab676ea536646634203d2696b372.pdf" download="resume.pdf" title="简历下载"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="file" class="svg-inline--fa fa-file " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M256 0v128h128L256 0zM224 128L224 0H48C21.49 0 0 21.49 0 48v416C0 490.5 21.49 512 48 512h288c26.51 0 48-21.49 48-48V160h-127.1C238.3 160 224 145.7 224 128z"></path></svg></a></span><span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"></path></svg></span></p><p>CopyRight © 2022 Louis K</p></div><div class="wrapper" style="align-items:flex-end"><h3>Links</h3><ul><li><span><a href="https://reactjs.org/" rel="noreferrer" target="_blank">React</a></span></li><li><span><a href="https://developer.mozilla.org/zh-CN/" rel="noreferrer" target="_blank">MDN</a></span></li><li><span><a href="https://leafletjs.com/reference.html" rel="noreferrer" target="_blank">Leaflet</a></span></li><li><span><a href="https://ant.design/index-cn" rel="noreferrer" target="_blank">Ant Design</a></span></li><li><span><a href="https://webpack.docschina.org/concepts/" rel="noreferrer" target="_blank">webpack</a></span></li></ul></div></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/articles/redbook-series/redbook-chapter03/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-a6a9e8476add1045c345.js"],"app":["/app-482b53f1cff3eb5f0e6d.js"],"component---src-pages-404-js":["/component---src-pages-404-js-54d2912befce789e6bfb.js"],"component---src-pages-articles-mdx-slug-js":["/component---src-pages-articles-mdx-slug-js-e4bb5d7bfe68b7d30d0d.js"],"component---src-pages-index-js":["/component---src-pages-index-js-c311ab3b0e843407d509.js"],"component---src-pages-non-tech-js":["/component---src-pages-non-tech-js-b2eb9ba93af5834cd9e7.js"]};/*]]>*/</script><script src="/polyfill-a6a9e8476add1045c345.js" nomodule=""></script><script src="/component---src-pages-articles-mdx-slug-js-e4bb5d7bfe68b7d30d0d.js" async=""></script><script src="/commons-be2d4d65e68c8bdaf6be.js" async=""></script><script src="/a9a7754c-992c6b2080a7db331a45.js" async=""></script><script src="/cb1608f2-001f1ae553ac1c271243.js" async=""></script><script src="/app-482b53f1cff3eb5f0e6d.js" async=""></script><script src="/framework-f27b074ecebec0f1dbc4.js" async=""></script><script src="/webpack-runtime-6810787f743bb0650217.js" async=""></script></body></html>