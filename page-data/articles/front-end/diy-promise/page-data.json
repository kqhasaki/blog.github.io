{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/articles/front-end/diy-promise",
    "result": {"pageContext":{"data":{"previous":{"slug":"front-end/cors-mdn","frontmatter":{"title":"跨源资源共享（CORS）"}},"next":{"slug":"front-end/eslint-and-prettier","frontmatter":{"title":"利用ESLint、Prettier统一团队内代码风格"}},"node":{"id":"feb73e70-97b5-566a-8fe7-037af5ced40c","frontmatter":{"cover":"https://tva1.sinaimg.cn/large/e6c9d24egy1h36lrpee4jj20ka0f8js8.jpg","date":"2022-06-13","title":"手动实现一个Promise"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"手动实现一个Promise\",\n  \"cover\": \"https://tva1.sinaimg.cn/large/e6c9d24egy1h36lrpee4jj20ka0f8js8.jpg\",\n  \"date\": \"2022-06-13T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"jsx\",\n    \"theme\": \"one-dark\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"const PENDING = 'pending'\\nconst FULFILLED = 'fulfilled'\\nconst REJECTED = 'rejected'\\n\\nconst resolvePromise = (promise, x, resolve, reject) => {\\n  if (promise === x) {\\n    return reject(\\n      new TypeError('Chaining cycle detected for promise#<MyPromise>')\\n    )\\n  }\\n\\n  let called\\n\\n  if ((typeof x === 'object' && x !== null) || typeof x === 'function') {\\n    try {\\n      const then = x.then\\n      if (typeof then === 'function') {\\n        then.call(\\n          x,\\n          y => {\\n            if (called) return\\n            called = true\\n            resolvePromise(promise, y, resolve, reject)\\n          },\\n          r => {\\n            if (called) return\\n            called = true\\n            reject(r)\\n          }\\n        )\\n      } else {\\n        resolve(x)\\n      }\\n    } catch (err) {\\n      if (called) return\\n      called = true\\n      reject(err)\\n    }\\n  }\\n}\\n\\nclass MyPromise {\\n  constructor(executor) {\\n    this.status = PENDING\\n    this.value = undefined\\n    this.reason = undefined\\n\\n    this.onResolvedCallbacks = []\\n    this.onRejectedCallbacks = []\\n\\n    const resolve = value => {\\n      if (value instanceof Promise) {\\n        return value.then(resolve, reject)\\n      }\\n      if (this.status === PENDING) {\\n        this.status = FULFILLED\\n        this.value = value\\n        this.onResolvedCallbacks.forEach(fn => fn())\\n      }\\n    }\\n\\n    const reject = reason => {\\n      if (this.status === PENDING) {\\n        this.status = REJECTED\\n        this.reason = reason\\n        this.onRejectedCallbacks.forEach(fn => fn())\\n      }\\n    }\\n\\n    try {\\n      executor(resolve, reject)\\n    } catch (err) {\\n      reject(err)\\n    }\\n  }\\n\\n  then(onFulfilled, onRejected) {\\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v\\n    onRejected =\\n      typeof onRejected === 'function'\\n        ? onRejected\\n        : err => {\\n            throw err\\n          }\\n\\n    const _promise = new MyPromise((resolve, reject) => {\\n      if (this.status === FULFILLED) {\\n        setTimeout(() => {\\n          try {\\n            let x = onFulfilled(this.value)\\n            resolvePromise(_promise, x, resolve, reject)\\n          } catch (err) {\\n            reject(err)\\n          }\\n        }, 0)\\n      }\\n\\n      if (this.status === REJECTED) {\\n        setTimeout(() => {\\n          try {\\n            const x = onRejected(this.reason)\\n            resolvePromise(_promise, x, resolve, reject)\\n          } catch (err) {\\n            reject(err)\\n          }\\n        }, 0)\\n      }\\n\\n      if (this.status === PENDING) {\\n        this.onResolvedCallbacks.push(() => {\\n          setTimeout(() => {\\n            try {\\n              const x = onFulfilled(this.value)\\n              resolvePromise(_promise, x, resolve, reject)\\n            } catch (err) {\\n              reject(err)\\n            }\\n          }, 0)\\n        })\\n\\n        this.onRejectedCallbacks.push(() => {\\n          setTimeout(() => {\\n            try {\\n              const x = onRejected(this.reason)\\n              resolvePromise(_promise, x, resolve, reject)\\n            } catch (err) {\\n              reject(err)\\n            }\\n          }, 0)\\n        })\\n      }\\n    })\\n\\n    return _promise\\n  }\\n\\n  catch(errCallback) {\\n    return this.then(null, errCallback)\\n  }\\n\\n  finally(callback) {\\n    return this.then(\\n      value => {\\n        return MyPromise.resolve(callback().then(() => value))\\n      },\\n      reason => {\\n        return MyPromise.resolve(\\n          callback().then(() => {\\n            throw reason\\n          })\\n        )\\n      }\\n    )\\n  }\\n\\n  static all(values) {\\n    if (!Array.isArray(values)) {\\n      const type = typeof values\\n      return new TypeError(`TypeError: ${type} ${values} is not iterable`)\\n    }\\n\\n    return new MyPromise((resolve, reject) => {\\n      const resultArr = []\\n      let orderIdx = 0\\n      const processResultByKey = (value, index) => {\\n        resultArr[index] = value\\n        if (++orderIdx === values.length) {\\n          resolve(resultArr)\\n        }\\n      }\\n\\n      for (let i = 0; i < values.length; i++) {\\n        const value = values[i]\\n        if (value && typeof value.then === 'function') {\\n          value.then(value => {\\n            processResultByKey(value, i)\\n          }, reject)\\n        } else {\\n          processResultByKey(value, i)\\n        }\\n      }\\n    })\\n  }\\n\\n  static race(values) {\\n    if (!Array.isArray(values)) {\\n      const type = typeof values\\n      return new TypeError(`TypeError: ${type} ${values} is not iterable`)\\n    }\\n\\n    return new MyPromise((resolve, reject) => {\\n      for (let i = 0; i < values.length; i++) {\\n        const val = values[i]\\n        if (val && typeof val.then === 'function') {\\n          val.then(resolve, reject)\\n        } else {\\n          resolve(val)\\n        }\\n      }\\n    })\\n  }\\n\\n  static resolve(data) {\\n    return new MyPromise(resolve => {\\n      resolve(data)\\n    })\\n  }\\n\\n  static reject(reason) {\\n    return new Promise((_, reject) => {\\n      reject(reason)\\n    })\\n  }\\n}\\n\\nconst promise = new MyPromise((resolve, reject) => {\\n  reject('\\u5931\\u8D25')\\n})\\n  .then()\\n  .then()\\n  .then(\\n    data => {\\n      console.log(data)\\n    },\\n    err => {\\n      console.error('error', err)\\n    }\\n  )\"), \"\\n        \"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"front-end/diy-promise","wordCount":{"sentences":0}}},"next":{"slug":"front-end/eslint-and-prettier","frontmatter":{"title":"利用ESLint、Prettier统一团队内代码风格"}},"previous":{"slug":"front-end/cors-mdn","frontmatter":{"title":"跨源资源共享（CORS）"}}}},
    "staticQueryHashes": ["2757060725","3605573801"]}